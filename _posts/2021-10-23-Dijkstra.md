---
title:  "[Algorithm] Dijkstra"
excerpt: "다익스트라 알고리즘"

categories:
  - Algorithm
tags:
  - [Algorithm]

toc: true
toc_sticky: true
 
date: 2021-10-23
last_modified_at: 2021-10-23
---

# ▶️ 다익스트라(Dijkstra Algorithm)

다익스트라 알고리즘은 DP(Dynamic Programming)을 활용해서 최단거리를 계산할 수 있는 알고리즘이다

특정한 하나의 정점에서 다른 정점으로 가는 최단 경로를 저장한다

**출발점이 있고, 어느 정점으로 가야하는 경우에는 다익스트라 알고리즘을 고려해봐야한다!!**
{: .notice}

![dijkstra](../../imgs/dijkstra_graph.png)

만약 위와 같은 그래프에서 1번 노드에서 2번 노드까지의 최단거리를 구한다면 하나의 간선으로 이루어진 경로(12)로 가는 것보다 3번 4번 노드를 거쳐 가는 경로(11)가 더 최단경로가 된다

최단 경로를 구해야하기 때문에 노드가 많이 존재하는 경우 시간복잡도 logN을 가지는 MinHeap을 이용하기도 한다

```js
class MinHeap{
  constructor() {
    this.heap = [];
    this.heap.push(-1e9);    // 큰 값을 제일 앞에 넣어준다
  }

  // heap에 데이터를 삽입
  insert(a, b){
    this.heap.push([a, b]);
    // 값이 들어오면 작거나 큼에 따라 위로 올려준다
    this.upheap(this.heap.length - 1);
  }


  // insert된 값을 올려주는 메소드
  upheap(pos){
    // 마지막으로 들어온 값을 temp에 할당
    let temp = this.heap[pos];

    // 부모노드와 비교하며 현시점의 부모보다 크면 부모노드의 값을 아래로 내림
    while(temp[1] < this.heap[parseInt(pos/2)][1]){
      this.heap[pos] = this.heap[parseInt(pos/2)];
      pos = parseInt(pos/2);
    }
    // 마지막으로 현시점의 노드에 temp값을 넣어준다
    this.heap[pos] = temp;
  }


  // 루트노드를 가져오는 메소드
  get(){
    // 만약 heap의 크기가 0인데 pop을 하려고 하면 false반환
    if (this.size() === 0) return false;
    // 만약 heap의 크기가 2라면 downheap()을 하지않고 pop만 수행
    if (this.size() === 1) return this.heap.pop();
    // 루트노드값을 result 변수에 임시저장하고, 루트노드 자리에 제일 마지막 노드를 위치시킨다
    const result = this.heap[1];
    this.heap[1] = this.heap.pop();
    // 아래로 진행하면서 자리배치
    this.downheap(1, this.heap.length-1);
    return result;
  }

  downheap(pos, len){
    // 루트노드에 위치한 값을 임시 저장
    let temp = this.heap[pos], child;
    while(pos <= parseInt(len/2)){
      child = pos * 2;        // 왼쪽 자식
      // 자식노드가 하나만 존재할 수 있기 때문에 child < len
      if(child < len && this.heap[child][1] > this.heap[child+1][1]) child++;      // +1로 오른쪽자식과 비교한다 
      // 자식노드보다 크다면 멈춘다
      if(temp[1] <= this.heap[child][1]) break;
      // 자식노드와 부모노드의 자리를 교환
      this.heap[pos] = this.heap[child];
      // 인덱스를 아래로 옮김
      pos = child;
    }
    // 현재 시점의 노드에 값 할당
    this.heap[pos] = temp;
  }

  // heap의 크기를 반환하는 메서드
  size(){
    return this.heap.length-1;
  }
}
```

## ▷ 다익스트라 문제

[프로그래머스 - 배달](https://programmers.co.kr/learn/courses/30/lessons/12978)

### → 문제 설명
> N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.

![배달](../../imgs/프로그래머스-배달.png)

> 위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.
마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.

### → 제한사항
> 마을의 개수 N은 1 이상 50 이하의 자연수입니다.
road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.
road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.
road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.
a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.
두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.
한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.
K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.
임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.
1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.

### → 입출력 예

| N | road | K | result |
|:---:|:---|:---:|:---:|
| 5 | [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]] | 3 | 4 |
| 6 | [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]] | 4 | 4 |


### → 풀이
```js
class minHeap{
  constructor(){
    this.heap=[];
    this.heap.push([Number.MIN_SAFE_INTEGER, 0]);
  }
  insert([a, b]){
    this.heap.push([a, b]);
    this.upheap(this.heap.length-1);
  }
  upheap(pos){
    let tmp=this.heap[pos];
    while(tmp[1]<this.heap[parseInt(pos/2)][1]){
      this.heap[pos]=this.heap[parseInt(pos/2)];
      pos=parseInt(pos/2);
    }
    this.heap[pos]=tmp;
  }
  get(){
    if(this.heap.length===2){
      return this.heap.pop();
    }
    let res;
    res=this.heap[1];
    this.heap[1]=this.heap.pop();
    this.downheap(1, this.heap.length-1);
    return res;
  }
  downheap(pos, len){
    let tmp, i;
    tmp=this.heap[pos];
    while(pos<=parseInt(len/2)){
      i=pos*2;
      if(i<len && this.heap[i][1]<this.heap[i+1][1]) i++;
      if(tmp[1]<=this.heap[i][1]) break;
      this.heap[pos]=this.heap[i];
      pos=i;
    }
    this.heap[pos]=tmp;
  }
  size(){
    return this.heap.length-1;
  }
  top(){
    return this.heap[1];
  }
}

function solution(N, road, K) {
  let answer = 0;
  // MinHeap을 사용
  let heap = new minHeap();
  
  // 입력을 graph화할 이차원 배열 생성
  let graph = Array.from(Array(N+1), () => Array());
  
  // 각 노드를 기준으로 최단거리를 저장할 배열
  let dist = Array.from({length:N+1}, () => 700000);

  // 입력을 인접리스트형태로 변환
  for(let [a, b, c] of road){
    graph[a].push([b, c]);
    graph[b].push([a, c]);
  }

  // 초기값 (첫번째 노드로 가는 비용은 0)
  dist[1] = 0;    
  heap.insert([1, 0]);  

  while(heap.size() > 0){
    let tmp = heap.get();
    let now = tmp[0];
    let nowCost = tmp[1];

    // 만약 현재 구한값(minheap에 있던값)이 더 작으면 아래 코드를 진행하지 않도록
    if(nowCost > dist[now]) continue;

    for(let [next, cost] of graph[now]){
      // 계산한 값 (MinHeap에 있던 값)이 더 작으면 갱신
      if(nowCost + cost < dist[next]){
        dist[next] = nowCost + cost;
        // 다음 계산을 위해 heap에 넣어줌
        heap.insert([next, dist[next]]);
      }
    }
  }

  // K를 넘는 값을 카운팅
  for(const d of dist){
    if(d <= K) answer++;
  }
  return answer;
}
```

자동으로 최소값을 루트노드로 올려주는 MinHeap을 이용해서 하나씩 추출하고, 그 값을 최단거리를 저장하는 `dist` 배열의 값과 비교하면서 계속해서 **최단거리를 갱신해준다**






