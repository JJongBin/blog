var store = [{
        "title": "Jekyll 블로그 시작 🚀",
        "excerpt":"    블로그를 시작해볼까 고민한지만 벌써 몇 개월째…드디어 블로그를 시작하게 되었다.  꾸준히 포스팅하려는 의지를 불태우고자 이것저것 첫번째 글을 써보려고 한다.       1. Jekyll blog 개발 환경 셋팅    구글링을 통해서 jekyll 블로그를 알게 되었고, 프론트엔드 개발자를 지향하고 있는 나에게 네이버나 다음 블로그보다 도움이 될거라고 생각했다.  템플릿을 정해야한다고 하길래 이것 저것 찾아보다가 몇 몇분들이 추천해주시는 minimal-mistakes에 꽂혀 이 템플릿을 사용하게 되었다.   minimal-mistakes github 주소!  https://github.com/mmistakes/minimal-mistakes       이제 내 로컬 환경에서 Github에 올릴 수 있도록 셋팅을 해줘야 했는데 환경변수 때문에 너무 애를 먹었다. ruby나 gem 자체를 처음 이용해 보기도 해서 더욱 생소했던 것 같다. 하다하다 안되서 전부 삭제하고 다시 깔았다.   brew install ruby gem install --user-install bundler jekyll   위 명령어를 터미널에 입력해서 이 순서대로 진행했는데 환경변수를 잘못 적어서 시간이 오래걸렸다.  homebrew를 이용해서 ruby를 설치하고 패키지시스템과 같은 gem을 이용해서 bundler, jekyll을 설치하고, .zshrc 파일에 환경변수를 추가했다   ## 환경변수 export PATH=\"$HOME/.gem/ruby/3.0.0/bin:$PATH\" export PATH=\"/usr/local/opt/ruby/bin:/usr/local/lib/ruby/gems/3.0.0/bin:$PATH\"    이 사이트를 참고했다. 아니 거의 따라했다.  https://jekyllrb.com/docs/installation/macos/       bundle -v jekyll -v   이렇게 입력했을때 bundle과 jekyll의 버전이 제대로 출력되면 다왔다!  Bundler version 2.2.25  jekyll 4.2.0   bundle jekyll serve --port [port]   서버를 시작하려고 위 명령어를 입력했더니   cannot load such file -- webrick (LoadError)  …..??   이런 오류가 나와서 당황했는데 얼른 구글링 하니 어떤분께서 이 문제에 대해서 설명을 잘해주셨다.   bundle add webrick 이라는 명령어로 webrick을 추가해 주고 다시 실행하면 된다고 한다.   안됬던 이유는 ruby 3.0.0부터 webrick이 기본으로 포함된 gem에서 빠졌기 때문이라고 한다.   위 과정까지 다하고나니 http://localhost:[port]/로 내가 만들 블로그에 로컬환경에서 접속할 수 있었다.       2. 블로그를 시작한 이유   자바스크립트에 대한 이해가 부족하다고 생각했기 때문에 유투버분의 추천을 보고 모던 자바스크립트 Deep Dive 라는 책을 구매해서 읽기 시작했다. 책이 900페이지나 되길래 먼저 속독으로 한번 읽어보고 다시 읽어야겠다고 생각했다. 하지만 속독으로 읽더라도 어느정도 감이 와야하는데 대충 보고 넘기다보니 까먹고 다시 찾아보고 하는 과정이 반복이 됬다. 너무 쉽게 생각한 내 잘못이었다. 어떻게 하면 꾸준하게 꼼꼼히 내 지식으로 만들 수 있을까 고민을 하다가 “블로그에 내가 이해한 내용을 정리하면 좋지않을까?” 라는 생각을 하게 되었고, 한 포스팅 당 한 한 단락으로 구성해보자! 라고 다짐했다. 나중에 내가 까먹은 지식을 내가 이해했던 방법으로 좀 더 빠르게 다시 생각해 낼 수 있고, 아무래도 포스팅을 하려면 좀 더 깊게 알고 이해할 수 있을 것 같다.   모던 자바스크립트 Deep Dive는 총 49장 ( 변수 표현식 … 에러처리 모듈 등 )으로 구성이 되어있다. 굉장히 오래 걸릴 것 같지만 그 때의 뿌듯함이 벌써부터 기대가 된다. 이 외에 내가 습득했던 지식을 사용하지 않다보니 잊어버리는 경우가 꽤 많아서 다른 것들도 정리하려고 한다. 화이팅 나!         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시고 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["Blog"],
        "tags": ["Blog","jekyll"],
        "url": "/blog/startBlog/",
        "teaser": null
      },{
        "title": "[Deep Dive] 01장 프로그래밍",
        "excerpt":"    1. 프로그래밍이란?    프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션    프로그래밍 → 기계가 실행할 수 있도록 정확하고 상세하게 요구사항을 설명하는 작업   프로그래밍은 기계에게 설명하는 과정이므로 컴퓨터적 사고를 가지고 바라보아야한다.       2. 프로그래밍 언어   컴퓨터에게 전달한 명령은 사람이 이해하는 언어가 아닌 컴퓨터가 이해할 수 있는 기계어로 전달해줘야한다.   기계어는 사람이 이해하기 어렵기 때문에 사람이 이해하기 쉬운 프로그래밍 언어로 작성된 명령을 컴파일러를 통해 기계어로 바꿔준다.   사람의 프로그래밍 언어  →  컴파일러(변환)  →  컴퓨터의 기계어       3. 구문과 의미   사람이 이해하도록 만들어진 프로그래밍 언어는 c, c++, 파이썬, 자바, 자바스크립트 등이 있다.  이러한 프로그래밍 언어들은 흐름제어(변수, 값, 연산자, 표현식, 문, 조건문, 반복문), 함수, 객체, 배열등의 문법을 제공한다.      프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.          이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive01/",
        "teaser": null
      },{
        "title": "[Deep Dive] 02장 자바스크립트란?",
        "excerpt":"    1. 자바스크립트의 탄생   1995년 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 프로그래밍언어를 도입   → 브렌던 아이크가 개발한 자바스크립트         2. 자바스크립트의 표준화   자바스크립트의 파생버전이 출시 (Jscript) → 이로인해 브라우저들 사이에서 *크로스 브라우징 이슈 발생 → 표준화된 자바스크립트의 필요성이 생김   * 크로스 브라우징  브라우저에 따라 호환성이 다르기 때문에 웹페이지의 기능들이 정상적으로 동작하지 않음!     1997년 7월 표준화된 자바스크립트 사양인 ECMAScript 1(ES1)이 완성     이후 ES2, ES3 ... 2020년 ES11로 크고 작은 기능들이 추가되어 발표됨   범용 프로그래밍 언어로써 필요한 여러 기능들이 도입된 2015년 ECMAScript(ES6)                   버전       년도       특징                       ES6       2015       let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for…of, 제너레이터, Proxy, 모듈 import.export                 3. 자바스크립트 성장과 역사       Ajax            1999년 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 주고 받을 수 있는 통신 기능       기존의 웹페이지는 화면이 전환되면 전체 HTML을 받아 다시 랜더링       Ajax등장 이후 변경할 필요가 없는 부분은 두고 필요한 데이터만 받아 해당 부분 랜더링 → 리소스 절약, 빠른 성능과 부드러운 화면전환이 가능               jQuery            DOM을 더욱 쉽게 제어할 수 있음       크로스 브라우징 이슈도 어느 정도 해결               V8 자바스크립트 엔진            V8은 웹 브라우저 내부에서 자바스크립트 수행 속도의 개선을 목표로 처음 고안되었습니다. 속도 향상을 위해 V8은 인터프리터를 사용하는 대신 자바스크립트 코드를 더 효율적인 머신 코드로 번역합니다. 저스트인타임 컴파일러를 구현함으로써 코드를 실행 시에 자바스크립트 코드를 머신 코드로 컴파일하는데, 이는 스파이더몽키나 리노와 같은 현대적인 다른 자바스크립트 엔진에서도 마찬가지입니다. 주된 차이는 V8은 바이트코드와 같은 중간 코드를 생산하지 않는다는 점입니다.                Node.js            브라우저 이외에도 자바스크립트를 작동시킬 수 있도록함       비동기I/O 지원, 단일스레드 이벤트 루프 기반(요청 처리 성능이 좋음)       백엔드까지도 다룰 수 있음               SPA 프레임워크            Single Page Application(SAP)       Angular, React, Vue.js, Svelte …                    SPA 구현을 쉽게 말하면 jsp파일 없이 index.html파일 하나에서 js, css등 리소스 파일들과 모듈들을 로드해서 페이지 이동 없이 특정영역만 새로 모듈을 호출하고 데이터를 바인딩하는 개념.                                  4. 자바스크립트와 ECMAScript    자바스크립트는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API(DOM, BOM, Canvas, XNLHttpRequest, fetch 등)을 아우르는 개념 (자바스크립트 &gt; ECMAScript)         5. 자바스크립트의 특징       웹 브라우저에서 동작하는 유일한 프로그래밍 언어   별도의 컴파일을 하지 않는 *인터프리터 언어   *인터프리터 언어  코드가 실행되는 단계인 런타임에 문 단위로 한줄씩 중간 코드인 바이트 코드로 변환한 후 실행      멀티 패러다임 프로그래밍 언어(명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍)   자바스크립트는 프로토타입 기반의 객체지행 언어         6. ES6 브라우저 지원 현황      해당 링크에서 자세히 볼 수 있다.  https://kangax.github.io/compat-table/es6/   몇몇 브라우저에서 자바스크립트의 최신기능을 지원하지 않을 수도 있기 때문에 *바벨(Babel)을 이용할 필요가 있다   *바벨(Babel)  ES6+ 버전의 자바스크립트나 타입스크립트, JSX 등 다른 언어로 분류되는 언어들에 대해서도 모든 브라우저에서 동작할 수 있도록 호환성을 지켜준다. 바벨은 이렇게 추상화 수준을 유지한 채로 코드를 변화시키는 트랜스파일러의 역할을 한다.         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive02/",
        "teaser": null
      },{
        "title": "[Deep Dive] 03장 자바스크립트의 개발 환경과 실행 방법",
        "excerpt":"  이론적인 부분만 정리하고 설치부분은 건너뛰었다! 이미 설치 다 했으니깐!       1. 자바스크립트 실행 환경   모든 브라우저는 자바스크립트를 내장하고 있고, Node.js도 자바스크립트 엔진을 내장하고 있다.  하지만 브라우저와 Node.js의 자바스크립트에는 조금 차이가 있다.                  브라우저               Node.js                       렌더링이 주된 목적               브라우저 이외의 환경에서 자바스크립트 사용 가능                 DOM API 제공               DOM API 제공하지 않음                 파일시스템 제공하지 않음               파일시스템 제공                 Client-side API               Node.js Host API                 ECMAScript               ECMAScript           Client-side API  API는 사이트가 실행되고 있는 브라우저와 운영 체제의 다양한 부분 그리고 웹 사이트 혹은 서비스의 데이터를 다룰 수 있는 인터페이스이다.  Client-side API는 기능들을 미리 구현한 DOM, BOM, Canvas, XMLHttpRequest, fetchm requestAnimation Frame, SVG, Web Storage, Web Component, Web Worker         2. 웹 브라우저      개발자 도구      단축키                  운영체제       단축키                       윈도우       F12 / Ctrl + Shift + I                 macOS       command + option + I                 기능                  패널       설명                       Elements       웹페이지의 DOM, CSS를 볼 수 있고 수정도 가능하다.(저장은 되지 않음)                 Console       에러를 확인, 자바스크립트의 console.log()를 확인                 Source       웹페이지의 자바스크립트 코드 디버깅                 Network       네트워크 request 정보와 성능 확인                 Application       웹스토리지, 세션, 쿠키 확인 및 관리                 콘솔   콘솔창에 에러가 출력된다. 또한 디버깅하는 것보다 쉽게 결과를 확인할 수 있다.         디버깅   Source 패널로 이동 → 에러가 발생한 위치에 빨간 밑줄이 표시됨(에러내용이 간략하게 표시됨) → 에러가 발생한 부분 수정       3. Node.js    프로젝트 규모가 커짐에 따라 React, Angular, Vue.js, Lodash 프레임워크, 라이브러리 도입 필요 → Node.js, npm 필요   2009년 아이언 달이 발표한 Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경   Node.js  브라우저 이외의 환경에서의 자바스크립트 실행환경 제공    npm  자바스크립트 패키지 매니저  Node.js에서 사용할 수 있는 모듈들을 패키지화, 패키지 설치 및 관리   4. 자바스크립트 동작원리(추가)      간단하게만 설명하자면 변수 등을 저장하는 메모리 힙이 존재하고 자바스크립트 엔진의 스택은 필요한 변수 등이 있으면 메모리 힙을 참조해 한번에 하나의 명령을 수행한다.   자바스크립트 엔진의 스레드는 하나라고 하는데 웹페이지를 보면 여러 작업들이 동시에 진행이 되는걸 볼 수 있다.   이는 이벤트루프를 통해 일종의 대기실인 콜백큐에서 기다렸다가 자바스크립트 엔진의 스텍이 비어있으면 이벤트루프가 콜백큐의 작업을 하나씩 꺼내 실행이 되도록 스텍에 넣어준다.   이번엔 간략하게 요약했지만 다음번에 이 주제로 공부하고 포스팅해야겠다!         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive03/",
        "teaser": null
      },{
        "title": "[Deep Dive] 04장 변수",
        "excerpt":"    1. 변수    컴퓨터는 CPU를 통해 연산하고 메모리를 사용해 데이터를 기억한다.   * 메모리  - 데이터를 저장할 수 있는 데이터 셀의 집합.  - 메모리 셀 하나의 크기는 1바이트(8비트).  - 1바이트 단위로 저장하고 읽음.  - 각 셀은 고유한 메모리 주소를 가진다. - 저장되는 모든 값은 이진수로 저장된다.   메모리 주소를 통해 값에 접근하는 것은 치명적일 수 있다. 따라서 자바스크립트는 직접적인 메모리 제어를 허용하지 않음.   프로그래밍 언어는 기억할 값을 메모리에 저장하고, 저장된 값을 읽고 재사용하기 위해 변수라는 것을 사용함.   * 변수의 정의  하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.   → 변수란 값의 위치를 가르킴                     변수이름       메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름                 변수 값       변수에 저장된 값                 변수 할당       변수에 값을 저장하는 것                 변수 참조       변수에 저장된 값을 읽어들이는 것               2. 식별자   변수의 이름은 식별자라고 부르기도 함.   * 식별자  어떤 값을 구별해서 식별할 수 있는 고유한 이름.  식별자는 값을 저장하는 것이 아니라 메모리 주소를 기억하고 있다.      3. 변수 선언    값을 저장하기 위한 메모리 공간을 확보 → 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있도록 함.   자바스크립트에서는 변수를 선언할 때 `var`, `let`, `const` 를 사용한다.   변수를 선언하면 가장 먼저 메모리가 확보되는데 자바스크립트 엔진에 의해 `undefined` 라는 값이 암묵적으로 할당되어 초기화된다.                  자바스크립트 엔진의 변수 선언 2단계                         선언단계       변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림                 초기화 단계       값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화           * 실행 컨텍스트  - 모든 변수 이름(식별자)는 실행 컨텍스트에 등록된다.  - 실행 컨텍스트는 엔진이 소스코드를 평가하고 실행하기 위한 환경을 제공 및 실행 결과를 관리하는 영역.  - 자바스크립트는 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.       4. 호이스팅     변수의 선언은 위에서 아래로 순차적으로 진행되는 순서를 따르지 않고 그 이전 단계에서 실행이 된다.  자바스크립트 엔진은 코드를 실행하기 앞서 소스코드 평과 과정을 진행한다. 이때 변수 선언 및 모든 선언문(변수, 함수 등)을 먼저 실행한다.   consoloe.log(jongbin); // 에러가 발생하지 않음  var jongbin = \"hello\";   var의 경우 에러가 발생하지 않지만, const, let은 에러가 발생   var는 되는데 왜 const, let는 안되는지 찾아보니 TDZ(Temporal Dead Zone)라는 개념이 있었다.   TDZ(Temporal Dead Zone)  변수선언 전에 변수에 접근하면 TDZ에 의해 ReferenceError가 발생하게 된다.   블로그를 찾다보니 TDZ 구간에 있는 변수는     선언은 되어있지만 아직 초기화가 되지않아 변수에 담길 값을 위한 공간이 메모리에 할당되지 않은 상태    라고 말하시기도 한다. const, let도 호이스팅은 되지만 TDZ에 들어있어 참조에러가 난다.   스코프 내용을 같이 하면 좋겠지만 책 뒤쪽에 나온다.  스코프는 간단히 변수에 접근할 수 있는 범위라고도 한다.       5. 값의 할당    //값의 할당은 선언과 함께 하나의 문으로 할 수 있다. const jongbin = \"hello\";  //선언과 할당을 따로 할 수 있다. const jongbin; jongbin = \"hello\";   변수 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.   * 이해하기 어려웠던 부분!  변수를 선언하면 undefined라는 값이 할당이 되는데 이후 변수에 할당을 하게되면 해당 변수가 가르키는 메로리주소값에 있는 undefined값이 수정값으로 수정되는것이 아니고 새로운 메모리에 수정값을 넣고 주소를 바꿔준다.   이렇게 하면 괜히 번거로운게 아닌가 생각을 하는데 왜 값을 직접 변경하지 않는지 모르겠다…(찾고 추가해서 수정하자!)       6. 값의 재할당   값의 재할당도 할당과 마찬가지로 직접 값을 수정하지 않고 새로운 메모리를 확보하고 값을 넣고 변수에 주소를 다시 맵핑해준다.   이렇게 되면 undefined값이나 전에 값들이 메모리에 남아있을텐데 이게 메모리 누수로 이어지지는 않을까 생각했지만!  이렇게 불필요한 값들은 **가비지 콜렉터**에 의해 메모리에서 자동 해제된다!       7. 식별자 네이밍 규칙       식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.   식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. (숫자로 시작 X)   예약어는 식별자로 사용할 수 없다.   변수 이름은 목적을 위해 의미를 명확히 표현하는게 좋다.       #. 네이밍 컨벤션      카멜 케이스 (jongbinHome)   스네이크 케이스 (jongbin_home)   파스칼 케이스 (JongbinHome)   헝가리언 케이스 (strJongbinHome) → (type + 식별자이름)                  자바스크립트에서는 일반적으로                         변수, 함수       카멜케이스                 생성자 함수, 클래스       파스칼케이스                 이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive04/",
        "teaser": null
      },{
        "title": "[Deep Dive] 05장 표현식과 문",
        "excerpt":"    1. 값       값은 식(표현식)이 평가되어 생성된 결과를 말한다.   값은 데이터 타입을 가지고, 메모리에 저장된다.   // 10 + 20이 평가되어 값 30을 생성 10 + 20;  // 30       2. 리터럴       리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법.   자바스크립트 엔진은 코드를 실행하는 런타임에 리터럴을 평가해 값을 생성함.   * 리터럴  정수리터럴, 부동소수점리터럴, 2진수리터럴, 문자열리터럴, 불리언리터럴, null리터럴, undefined리터럴, 객체리터럴, 배열리터럴, 함수리터럴, 정규표현식리터럴       3. 표현식       표현식은 값으로 평가될 수 있는 문.   표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.   표현식은 값처럼 사용될 수 있다.       4. 문       문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위.   문의 집합 → 프로그램  /  문을 작성하고 나열 → 프로그래밍        선언문, 할당문, 조건문, 반복문 등         토큰은 문법적인 의미를 가지고, 문법적으로 더 이상 나눌 수 없는 코드의 기본요소를 의미   문은 여러 토큰으로 구성   키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등은 문법적인 의미를 가지고 더 이상 나눌 수 없음  →  토큰       5. 세미콜론과 세미콜론 자동 삽입 기능    자바스크립트 엔진은 세미콜론으로 문의 종료 위치를 파악하고 순차적으로 실행한다.   코드블록({…})은 자체종결성을 가지기 때문에 세미콜론을 붙이지 않는다.   * 세미콜론 자동 삽입 기능(ASI)  자바스크립트 엔진은 소스코드를 해석할때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여준다.       6. 표현식인 문과 표현식이 아닌 문    구별하는 방법 → 변수에 할당하는 것                  표현식인 문       값으로 평가(변수에 할당 가능)       var temp = 1 + 2                 표현식이 아닌 문       값으로 평가되지 않음(할당x)       var temp = var x                 이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive05/",
        "teaser": null
      },{
        "title": "[Deep Dive] 06장 데이터타입",
        "excerpt":"    자바스크립트는 7개의 데이터 타입을 제공한다.                  구분       데이터 타입       설명                       원시타입       숫자 타입       숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재                 원시타입       문자열 타입       문자열                 원시타입       불리언 타입       논리적 참(true), 거짓(false)                 원시타입       undefined 타입       var 키워드로 선언된 변수에 암묵적으로 할당되는 값                 원시타입       null 타입       값이 없다는 것을 의도적으로 명시할 때 사용하는 값                 원시타입       심벌 타입       ES6에서 추가된 7번째 타입                 객체타입       객체 타입       객체, 함수, 배열 등               1. 숫자 타입       자바스크립트의 숫자 타입은 모두 실수로 처리함.   메모리에 저장될때 2진수로 저장됨.   값을 참조할때 모두 10진수로 해석됨.   * 숫자타입의 특별한 세가지  - Infinity: 양의 무한대  - -Infinity: 음의 무한대  - NaN: 산술 연산 불가       2. 문자열 타입       문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합.   작은따옴표(' '), 큰따옴표(\" \"), 백틱(` `)으로 표현.   문자열은 불변값임(연산시 새로운 값을 할당한 후 참조주소를 변경)       템플릿 리터럴  ES6부터 템플릿 리터럴이라는 새로운 문자열 표기법 도입.     백틱(``)을 사용해 멀티라인 문자열 가능   const jongbin = `hello I'm jongbin`;  // 출력결과 // hello // I'm jongbin         표현식 삽입 (${}를 사용해서 표현식을 삽입한다.)   const jongbin = `I',m ${20+6} years old`;   // 출력결과 // I'm 26 years old       3. 불리언 타입    불리언 타입은 true, false값 두가지가 있다.       4. undefined 타입    undefined은 값을 할당하지 않은 변수를 참조했을때 반환된다.   선언만 하고 값을 할당하지 않은 변수를을 undefined로 초기화한다.       5. null 타입    null은 변수에 값이 없음을 의도적으로 명시할 때 사용한다.   이전의 값의 참조를 명시적으로 제거할 때 사용       6. 심벌 타입       변경불가능한 원시타입의 값   다른 값과 중복되지 않는 유일한 값       7. 객체 타입       자바스크립트의 기본 타입은 객체(object).   객체란 실생활에서 우리가 인식할 수 있는 사물로 볼 수 있다.   객체는 여러 프로퍼티(property)나 메소드(method)를 같은 이름으로 묶어놓은 일종의 집합체.   자바스크립트를 이루고 있는 거의 모든 것이 객체.       데이터 타입의 필요성       메모리            메모리에 값을 저장하려면 공간을 확보해야함.       변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정됨               값의 해석            데이터 타입에 따라 다르게 해석한다.(메모리에 저장된 이진수(값)을 문자열? 숫자?)           심벌 테이블  컴파일러 또는 인터프리터는 심벌테이블라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.      값을 저장할 깨 확보해야 하는 메모리 공간의 크기를 결정.   값을 참조할 때 한번에 읽어야 할 메모리 공간의 크기를 결정.   메모리에서 읽어들인 2진수를 어떻게 해석할지 결정.       동적 타이핑    자바스크립트는 정적 타입 언어와 다르게 변수 선언시 타입을 지정하지 않는다. 대신 var, const, let 키워드를 사용해 변수 선언을 한다.   // c 언어 char c; int num;   // javascript var t1; const t2; let t3;         자바스크립트는 할당된 값에 의해 타입이 결정된다.   재할당에 의해 타입이 동적으로 변할 수 있다.   이런 언어를 동적 타입 언어라고 한다.   동적타입언어는 개발자의 의도와는 다른 변수타입을 제공할 수 있다. → 동적타입언어는 유연성은 높지만 신뢰성은 떨어진다.         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive06/",
        "teaser": null
      },{
        "title": "[Deep Dive] 07장 연산자",
        "excerpt":"    피연산자     연산자의 대상   값으로 평가될 수 있는 표현식       1. 산술 연산자       피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듬.   산술 연산이 불가능한 경우 NaN을 반환       * 이항 산술 연산자                  이항 산술 연산자       의미       부수효과                       +       덧셈       X                 -       뺄셈       X                 *       곱셈       X                 /       나눗셈       X                 %       나머지       X               * 단항 산술 연산자                  단항 산술 연산자       의미       부수효과                       ++       증가       O                 --       감소       O                 +       효과 X       X                 -       양수를 음수로, 음수를 양수로 반전한 값 반환       X             증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 일어남.   증가/감소 연산자는 위치에 의미가 있다.  - 피연산자 앞에 위피한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨후 다른 연산을 수행.  - 피연산자 뒤에 위피한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후 피연산자의 값을 증가/감소.       * 문자열 연결 연산자     + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.       2. 할당 연산자    할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.                  할당 연산자       예       동일 표현       부수효과                       =       x=5       x=5       O                 +=       x+=5       x=x+5       O                 -=       x-=5       x=x-5       O                 *=       x*=5       x=x*5       O                 /=       x/=5       x=x/5       O                 %=       x%=5       x=x%5       O           부수효과 =&gt; 변수값이 변함.       3. 비교 연산자    비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환.       * 동등/일치 비교 연산자                  비교 연산자       의미       사례       설명       부수효과                       ==       동등 비교       x==y       x와 y의 값이 같음       X                 ===       일치 비교       x===y       x와 y의 값과 타입이 같음       X                 !=       부동등 비교       x!=y       x와 y의 값이 다름       X                 !==       불일치 비교       x!==y       x와 y의 값과 타입이 다름       X           ==와===는 같아 보이지만 정확한 비교를 위해서는 ===를 사용하는게 좋다.   ==는 비교할때 암묵적인 타입변환을 통해 타입을 일치시킨다.       * 동등/일치 비교 연산자                  대소 관계 비교 연산자       예제       설명       부수효과                       &gt;       x&gt;y       x가 y보디 큼       X                 &lt;       x&lt;y       x가 y보디 작음       X                 &gt;=       x&gt;=y       x가 y보디 크거나 같음       X                 &lt;=       x&lt;=y       x가 y보디 작거나 같음       X               4. 삼항 조건 연산자    삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정.   조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값  // x와 y 중에 더 큰 값을 반환 var jongbin  = x&gt;y ? x : y   console.log(jongbin) // 값처럼 사용 가능     삼항 조건 연산자를 중복해서 사용할 수 있다.   var jongbin  = num ? (num&gt;0 \"양수\" : \"음수\") : \"0\";       5. 논리 연산자    논리 연산자는 우항과 좌항의 피연산자를 논리 연산.                  논리 연산자       의미       부수 효과                       ||       논리합(AND)       X                 &amp;&amp;       논리곱(OR)       X                 !       부정(NOT)       X           불리언 값을 반환한다.(true, false)       6. 쉼표 연산자    쉼표 연산자는 파례대로 피연산자를 평가하고 마지막 피연산자의 결과를 반환.  var x, y, z; x=1, y=2, x=3; // 결과 // 3       7. 그룹 연산자    소괄호(())로 묶어 내부 피연산자의 연산을 먼저한다.       8. typeof 연산자    typeof연산자는 피연산자의 데이터 타입을 문자열로 반환.   string, number, boolean, undefined, symbol, object, function 중 한가지를 반환.       9. 지수 연산자       ES7에서 도입   좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한 값을 반환.   Math.pow 메서드와 같다.   우선순위가 가장 높다.   2 ** 2;   // 4 2 ** 10;   // 1024       11. 그 외 연산자                   연산자       개요                       ?.       옵셔널 체이닝 연산자                 ??       null 병합 연산자                 delete       프로퍼티 삭제                 new       생성자 함수를 호출할 때 사용하여 인스턴스를 생성                 instanceof       좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별                 in       프로퍼티 존재 확인               12. 연산자의 우선순위    연산자가 여러개 있을 때 수행되는 순서.                  우선순위       연산자                       1       ()                 2       new(매개변수 존재), ., [](포로퍼티 접근), ()(함수호출), ?.(옵셔널 체이닝 연산자)                 3       new(매개변수 미존재)                 4       x++, x--                 5       !x, +x, -x, ++x, --x, typeof, delete                 6       **(이항연산자 중에서 우선순위가 가장 높다)                 7       *, /, %                 8       +, -                 9       &lt;, &lt;=, &gt;, &gt;=, in, instanceof                 10       ==, !=, ===, !==                 11       ??(null 병합연산자)                 12       &amp;&amp;                 13       ||                 14       ? ... : ...                 15       할당연산자(=, +=, -=,…)                 16       ,               13. 연산자 결합 순서                   결합 순서       연산자                       좌항→우항       +, -, /, %, &lt;, &lt;=, &gt;, &gt;=, &amp;&amp;, ||, ., [], (), ??, ?., in, instanceof                 우항→좌항       ++, --, 할당연산자(=, +=, -=,…), !x, +x, -x, ++x, --x, typeof, delete, ? ... : ...                 이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive07/",
        "teaser": null
      },{
        "title": "[Deep Dive] 08장 제어문",
        "excerpt":"    제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용.       1. 블록문       블록문은 0개 이상의 문을 중괄호({})로 묶은 것   자바스크립트는 블록문을 하나의 실행 단위로 취급   일반적으로 제어문이나 함수를 정의할 때 사용   블록문은 자체종결성을 가지므로 세미콜론(;)을 붙이지 않음       2. 조건문    조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정.   if ... else 문   if ... else문은 주어진 조건식의 논리적 참, 거짓에 따라 실행 블록 결정.   if (조건식){   // 조건식이 참(true)일때 이 코드 블록 실행 } else {   // 조건식이 거짓(false)일때 이 코드 블록 실행 }     조건문을 여러개 만들 수 있는데 else if를 사용하면 된다   if (조건식1){   // 조건식1 참(true)일때 이 코드 블록 실행 } else if(조건식2) {   // 조건식2 참(true)일때 이 코드 블록 실행 } else if(조건식3){   // 조건식3 참(true)일때 이 코드 블록 실행 } else {   // 모든 조건식이 거짓(false)일때 이 코드 블록 실행 }   if ... else문은 위에서 순서대로 진행된다 (범위를 조건으로 했을때 주의)   대부분의 if ... else문은 삼항 조건 연산자로 표현할 수 있다   switch 문   switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 같는 case문으로 실행 흐름을 옮김.   switch (표현식) {   case 표현식1: 표현식과 표현식1이 일치하면 실행;     braek;   case 표현식2: 표현식과 표현식2가 일치하면 실행;     braek;   case 표현식3: 표현식과 표현식3이 일치하면 실행;     braek;   default: 아무것도 일치하지 않을때 실행; }  switch문의 case를 보면 break가 포함되어 있는데 코드 블록을 출하는 역할을 함.   `braek`를 사용하지 않으면 `default`가 실행된다.   * 폴스루(fall through)  switch문에서 의도적으로 break를 생략하여 여러 조건을 동일하게 사용한다.       3. 반복문    반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 반복해서 실행(거짓일 때까지 반복).       &lt; 자바스크립트의 반복문 대체 &gt;     forEach : 배열을 순회   for...in : 객체의 프로퍼티를 열거   for...of : 반복문 대체 [ES6]   for 문   for (변수선언 및 할당; 조건식; 증감식){   // 조건식이 참인 경우 반복해서 실행 (조건식이 거짓일 때까지) }   // 1부터 10까지 출력 for (let i = 1; i&lt;=10; i++){   console.log(i) }  위 코드를 순서대로 살펴보면,       i는 let키워드를 사용해서 선언 및 1을 할당했고,     i&lt;=10이 조건식으로 있고 현재 i는 1이므로 true → 코드블록 실행     i를 출력 → 1 출력     증감식으로 i++, 코드블록 실행 이후 i가 1증가하고,     이후 조건식의 true, false 여부판단 → 코드블록 실행(조건식이 false일 때까지)       // 무한루프 for (;;){   // 코드실행 }      for문의 무한루프는 이렇게 사용이 가능.   for문은 중첩할 수 있다.       while  문   while문은 주어진 조건식의 평가 결과가 참(false)이면 코드블록을 계속해서 반복 실행.   while(조건식){   // 조건식이 참(true)이면 코드 반복 실행 }   // 1부터 9까지 출력 let i = 1; while(i&lt;10){   console.log(i)   i++; }  예시) 1 ~ 9 출력   // 무한루프 while(true){   // 코드 실행 }       do...while 문   do...while문은 코드블록을 먼저 실행하고 조건식을 평가 → 무조건 한번은 실행   do{   // 코드 실행 } while(조건문)       4. break 문   break문은 코드 블록을 탈출하는데 레이블문, 반복문, switch문을 탈출한다   →   이외 코드블록에서는 **SyntaxError(문법에러) 발생**   레이블문 : 식별자가 붙은 문을 말함   내부 코드블록이 아닌 외부 코드 블록을 탈출하려고 할때 식별자를 붙이고 braek에 식별자를 명시.   outer: for (;;){   for (let i = 1; i&lt;100; i++) {     console.log(i)     if (i === 50){       break outer;     }   } }  i가 50 일때 외부코드블록을 탈출시킨다.       5. continue 문   continue문은 반복문의 코드 블록 실행을 건너뛰고 진행한다.   for (let i = 1; i&lt;10; i++) {   if (i === 5){     continue;   }   console.log(i) }  i가 5일때 continue가 있는 해당 지점부터 코드블록을 건너뛰고 i가 6일때로 진행된다.         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive08/",
        "teaser": null
      },{
        "title": "[Deep Dive] 09장 타입 변환과 단축 평가",
        "excerpt":"    1. 타입 변환    # 명시적 타입 변환 / 타입 캐스팅      개발자가 의도적으로 값의 타입을 변환하는 것   parseInt(), toString() …   # 암묵적 타입 변환 / 타입 강제 변환      개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 변환   표현식을 평가하기 위해 새로운 값을 생성하고 한번 사용하고 버림       명시적 타입 변환, 암묵적 타입 변환이 원시값(변수의 값)을 직접 변경하지 못함(원시값은 변경불가)   → 기존 원시값을 이용해서 다른 타입의 새로운 원시값을 생성        2. 암묵적 타입 변환    # 문자열 타입   1 + '2' // '12'  ”+ 연산자”는 피연산자 중 하나 이상이 문자열이기 때문에 1이 문자열로 암묵적으로 변환됨   # 숫자 타입   1 - '1'   // 0 1 * '10'  // 10 1 / 'one' // NaN   “산술 연산자”는 숫자 값을 만드는 연산자로 문자열이 숫자값으로 암묵적 타입 변환됨   숫자로 변환되지 않는 문자열로 연산했을때는 NaN 반환   '1' &gt; 0   // true  “비교 연산자”의 경우 크기를 비교하므로 숫자로 암묵적 타입 변환   자바스크립트 엔진은 숫자로 암묵적 변환을 할때 다음과 같다.  // 문자열 타입 +''       // 0 +'0'      // 0 +'1'      // 1 +'aaa'    // NaN  // 불리언 타입 +true     // 1 +false    // 0  // null 타입 +null     // 0  // undefined 타입 +undefined  // NaN  // 심벌 타입 +Symbol()   // error  // 객체 타입 +{}             // NaN +[]             // 0 +[1,2,3]        // NaN +(function ())  // NaN       # 불리언 타입   자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy값(참), Falsy값(거짓)으로 구분     Truthy값(참) =&gt; true   Falsy값(거짓) =&gt; false   Falsy값(거짓) : false, undefined, null, 0, -0, NaN, ''       3. 명시적 타입 변환    # 문자열 타입      String생성자 함수를 new연산자 없이 호출   Object.prototype.toString메서드 사용   문자열 연결 연산자(+)를 사용   // String 생성자 함수 String(1)   // \"1\"  // Object.prototype.toString 메서드 (1).toString()    // \"1\"  // 문자열 연결 연산자 1 + \"\"      // \"1\"       # 숫자 타입      Number생성자 함수를 new연산자 없이 호출   parseInt, parseFloat함수를 사용(문자열 → 숫자)   + 단항 산술 연산자 이용   * 산술 연산자 이용   // Number 생성자 함수 Number(1)   // 1  // parseInt 함수 parseInt(\"1\")   // 1  // 단항 산술 연산자 +\"1\"      // 1  // 산술 연산자 \"1\" * 1      // 1       # 불리언 타입      Boolean생성자 함수를 new연산자 없이 호출   ! 부정 논리 연산자를 두번 사용   // Boolean 생성자 함수 Boolean(1)    // true Boolean(0)    // false Boolean(\"\")   // false Boolean({})   // true Boolean([])   // true  // 부정 논리 연산자 !!'1'         // true !!''         // false !!1         // true !!0         // false       4. 단축 평가    &amp;&amp;, || 단축 평가 규칙                  단축 평가 표현식       평가 결과                       true || anything       true                 false || anythig       anything                 true &amp;&amp; anything       anything                 false &amp;&amp; anythig       false                   &amp;&amp;의 경우 첫번째 피연산자가 true, 두번째 피연산자가 true이면 두번째 피연산자를 반환            ||의 경우 첫번째 피연산자가 true이면 첫번째 피연산자를 반환           # if문 대체   let jongbin; let bool = true;  if (true) {   jongbin = \"hi\"; } console.log(jongbin);    // hi  // 단축 평가로 대체 // bool이 false이면 let bool = false; jongbin =  bool || \"hi\"; console.log(jongbin)      // hi  변수 bool이 true이면 true를 반환했을 것이다.       # 객체를 가르키는 변수 확인   변수가 객체가 아닌 null, undefined가 할당되어 있을 수 있는 경우에   let variable = null;  let value = variable &amp;&amp; variable.value  // null  변수 variable이 null이 아니었다면 정상적인 값을 출력   단축 평가를 사용하지 않고 그냥 참조하면 에러발생       # 함수 매개변수에 기본값 설정   함수를 호출할때 매개변수를 전달하지 않으면 매개변수는 undefined 자동 할당  → 이로인해 일어날 에러를 방지하기 위해서   function num(x) {   x = x || 0;   return x*x }  x를 전달하지 않으면 x는 undefined로 false값이기 때문에 0이 할당됨       # 옵셔널 체이닝 연산자(?.)      ES11에서 도입   좌항의 피연산자가 null, undefined이면, undefined반환   좌항의 피연산자가 null, undefined이 아니면, 참조   let variable = null; let value = variable?.value;    // undefined  만약 변수variable이 정상적인 값이라면 변수value는 variable.value       # null 병합 연산자(??)      ES11에서 도입   좌항의 피연산자가 null, undefined이면, 우항의 피연산자 반환   좌항의 피연산자가 null, undefined이 아니면, 좌항의 피연산자 반환   // 좌항이 null let variable = null ?? \"jongbin\";   // \"jongbin\"  // 좌항이 null이 아니면 let variable = \"won\" ?? \"jongbin\";   // \"won\"         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive09/",
        "teaser": null
      },{
        "title": "[Deep Dive] 10장 객체리터럴",
        "excerpt":"    1. 객체       객체 타입은 다양한 타입의 값(원시값, 다른객체)들을 하나의 단위로 묶은 자료구조   0개 이상의 프로퍼티(key, value)로 구성된 집합   프로퍼티 값이 함수일 경우 일반함수와 구분되게 메서드(method)라고 함                                            프로퍼티       객체의 상태를 나타내는 값                 메서드       프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작               2. 객체 리터럴에 의한 객체 생성    자바스크립트는 프로토타입 기반 객체 지향 언어     객체 리터럴   Object 생성자 함수   생성자 함수   Object.create 메서드   클래스   객체 리터럴  중괄호({...}) 내에 0개 이상의 프로퍼티를 정의 (코드블럭 x → 세미콜론 필요)   const jongbin = {   age = 26,   location = \"suwon\",   // 여러개의 프로퍼티 정의 };       3. 프로퍼티    키(key)와 값(value)로 구성됨   const jongbin = {   age = 26,   // age는 키, 26은 값 };                     &lt; 프로퍼티 키, 값으로 사용할 수 있는 값 &gt;                         키(key)       빈 문자열을 포함하는 모든 문자열 또는 심벌 값                 값(value)       자바스크립트에서 사용할 수 있는 모든 값              프로퍼티 키는 식별자 네이밍 규칙(카멜케이스)을 따르지 않는 이름에는 반드시 따옴표 사용   프로퍼티 키로 예약어를 사용하는 것도 가능(권장 x)   중복 선언하면 에러 대신 덮어씀   객체의 프로퍼티를 동적으로 생성  프로퍼티 키를 대괄호([...])로 묶음   jongbin[shoes] = \"nike\";       4. 프로퍼티 접근    객체에 존재하지 않는 프로퍼티에 접근하면 `undefined`를 반환       &lt; 프로퍼티에 접근하는 방법 &gt;     마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법   대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법   const jongbin = {   age = 26 };  // 마침표 표기법 console.log(jongbin.age);  // 대괄호 표기법 console.log(jongbin[\"age\"])        대괄호 표기법을 사용할 때 키 값을 따옴표로 감싸야 함   키값이 네이밍 규칙을 준수하지 않았다면 대괄호 표기법을 이용해야 함       5. 프로퍼티 갱신, 접근, 삭제    갱신   const jongbin = {   age = 26 };  jongbin.age = 20;  존재하는 프로퍼티에 값을 할당하면 갱신됨.   생성   const jongbin = {   age = 26 };  jongbin.shoes = \"nike\";  존재하지 않는 프로퍼티에 값을 할당하면 동적으로 프로퍼티가 생성됨.   삭제   const jongbin = {   age = 26 };  delete jongbin.age;  delete 연산자를 사용하여 프로퍼티값을 삭제함(존재하지 않는 프로퍼티의 경우 무시)       6. ES6의 객체 리터럴   축약 표현   const x = 1, y = 2;  // 기존 const jongbin = {   x: x,   y: y }  // ES6 const jongbin = {   x,   y }  ES6에서는 변수 이름과 프로퍼티 키가 동일한 경우 프로퍼티 키를 생략할 수 있다.       여러개 프로퍼티 동적 생성   const something = \"shoes\"; let i = 0; const jongbin = {};  // 기존 jongbin[something + '-' + ++i] = \"nike\" jongbin[something + '-' + ++i] = \"hoka\"  console.log(jongbin)  // {shoes-1: \"nike, shoes-2: \"hoka\"}  // ES6 jongbin = {   [`${something}-${++i}`] : \"nike2\"   [`${something}-${++i}`] : \"hoka2\" }  console.log(jongbin)  // {shoes-1: \"nike2, shoes-2: \"hoka2\"}  ES6는 객체리터럴 내부에서도 사용 가능       메서드 축약 표현   // 기존 const jongbin = {   age: 26,   myOld: function() {     console.log(\"I'm \" + this.age.toString())   } }  // ES6 const jongbin = {   age: 26,   myOld() {     console.log(\"I'm \" + this.age.toString())   } }  function 키워드를 생략할 수 있음.         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive10/",
        "teaser": null
      },{
        "title": "[Deep Dive] 11장 원시값과 객체",
        "excerpt":"    자바스크립트의 7가지 데이터 타입은 원시 타입과 객체 타입으로 구분됨                  원시 타입       객체 타입                       변경 불가능한 값       변경 가능한 값                 변수에 실제 값이 저장       변수에 참조 값이 저장                 값에 의한 전달       참조에 의한 전달           * 값에 의한 전달  변수를 다른 변수에 할당할 때 원본의 원시값이 복사되어 전달   * 참조에 의한 전달  변수를 다른 변수에 할당할 때 원본의 참조값이 복사되어 전달       1. 원시값    원시 타입의 값은 변경 불가능한 값 → 재할당을 할때 새로운 값을 생성  교체한다고 하는게 맞는 느낌이다!   변수 age -&gt; 0x000000f2(주소)  |  26(값) ___________________________________________                           새로 생성    0x00001222(주소)  |  27(값) ___________________________________________                                     0x000000f2(주소)  |  undefined(값) 변수 age -&gt; 0x00001222(주소)  |  27(값) ___________________________________________                         원시 값을 재할당하면,     새로운 메모르 공간 확보   확보된 메모리에 값 저장   변수가 참조하는 메모리 변경   값이 변하지 않아 이를 불변성이라고 함       값에 의한 전달   let jongbin = \"hi\";  // 참조된 주소가 아닌 값이 전달 let jb = jongbin;  console.log(jongbin === jb);    // true   변수 age   -&gt;   0x000000f2(주소)  |  26(값)                              ⬇︎ age copy  변수 age   -&gt;   0x000000f2(주소)  |  26(값) 변수 jbAge  -&gt;  0x00001222(주소)  |  26(값)   메모리주소(저장된 값)을 복사한다(참조된 주소값은 다름!)  메모리 주소를 복사하지만 주소값이 같은 것이 아님 → 전달된 메모리 주소로 값을 참조할 수 있다   → 복사한 변수를 수정해도 원본에 영향을 미치지 않음       2. 객체    객체는 메모리 크기가 정해져 있지도 않고, 프로퍼티를 추가, 삭제, 갱신 할 수 있기 때문에 원시값과는 다른 동작방식을 지닌다.   변경 가능한 값   객체 jongbin -&gt; 0x000000f2(주소)  |  0x00001222(값)                                    ⬋ 참조(값에 주소를 저장)                0x00001222(주소)  |  { age: 26 }(값)   원시값과는 다르게 객체는 메모리에 참조값을 저장한다. 객체는 변경이 가능한 값이므로 내부 프로퍼티를 수정할 수 있지만 내부 프로퍼티를 수정해도 참조값은 바뀌지않는다.   이런 방식은 계속해서 변하는 객체의 특성 때문에 고려된 메모리 사용의 효율성과 성능을 위한 방식이다. 하지만 단점으로 여러개의 식별자가 동일한 객체를 공유할 수 있다.       참조에 의한 전달   객체 jongbin -&gt; 0x000000f2(주소)  |  0x00001222(값)                   0x00001222(주소)  |  { age: 26 }(값)   // 동일한 객체                                 ⬇︎ copy  객체 jb   -&gt;    0x00002323(주소)  |  0x00001222(값)                                   0x00001222(주소)  |  { age: 26 }(값)   // 동일한 객체   복사를 하게 되면 메모리의 값(참조값)을 복사하기 때문에 동일한 객체를 참조하게 된다. 이는 여러개의 변수가 서로 영향을 미칠 수 있다.   원본의 참조값이 복사되어 전달되는 것을 참조에 의한 전달이라고 한다   참조 값만 복사하는 것을 얇은 복사라고 함   깊은 복사는 객체에 중첩되어 있는 객체까지도 전부 복사함         자바스크립트는 결국 메모리에 저장되어 있는 값을 전달한다 근데 그 값이 그냥 값인지 참조값인지에 따라 나뉘는 것 같다!         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive11/",
        "teaser": null
      },{
        "title": "[Deep Dive] 12장 함수(1)",
        "excerpt":"    함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것                  매개변수       함수 내부로 입력을 전달받는 것                 인수       입력                 반환값       출력           // 함수 정의  function jongbin(x) {   return \"I'm jongbin \" + x; }  // 함수 호출 const jb = jongbin(\"hi\"); console.log(jb)   // I'm jongbin hi       1. 함수를 사용하는 이유       함수는 원할 때, 원하는 만큼 호출이 가능 → 재사용   코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높임   함수는 객체 타입의 값   적절한 식별자는 내용을 파악하는데 용이 → 가독성       2. 함수 리터럴                   구성요소       설명                       function 키워드       함수를 선언                 함수 이름       * 함수이름은 식별자이므로 네이밍 규칙을 준수해야함  * 함수 리음은 함수 몸체 내에서만 참조할 수 있는 식별자  * 함수 이름은 생략가능(기명함수, 무명/익명함수)                 매개변수 목록       * 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분  * 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당  * 매개변수는 함수 몸체 내에서 변수와 동일하게 취급(매개변수도 변수와 마찬가지로 네이밍 규칙 준수)                 함수 몸체       * 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록  * 함수 몸체는 함수 호출에 의해 실행               3. 함수 정의    함수정의: 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것   함수 정의 방식   // 함수 선언문 function jongbin(s) {   return \"I'm jongbin\" + s; }  // 함수 표현식 const jongbin = function (s) {   return \"I'm jongbin\" + s; };  // Function 생성자 함수 const jongbin = new Function('s', 'return \"I\\'m jongbin\" + s');  // 화살표 함수(ES6) const jongbin = () =&gt; return \"I'm jongbin\" + s;       함수 선언문          함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당    → 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가르키는 식별자로 호출        const jb = function jongbin(s) {    return \"I'm jongbin \" + s;  }   console.log(jb('hi'));    // I'm jongbin hi   console.log(jongbin('hi'))    // error  // 함수 이름은 함부 몸체 내부에서만 유효                       함수 선언문은 이름을 생략할 수 없음                함수 선언문은 표현식이 아닌 문        // 표현식이 아닌 문은 변수에 할당할 수 없다   const jb = function jongbin(s) {  return \"I'm jongbin\" + s;   }   // 이건 왜 할당되?   // 기명함수 리터럴은 함수 선언문, 함수 리터럴 표현식으로 해석이 되니까!          {}는 블록문, 객체 리터럴 둘 다 된다          {}가 피연산자(우변)로 사용되면 객체 리터럴로 해석   {}가 단독으로 사용되면 블록문으로 해석       함수 표현식      자바스크립트의 함수는 일급객체 → 변수에 할당할 수 있음   함수 표현식은 표현식인 문 (함수 선언문은 표현식이 아닌 문)   일급객체 : 값의 성질을 갖는 객체       함수 생성 시점과 함수 호이스팅   console.dir(func1);  // f func1(s) console.dir(func2);  // undrfined  console.log(func1(\"hi\"));   // 함수선언문 hi console.log(func2(\"hi\"));   // TypeError: func2 is not a function  function func1(s) {   return \"함수선언문 \" + s; }  const func2 = function (s) {   return \"함수표현식 \" + s; }      함수 선언문으로 정의한 함수는 호이스팅으로 인해 정의되기 전에 호출할 수 있다.(함수 호이스팅)   함수 표현식은 변수에 할당되기 때문에 할당되기 전에 undefined로 초기화된다(호이스팅x)(변수 호이스팅)   호이스팅: 코드의 선두로 끌어 올려진 것처럼 작동하는 자바스크립트 고유의 특징       Function 생성자 함수   const jongbin = new Function('s', 'return \"I\\'m jongbin \"+ s');   빌트인 함수인 Function 생성자 함수에 먀갸변수 목혹과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.   (Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않음)   바람직하지 않은 방법이라고 한다       화살표 함수   const jongbin = (s) =&gt; {   return \"I'm jongbin \" + s; }      ES6에서 등장   화살표 함수는 기존의 함수보다 표현도 간략하고, 내부 동작 또한 간략화   기존 함수와 this 바인딩 방식이 다름   prototype 프로퍼티가 없음   argument 객체를 생성하지 않음         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive12-1/",
        "teaser": null
      },{
        "title": "[Deep Dive] 12장 함수(2)",
        "excerpt":"    1. 함수 호출    함수는 함수를 가르키는 식별자와 소괄호(())인 함수 호출 연산자로 호출   함수 호출 연산자(()) 내에는 0개 이상의 인수를 쉼표로 구분해서 나열       매개변수와 인수  함수를 실행하기 위해 필요한 값이 있는 경우, 매개변수(인자)를 통해 인수를 전달  인수는 개수와 타입에 제한이 없음      인수 확인   자바스크립트는 인수와 매개변수의 갯수를 체크하지 않음     순서대로 전달   인수가 부족하면 매개변수로 undefined값을 전달   인수가 매개변수의 갯수 초과시 무시(arguments객체의 프로퍼티로 보관)   자바스크립트 언어는 동적 타입 언어로 사전에 타입을 지정할 수 없음       1) 만약 인수가 전달되지 않는 경우를 대비해 단축평가 사용가능!   function add (a, b) {   a = a || 0;   // 단축평가   b = b || 0;   return a + b;  }   2) 또는 기본값을 사용 가능(ES6)  function add (a=0, b=0) {   return a + b;  }       매개변수의 최대 개수   ECMAScript 사양에서는 매개변수의 최대 개수를 명시적으로 제한하지 않음.  하지만 물리적 한계는 존재!   * 권장사항     이상적인 매개변수는 0개   함수는 한 가지 일만 해야하며 가급적 작게   매개변수는 최대 3개 이상을 넘지 않는 것이 좋음       반환문  함수는 return 키워드와 표현식(반환문)으로 실행 결과를 함수 외부로 반환할 수 있디.   * 반환문의 역할     함수의 실행을 중단하고 함수 몸체를 빠져나감   return 키워드 뒤에 오는 표현식을 형가해 반환(명시하지 않으면 undefined 반환)   반환문은 생략이 가능 → 함수 마지막 문까지 실행후 암묵적으로 undefined 반환       2. 참조에 의한 전달과 외부 상태의 변경    let num = 0; let obj = {name: \"jongbin\"};  function jongbin(num, obj) {   num += 1;   obj.name = \"won\"; }  console.log(num)  // 0 console.log(obj)  // {name: \"won\"}     원시값은 값에 의한 전달 방식으로 값이 변하지 않음   객체는 참조에 의한 전달 방식으로 변경 가능하므로 값이 변함   → 방어적 복사, 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체   * 순수함수 : 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수       3. 다양한 함수의 형태    즉시 실행 함수   함수의 정의와 공시에 즉시 호출되는 함수이며, 단 한 번만 호출되며 다시 호출할 수 없다   (function () {   const x = 10;   const y = 5;   return x * y; }());      즉시 실행 함수는 반드시 ()로 감싸야 한다   값을 반환할 수 있다   인수를 전달할 수 있다.       재귀 함수   자기 자신은 호출하는 것을 재귀 호출이라고 하는데, 재귀함수는 자기 자신을 호출(재귀 후출)하는 함수   // 자기 자신을 호출하는 피보나치 함수 function pibonaci(n) {     if (n &gt;= 2) {   // 탈출 조건         return pibonaci(n-2) + pibonaci(n-1)     } else {         return n     } }   재귀함수는 무한하게 자기 자신을 호출하므로 탈출 조건이 있어야 함.       중첩 함수   함수 내부에 정의된 함수를 중첩함수라고 한다     중첩함수를 내부함수   중첩함수를 포함하는 함수를 외부함수   외부 함수의 변수를 참조할 수 있다       콜백 함수      함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 한다.   매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수라고 한다.       function jongbin(n, f) {   for (let i = 0; i &lt; n; i++) {     f(i)   } }  const output = function (i) {   console.log(i) }  jongbin(5, output);   // 0 1 2 3 4      콜백함수는 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다(고차함수는 콜백함수를 자신의 일부분으로 합성)   고차함수는 매개변수를 통해 전달받은 콜백함수의 호출 시점을 결정해서 호출   비동기 처리(이벤트, Ajax통신, 타이머 함수등), 배열 고차 함수 등 중요하게 사용된다   function jongbin(n, f) {   for (let i = 0; i &lt; n; i++) {     f(i)   } }  // 익명 함수 리터럴로 곧바로 전달 jongbin(3, function (i) {   console.log(i) })    // 0 1 2        순수 함수, 비순수 함수  순수 함수는 외부 상태를 변경시키지 않는 함수   let count = 0;  // 순수 함수 function increase(n) {   return ++n;   // count를 인자로 전달해도 count가 변하지 않음 }  // 비순수 함수 function increase2() {   return ++count; }   // count를 1 증가시킨다.   순수함수를 지향해 불변성을 지키고, 복잡성이나 상태변경 문제를 억제하자!         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive12-2/",
        "teaser": null
      },{
        "title": "instanceof",
        "excerpt":"개인 프로젝트(car_management)를 진행하면서 웹페이지에서 check박스를 클릭해 db의 값을 수정하는 것이 목표였다. 프론트에서 데이터를 넘겨줬을때 백에서 request.body에 checkbox에서 지정한 name으로 값이 넘어오는 것을 알게 되었다.     문제는 여러개를 선택했을때는 배열값으로 넘어오고 한개를 선택했을때는 문자열값으로 데이터가 전달된다는 것이었다.     update를 진행하려면 mongose를 이용해 id값을 입력하고 update하려는 값을 인자로 전달해주어야했기 때문에 어떻게 해야 수정하려는 값이 한개일 때 혹은 여러개일 때 어떻게 처리할지 고민하였다.   처음 생각한 방법은 다음과 같다.  // 전달된 값의 타입이 object일때 if(typeof target === \"object\") {     // target의 길이만큼 반복     for (let i = 0; i &lt; target.length; i++) {            // DB update     } } else {     // DB update }   하지만 if(typeof target === \"object\") 이 부분이 작동하지 않았었다. 하지만 해당 글을 기록하면서 테스트를 해보다가 되는걸 알게되고 다시 typeof를 적용해보니 아주 잘 정상 작동한다…!   어쨌든…! instanceof의 결과를 보자면 제대로 작동했고 다음과 같다.   if (target instanceof Array) {     for (let i = 0; i &lt; target.length; i++) {         // DB update     }; } else {     // DB update }       instanceof  instanceof는 true, false값을 반환 받을 수 있다.  const obj = {}  // typeof console.log(typeof obj)     // object  // instanceof console.log(obj instanceof Object)      // true console.log(obj instanceof Array)      // false   MDN문서를 확인해보았을때 정확하게 말하자면 다음과 같다.      instanceof 연산자는 생성자의 prototype 속성이 객체의 프로토타입 체인 어딘가 존재하는지 판별합니다.    또한 `instanof`는 생성자의 프로퍼티를 확인하는 것이기 때문에 내가 정의한 생성자함수로도 확인이 가능하다!       typeof의 문제점은 이런점이 있다.   console.log(typeof {})     // object console.log(typeof [])     // object console.log(typeof null)     // object   객체와 배열, null값이 모두 object로 반환된다는 점이다. 이럴때 instanceof를 사용하면 좋을 것 같다!   조금 허무하지만 instanceof라는 메소드를 알게되서 다행이라고 생각해야겠다..  ","categories": ["Method"],
        "tags": ["JavaScript","Method"],
        "url": "/method/instanceof/",
        "teaser": null
      },{
        "title": "[Deep Dive] 13장 스코프",
        "excerpt":"    함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고, 함수 내부에서 선언한 변수는 함수 외부에서는 참조할 수 없고 함수 몸체 내에서만 참조할 수 있다.  왜냐하면 스코프가 정해져있기 때문이다       1. 스코프    모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다   ➞ 이를 스코프 라고 한다 (식별자가 유효한 범위)   // let, const는 중복 선언이 안되기 때문에 var를 사용 var x = 1;  fuinction func() {   var x = 10;   console.log(x)    // 10 } console.log(x)    // 1       2. 스코프의 종류   스코프는 “전역스코프”, “지역스코프” 이렇게 두개로 나뉜다                  구분       설명       스코프       변수                       전역       코드의 가장 바깥 영역       전역 스코프       전역 변수                 지역       함수 몸체 내부       지역 스코프       지역 변수                출처 https://frontj.com/entry/5-Javascript%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84    위 그림을 보면 전역 스코프는 함수를 포함한 그 밖의 영역 제일 바깥쪽이다   그리고 지역 스코프는 foo()함수의 내부에 1개, bar()함수의 내부에 1개, 총 2개가 있다      지역은 함수 몸체 내부를 뜻하고 지역변수는 자신의 지역 스코프와 하위의 지역 스코프에서도 유효하다   전역 스코프는 어디에서나 유효하다(최상단에 있기 때문)       3. 스코프 체인   함수는 중첩될 수 있으므로(각각 함수 내부의 함수는 중첩함수, 외부는 외부함수) 스코프도 중첩된다   ➞ 스코프가 함수의 중첩에 의해 계층적 구조를 가짐   지역 스코프의 상위 스코프는 함수기준 외부 함수의 스코프이다. 계층적으로 연결된 것을 스코프 체인이라고 한다       변수를 참조할때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다   하위 스코프에서 유효한 변수를 상위스코프에서 참조할 수 없다   // let, const는 중복 선언이 안되기 때문에 var를 사용 var x = \"global\";  fuinction func() {   var x = \"inner\";   console.log(x)    // 내부 } console.log(x)    // 외부  즉 내부에서 x를 호출했을 때 내부의 변수 x가 참조되지 외부의 x(global)이 참조될 수 없다는 뜻이다   렉시컬 환경  스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다  변수 선언 -&gt; 렉시컬환경에 키 등록  변수 할당 -&gt; 해당하는 값 변경       4. 함수 레벨 스코프  var 키워드로 선언된 변수는 코드블럭이 아닌 함수에 의해서만 지역 스코프가 생성됨   const, let 키워드로 선언된 변수는 블록 레벨 스코프를 지원한다       5. 렉시컬 스코프   상위 스코프를 결정하는 패턴은 두가지가 있다                  스코프       방법                       동적 스코프       함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정                 렉시컬 스코프       함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정           자바스크립트는 렉시컬 스코프를 따른다.   따라서 어디서 정의했는지에 따라 상위스코프를 결정   var x = \"global\";  function func1() {   var x = \"inner\";   funt2(); }  function func2() {   console.log(x); }  func1();   // global func2();   // global  func2 함수가 외부에서 선언되었기 때문에 func1함수 내부에서 func2를 호출하더라도 “global”을 출력한다 (스코프가 전역이므로)         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive13/",
        "teaser": null
      },{
        "title": "[Deep Dive] 14장 전역 변수의 문제점",
        "excerpt":"전역변수를 많이 사용하다보면 의도하지 않은 재할당이 일어날 수 있고, 메모리를 잡아먹는 등 문제점들이 있다.     변수의 생명주기   함수 내부에서 변수가 선언될 경우 초기에 전역변수처럼 호이스팅이 일어나지 않는다.   함수가 실했되었을 때 자바스크립트 엔진에 의해서 가장 먼저 실행(선언)된다   const func = () =&gt; {   var x = 10;   console.log(x);    // 10 } func(); console.log(x);    // error   위 코드를 보게되면 이해하기 쉽다. 우리가 알던대로라면 호이스팅이 일어나서 변수들의 선언이 가장 먼저 실행되어 가장 아랫줄의 console.log(x);은 undefined가 되어야 한다. 하지만 함수 내에서 변수를 선언한 경우에는 변수를 실행했을때 함수 내부 코드를 실행하는 측면에서만 가장 먼저 변수 선언이 일어난다   이후 함수를 실행하고 변수가 선언이 되었더라도 함수가 종료되면 변수도 사라지게 된다   ➞ 즉 변수의 생명주기는 함수의 생명주기와 일치한다.   전역변수도 마찬가지로 자바스크립트에 의해 어떤 객체보다도 먼저 생성되는 전역 객체의 생명주기와 동일하다       전역 변수의 문제점   암묵적 결합  전역변수는 어디서든 참조하고 할당할 수 있다. 따라서 어디서든지 전역변수를 참조하고 변경할 수 있다. 이처럼 유효 범위가 크면 가독성이 나빠지고 변수관리가 어렵다   긴 생명주기  전역변수의 생명 주기는 전역 객체의 생명주기와 동일하므로 코드 전체의 생명주기와 같다. 따라서 그만큼 시스템 자원(메모리 리소스)을 오래 차지하고 있다는 뜻이 된다.   스코프 체인상 종점에 존재  스코프 체인상에서 보면 거슬러 올라가야 하기 때문에 전역변수를 참조해야 할때 가장 종점까지 거슬러 올라가야 한다. 따라서 그만큼 시간이 오래 걸린다.(큰 차이는 없으나 시간 차이는 존재)   네임스페이스 오염  파일이 분리되어 있더라도 하나의 전역 스코프를 공유한다. 따라서 동일한 이름의 전역변수가 존재할 수 있다.       전역 변수 사용의 억제(방법)   이러한 문제점들을 방지하기 위한 방법들이 있다   즉시 실행 함수  즉시 실행 함수는 한번만 실행되므로 이를 이용해서 변수의 유효 범위를 제한한다(지역변수로)  (function (){   const x = \"jongbin\"; }());  console.log(x);   // error   네임스페이스 객체  전역에 객체를 생성하고 객체 내에 객체를 생성해 계층적으로 관리할 수 있다.   ( 중복을 방지할 수 있으나 전역 변수로 선언되는 것은 동일하다 )   const obj = {};  obj.name = \"jongbin\";  console.log(obj.name);   모듈 패턴  클래스를 모방해서 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로써 만든다.   네임스페이스의 오염을 막고, 정보은닉에도 활용된다.   const Mo = (function (){   const name = \"jongbin\";    return {     hi(){       return name+\" Hi!\";     }     bye(){       return name+\" Bye!\";     }   } }())  console.log(Mo.name);    // undifined (정보은닉)  console.log(Mo.hi());     // jongbin Hi!  외부에서 Mo내부의 name이라는 변수를 참조할 수 없다   ES6 모듈  파일 자체의 독자적인 모듈 스코프를 제공한다.  (모듈 내에서 var키워드로 선언한 변수는 전역변수가 아니다)  그렇다면 const, let 키워드는 해당이 안되는건가???   &lt;script type=\"nodule\" src=\"lib.mjs\"&gt;&lt;/script&gt; &lt;script type=\"nodule\" src=\"app.mjs\"&gt;&lt;/script&gt;  ES6의 모듈은 구형 브라우저에서는 작동하지 않는다. 또한 트랜스파일링이나 번들링이 필요하므로 Webpack을 더 사용한다.   * 트랜스파일링: 한 언어로 작성된 소스코드를 비슷한 수준의 추상화(Abstraction)를 가진 다른 언어로 변환하는 것  * 번들링: 여러개의 파일을 모아서 하나로 만드는 것  * Webpack: 오픈 소스 자바스크립트 모듈 번들러         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive14/",
        "teaser": null
      },{
        "title": "[Deep Dive] 15장 var, let, const",
        "excerpt":"var 키워드  ES6 이전의 변수 선언 키워드로서 중복선언이 가능한 키워드이다  var x = 1; var y = 1;  var x = 10; var y;    // 초기화문(초기값할당)이 없으면 무시  console.log(x) // 10 console.log(y) // 1   함수 레벨 스코프  블록 레벨 스코프가 아니고, 함수의 코드 블록만 지역 스코프로 인정     for문, if문, while문 등 모두 인정하지 않음   호이스팅  var 키워드로 선언한 변수들은 모두 호이스팅된다       let 키워드  중복 선언이 금지된다  let x = 10; let x = 20;   // error  console.log(x)   블록 레벨 스코프  let키워드는 모든 코드블록(for, if, while try/catch 등)을 지역변수 스코프로 인정한다  {   let x = 10; } console.log(x)    // error   호이스팅이 되지 않는 것처럼 동작  사실 내부적으로 호이스팅이 되지만 그렇지 않은것처럼 동작한다  console.log(x);   // error let x = 10;      var: 선언단계 + 초기화 단계(undefined) -&gt; 할당(x=1)   let: 선언단계 -&gt; 일시적 사각지대 -&gt; 초기화단계 -&gt; 할당   코드를 읽기전에 초기화단계까지 진행(var)하기 때문에 호이스팅발생  하지만 let키워드는 코드상에서 선언문을 만나야 초기화단계가 실행된다      let 키워드는 일시적 사각지대(TDZ)가 존재한다  스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간    let x = 10;  console.log(x) let x = 20; // SyntaxError: Identifier 'x' has already been declared  호이스팅이 발생하는 것을 알수 있다(console.log(x)가 출력되고 에러가 발생했어야 함)   전역객체의 프로퍼티가 되지 않음  브라우저 상에서 let키워드는 전역객체 window의 프로퍼티가 되지 않는다     var 키워드 var x = 1;   암묵적 전역 y = 1;   전역 함수 function xx() {}   위는 모두 window.x 또는 window.y window.xx로 출력할 수 있다 하지만 let의 경우에는 프로퍼티에 해당하지 않아 window.(let으로 선언한 변수)는 undefined가 출력된다       const 키워드  재할당 금지  const로 선언한 변수는 재할당이 금지되고, 재선언되지 않는다  const x = 10; x = 20; //error   선언과 동시에 초기화  const로 변수를 선언할 때에는 재할당이 되지 않기 때문에 선언과 동시에 값을 할당해 초기화해야 한다   재할당이 금지, 객체의 값 변경은 가능  const 변수에 객체를 할당했을 경우 변수에는 해당 객체의 주소값이 들어가기 때문에 객체 내부의 값은 변경이 가능하다 (변수를 조작하는 것이 아니다)            var키워드를 사용하면 사용자도 모르게 전역변수가 되어버리는 경우가 있다(함수 이외 코드블럭에서의 사용) 따라서 메모리를 할당받는 것이고, const를 사용하면 재할당을 방지할 수 있다. let의 경우에도 재선언을 방지하기 때문에 변수관리가 쉽다.   따라서 보통의 경우에는 const를 사용하다가 재할당이 필요한 변수에 let키워드를 사용하는 것이 좋다고 한다         이웅모 선생님의 모던 자바스크립트 Deep Dive를 공부하기 위해 정리한 글입니다.  혹시나 보시다가 고칠 부분이나 마음에 안드시는 부분이 있다면 말씀해주시면 감사하겠습니다!   ","categories": ["DeepDive"],
        "tags": ["JavaScript","DeepDive"],
        "url": "/deepdive/deepDive15/",
        "teaser": null
      },{
        "title": "HTML 개요",
        "excerpt":"1. HTML, CSS, JS  1-1. HTML (Hyper Text Markup Language)   HTML은 하이퍼텍스트 마크업 언어 (브라우저로 보여준다)      하이퍼 텍스트: 이동하기 위한 요소   마크업 언어: 표현하는 것을 기술(정의)하는 기능의 언어 (&lt;&gt; 꺽쇠기호로 표현)   1-2. CSS (Cascading Style Sheets)  CSS는 HTML이나 XML로 작성된 문서의 표시 방법을 기술하기 위한 스타일 시트 언어      html과 css를 구분해서 사용자 환경에 따라 사용자에게 웹페이지를 다르게 보여줄 수 있다   어떤 요소의 색상이나 모양, 크기, 배치 등(스타일, 레이아웃)을 지정해줄 수 있다   하나의 HTML에 여러개의 css가 적용, 여러 HTML에 같은 css를 적용할 수 있다   UX를 위해서 사용하기도함 (편리성)   1-3. JS(JavaScipt)  JavaScript는 컴파일 프로그래밍 언어      동적인 요소를 표현해주고 사용자와의 통신(인터랙션)이 가능하도록 해준다         2. 웹브라우저  인터넷을 통해 데이터들을 통신할 수 있는 기능을 제공하는 응용 프로그램   2-1. 웹 표준 (Web Standards)  브라우저마다 해석하는 방식에 차이가 있다  ➞  같은 기능으로 동작하도록 표준 지정(W3C)     표준화 이전에 독자적인 플러그인을 사용하기도 했으므로 선택의 폭이 매우 좁았었다   브라우저마다 스타일이 다를 수는 있다 (같은 기능을 함)   HTML5 - 2014년에 공식 표준화됨   2-2. 웹 접근성 (Web Accessibility)  일시적으로나 어떤 상황에서든 웹사이트를 이용할 수 있도록 하는 것(마우스타자판, 음성인식 등)     일반적인 브라우저를 이용하기 어려운 경우 브라우징을 할 수 있도록 도와주는 역할을 하게 됨   2-3. 웹 호환성(Cross Browsing)  웹브라우저에 상관없이 의도한대로 기능 동작하는 것(크로스브라우징)     브라우저에 따라 다른 기능을 할 수도 있음 -&gt; 하지만 표준화되면서 대부분 같은 기능을 함   어떤 브라우저를 이용하더라도 의도된 동작을 수행하도록 함         3. HTML 문법  HTML을 작성할 때에는 태그(&lt; &gt;)라는 표기법으로 작성하고 태그의 이름은 HTML5 웹 표준에 맞게 작성한다   &lt;태그이름&gt; 요소의 내용 &lt;/태그이름&gt;  &lt;h1&gt;jongbin&lt;/h1&gt;      태그의 시작을 알리는 여는 태그 &lt;태그의 이름&gt;   태그의 끝을 알리는 닫는 태그 &lt;/태그의 이름&gt;   여는 태그와 닫는 태그 사이에 요소의 내용을 입력   닫는 태그가 없는 태그들도 존재한다 (&lt;input&gt; 등)   대소문자 구분 x ( But 소문자를 권장 ) - 협업을 위해, 유지보수를 위해(가독성)   개행(줄바꿈)을 무시한다   3-1. 빈 요소 (Empty Element)      내용이 없는 태그 ➞ 닫는 태그가 존재하지 않는다   꺽쇄&lt; &gt;내부 마지막에 /를 붙이는건 생략가능하지만 붙여서 명시해주는 것이 좋다   일관성있게 /를 붙이면 전부 다 붙이고 그렇지 않으면 전부 다 붙이지 않는게 좋다                  빈 요소       기능                       &lt;br&gt;       줄바꿈                 &lt;hr&gt;       내용의 구분(수평선)                 &lt;img&gt;       이미지 삽입                 &lt;meta&gt;       메타데이터 정의                 &lt;input&gt;       입력요소           3-2. 요소의 중첩 (Nesting)      요소 내부의 내용으로서 요소를 삽입할 수 있다 (상하관계)   포함관계, 부모자식관계(외부태그가 부모, 내부태그가 자식, 인접한 태그 형제)   요소는 겹쳐질 수 없다   &lt;body&gt;   &lt;div&gt;     &lt;p&gt;   &lt;/div&gt;&lt;/p&gt; &lt;/body&gt;  div내부에 p태그를 삽입하려는 목적이었으나, 순서가 잘못됨(겹쳐짐) -&gt; 문법 에러 발생!   3-3. 주석   브라우저는 주석을 해석하지 않는다 (메모의 역할, 임시로 사용하지 않도록)   HTML의 주석 표현은 다음과 같다. 앞뒤를 각각 &lt;!--, --&gt;로 감싼다  &lt;!-- &lt;p&gt;jongbin&lt;/p&gt; --&gt;       브라우저가 주석의 시작부분(&lt;!--)를 만나게 되면 주석이 끝나는 부분(--&gt;)를 만날때 까지 무시하게 된다 따라서 주석 내부의 주석은 잘못될 가능성이 있다.   &lt;!-- &lt;div class=\"box\"&gt;   &lt;!-- &lt;div class=\"item\"&gt;1&lt;/div&gt; --&gt;   &lt;div class=\"item\"&gt;2&lt;/div&gt;   &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;/div&gt; --&gt;  원래 주석이었던 item 클래스의 1은 box 클래스 전부를 주석처리하면서 이상한 주석처리로 바뀌게 됨 (주의!)   3-4. HTML 문서의 구조   HTML 문서는 &lt;!DOCTYPE html&gt;, &lt;html&gt;, &lt;head&gt;, &lt;doby&gt;를 필수로 포함해야 한다   &lt;!DOCTYPE html&gt;     // HTML 버전 명시 (html5) &lt;html&gt;              // root 요소     &lt;head&gt;          // 웹페이지의 정보명시(사용자에게 보여지지 x)     &lt;/head&gt;     &lt;body&gt;          // 보여지는 컨텐츠     &lt;/body&gt; &lt;/html&gt;      &lt;!DOCTYPE html&gt;는 버전을 명시한다 생략해도 되지만 관습적으로 명시한다   모든 태그들은 &lt;html&gt;&lt;/html&gt;에 포함되어야 한다   ▶️ DOCTYPE   Document type의 약자로 버전을 명시한다.      관습적으로 문서의 제일 위에 &lt;!DOCTYPE html&gt;(HTML5)이라고 명시한다   html 이외의 버번의 명시는 다음과 같다   &lt;!-- XHTML 1.0 문서 선언 --&gt; &lt;!-- Strict --&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt; &lt;!-- Transitional --&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; &lt;!-- Frameset --&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"&gt;   &lt;!-- XHTML 1.1 문서 선언 --&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"     \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"&gt;   &lt;!-- HTML 4.01 문서 선언 --&gt; &lt;!-- Strict --&gt; &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"    \"http://www.w3.org/TR/html4/strict.dtd\"&gt; &lt;!-- Transitional --&gt; &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"    \"http://www.w3.org/TR/html4/loose.dtd\"&gt; &lt;!-- Frameset --&gt; &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"    \"http://www.w3.org/TR/html4/frameset.dtd\"&gt;     출처: https://dasima.xyz/doctype-html/       DOCTYPE을 선언하면 표준모드, 선언하지 않으면 비표준모드(호환모드)로 랜더링한다   비표준모드(호환모드)일 경우 오래된 페이지도 최신 브라우저에서 깨지지 않게 하기 위해서 브라우저마다 다르게 보일 수 있다 -&gt; 표준모드권장(DOCTYPE 명시!)       ▶️ head 태그  head태그에는 문서의 정보(메타데이터)를 가진다      한개의 title요소를 포함해야 한다   생략도 가능하지만 생략하지 않는 것을 권장       ▶️ body 태그  body 태그 내부에는 모든 내용의 요소들이 담긴다     한개의 body 태그만 존재할 수 있다   일반 요소들처럼 style을 입힐 수 있다       3-5. 태그의 구분 (특성, 블록-인라인)   ▶️ 수많은 태그들을 두가지의 특징으로 나눌 수 있다      구획을 나누는 태그 (layout)            여러가지 요소를 묶어 그룹화한다       내용없이 태그만 사용하면 눈에 보이지 않는다       &lt;header&gt;, &lt;section&gt;, &lt;footer&gt;, &lt;div&gt;…           그 자체로 요소인 태그            단독으로 사용해도 바로 보여진다       &lt;button&gt;, &lt;img&gt;…               ▶️ 블록(block)요소와 인라인(inline)요소      블록(block)            블록요소는 좌우로 가능한 넓은 범위를 차지하려고 한다       한줄을 모두 차지한다       자동으로 개행이 된다       &lt;div&gt;, &lt;li&gt;, &lt;p&gt;, &lt;h1&gt;…           인라인(inline)            어느 곳에서나 가능하다       요소의 내용만큼만 공간을 차지한다       블록 요소를 포함할 수 없다       &lt;span&gt;, &lt;a&gt;, &lt;button&gt;, &lt;i&gt;…              인라인 요소는 height가 적용되지 x   인라인 요소는 width가 적용되지 x   블록 요소는 vertical-align 이 적용되지 x   블록 요소는 text-align이 적용되지 x       3-6. 콘텐츠 카테고리     하나의 요소가 여러 카테고리로 분류될 수 있다(1:n 관계)   MDN에 어느 카테고리에 해당하는지 명시되어 있다(기술 요약)   HTML5에서 비슷한 특징으로 나누어 7가지 카테고리로 세분화      메타데이터 콘텐츠 (Metadata Content)            문서의 메타데이터, 다른 문서를 가르키는 링크 등을 나타내는 요소           플로우 콘텐츠 (Flow Content)            웹 페이지 상에 일부 메타데이터를 제외하고 거의 모든 요소.       보통 텍스트나 임베디드 콘텐츠를 포함       &lt;body&gt;의 내용이 흐름에 따라 배치되기 때문에 플로우 콘텐츠라고 함           섹션 콘텐츠 (Section Content)            웹 문서의 구획을 나눌 때 사용           헤딩 콘텐츠 (Heading Content)            섹션의 제목과 관련된 요소           프레이징 콘텐츠 (Phrasing Content)            문단에서 텍스트를 마크업 할 때 사용           임베디드 콘텐츠 (Embedded Content)            이미지나 비디오 등 외부 소스를 가져오거나 삽입할 때 사용되는 요소 (img, video, audio, iframe, canvas)           인터랙티브 콘텐츠 (Interactive Content)            사용자와의 상호작용을 위한 컨텐츠 요소       버튼을 클릭하거나, 텍스트를 입력 (form - input)                 4. 참고   4-1. 웹 에디터(편집기)  HTML 문법에 맞춰 편리하게 작성할 수 있도록 도와주는 편집기     Atom, Notepad++, Sublime Text, Visual Studio Code …       온라인 웹 에디터  https://jsbin.com, https://replit.com, https://codepen.io    4-2. 통합개발환경 (IDE)  개발을 할때 필요한 여러 툴들을 하나의 프로그램을 통해 사용할 수 있다.     편집기와 포함관계   편집기, 빌더, 디버거, 플러그인 등   Visual Studio Code, IntelliJ, Xcode, Eclipse …   4-3. 단축키   ▶️ VS 단축키                  가능       키                       현재 창 닫기       Cmd+w                 닫은 창 다시 열기       Cmd+Shift+t                 사이드바 토글       Cmd+b                 사이드바 - 탐색기       Cmd+Shift+e                 사이드바 - 전체검색       Cmd+Shift+f                 에디터 확대       Cmd++                 에디터 축소       Cmd+-           ▶️ 소스코드 편집                  기능       키                       들여쓰기       Tab / Cmd+]                 내어쓰기       Shift+Tab or Cmd+[                 아래에 행 삽입       Cmd+Enter                 위에 행 삽입       Cmd+Shift+Enter                 현재 행 이동       Opt+⬆️/⬇️                 현재 행 복사       Cmd+Shift+⬆️/⬇️                 현재 행 삭제       Cmd+Shift+k                 주석       Cmd+/           ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/html/",
        "teaser": null
      },{
        "title": "HTML 요소 1 - 텍스트 요소",
        "excerpt":"1. 텍스트 요소  ▶️ h1 ~ h6  block 요소로 제목을 나타낸다. h1이 가장 크고, h6가 제일 작다.   &lt;h1&gt;Jongbin&lt;/h1&gt; &lt;h2&gt;Jongbin&lt;/h2&gt; &lt;h3&gt;Jongbin&lt;/h3&gt; &lt;h4&gt;Jongbin&lt;/h4&gt; &lt;h5&gt;Jongbin&lt;/h5&gt; &lt;h6&gt;Jongbin&lt;/h6&gt;   웹 접근성을 향상시키기 위해 다음과 항목이 권장된다      제목의 단계를 건너뛰지 않는 것이 좋다(순차적으로 진행)   글씨 크기를 키우기 위해 제목 태그를 사용하는 것은 좋지 않다   하나의 페이지에는 하나의 h1만 있는 것이 좋다   ▶️ p  하나의 문단을 나타낸다(paragraph)   &lt;p&gt;Hello! Hello! Hello! Hello! Hello!&lt;/p&gt; &lt;p&gt;Jongbin Jongbin Jongbin Jongbin Jongbin&lt;/p&gt;      blcok요소이다   space가 두개 이상 사용되도 한번만 표시 -&gt; 개행문자나 &lt;br&gt; 사용   각 문단 사이에는 한줄높이의 여백이 추가된다.   빈 p태그로 여백을 추가하는 것은 웹 접근성측면에서 좋지 않다 -&gt; CSS이용   p태그 내부에는 block요소가 올 수 없다 (block요소를 만나면 자동으로 닫힘)   - 개행문자  라인을 제어하기 위한 문자                  개행문자       기능                       \\n       줄바꿈                 \\b       백스페이스                 \\t       탭                 \\s       스페이스           ▶️ br  텍스트 내부에 줄바꿈을 생성   &lt;p&gt;jongbin is gone&lt;br&gt;     he is 26 years old &lt;/p&gt;     &lt;!-- 다음과 같이 출력     jongbin is gone     he is 26 years old      --&gt;      문단 사이의 여백을 많이 주고 싶을때 &lt;br&gt;을 많이 사용하는 것은 좋지 않다   문단 구분을 &lt;br&gt;로 하는 것은 웹 접근성면에서 좋지 않다(태그는 존재하지만, 빈내용)   빈요소이다   ▶️ blockquote, q  두 태그 모두 인용을 위한 태그   &lt;blockquote&gt;   &lt;p&gt;jongbin jongbin jongbin jongbin jongbin jongbin jongbin&lt;/p&gt; &lt;/blockquote&gt;  &lt;p&gt;jongbin said, &lt;q&gt;hi&lt;q&gt;&lt;p&gt; &lt;!-- jongbin said \"hi\" --&gt;      &lt;blockquote&gt;은 block요소, &lt;q&gt;는 inline요소        &lt;q&gt; 텍스트 사이에 자연스럽게 넣을 목적으로 사용, &lt;blockquote&gt;는 모두 묶어서 블록처럼 사용       &lt;blockquote&gt;는 앞뒤로 여백이 생긴다.   &lt;q&gt;를 사용하면 쌍따옴표가 붙는다   &lt;blockquote&gt;와 &lt;q&gt;는 동일하게 cite 속성으로 출처를 나타낼 수 있다 (사용자에게 보여지지는 않음) / 요소 내용으로 사용도 가능       ▶️ pre  미리 서식이 지정된 텍스트를 나타낸다.  &lt;pre&gt;   \\    /    \\()/     ||     /\\    /  \\ &lt;/pre&gt;     개행에 상관없이 입력한 형식 그대로 출력된다   고정된 글꼴을 사용해 랜더링된다(모든 글자의 크기가 같음 - monospace font)       ▶️ figure, figcaption  독립적인 컨텐츠를 표현한다(삽화나 다이어그램, 사진 등 문서의 주요 흐름과는 독립적)   &lt;figure&gt;     &lt;img src=\"filePath\" alt=\"image\"/&gt;     &lt;figcaption&gt;this is image&lt;/figcaption&gt; &lt;/figure&gt;      HTML5에서 새로 추가된 태그   &lt;figure&gt;, &lt;figcaption&gt;는 같이 사용됨   img태그 이외 다른 태그들 pre, p 등 도 사용될 수 있다   사용자에게 보여질때 들여쓰기가 조금 들어감   &lt;figure&gt;는 연관성이 있음을 알려준다(여러 요소를 감싸줌으로써!)   &lt;figcaption&gt;는 설명하는 역할을 한다(꼭 들어갈 필요는 없다)   ▶️ hr  수평선 (가로로 줄이 생긴다) -&gt; 구획 내 주제 변경 등에 사용     문단을 나눌때 사용하는 경우가 대부분이다   빈요소이다(&lt;hr/&gt;)   꾸며줄 수 있는 속성이 있지만 권장하지 않는다(align, color, size…) ➞ 대신 css를 사용하자(웹표준준수!)   hr에 css를 사용할 때는 다음과 같다   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;     &lt;style&gt;         .box {             height: 100px;             background-color: skyblue;             border: 1px solid #000;             margin: 30px;         }         hr {             height: 10px;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div class=\"box\"&gt;&lt;/div&gt;     &lt;hr&gt;     &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;     파란색 상자 가운데 있는 것이 hr이다 height를 이용해서 높이 조정을 하고보니 input처럼 뭔가 들어가야하게 생겼다 -&gt; `border: 0`하면 일반 박스처럼 된다   hr {   height: 50px;   background: url(./hr-css.png);   border: 0;   background-position: 0% 33%;   background-size: cover; }     추가적으로 background-image로 지정해줄수도 있다 여기서는 이미지스프라이트 파일로 position을 지정했다       &lt;abbr title=\"world wide web\"&gt; www &lt;/abbr&gt;  &lt;address&gt; 경기도 수원시 ~~~ &lt;/address&gt;   &lt;p&gt;&lt;bdo dir=\"\"rtl&gt; 오른쪽 왼쪽 &lt;bdo&gt;&lt;p&gt;      &lt;!-- rtl ➞ right to left --&gt; &lt;!-- 쪽왼 쪽른오 --&gt;   ▶️ abbr  &lt;abbr title=\"Jong Bin\"&gt; JB &lt;/abbr&gt;  title 속성을 사용해서 원래의 의미를 나타낸다 (밑줄이 점선으로 표기되고, 마우스를 올리면 내용이 나온다)   ▶️ address  &lt;address&gt;경기도 수원시 ...&lt;/address&gt;   주소를 나타낸다(글꼴이 기울여진다) -&gt; 지도상 주소만 나타냈었으나, 현재는 email, website, sns들도 칭한다   ▶️ cite  &lt;figure&gt;   &lt;blockquote&gt;     &lt;p&gt; jongbin's age is 26&lt;p&gt;   &lt;blockquote&gt;   &lt;figcaption&gt; 출처는 &lt;cite&gt;종빈에게서&lt;/cite&gt;&lt;figcaption&gt; &lt;/figure&gt;  인용의 출처를 나타낸다   ▶️ bdo  &lt;p&gt;&lt;bdo dir=\"rtl\"&gt; ABCD &lt;bdo&gt;&lt;p&gt;     &lt;!-- DCBA  --&gt;  양방향의 의미를 가지고 텍스트를 바꿔줌     ltr : left to right (왼쪽에서 오른쪽으로)   rtl : right to left (오른쪽에서 왼쪽으로)   ▶️ b, strong  텍스트를 굵게 만들어준다 (결과 동일)  &lt;pre&gt;    1 2 3 4 5 6 7 8 9 &lt;b&gt;number&lt;/b&gt;   a b c d &lt;strong&gt;string&lt;/strong&gt; &lt;/pre&gt;      &lt;b&gt;: 그냥 굵게 사용하기 위해서(어느정도 강조)   &lt;strong&gt;: 높은 중요도를 가진 것   style적으로 사용하지 않는다 -&gt; font-weight를 사용하면 좋을듯!   inline 요소   스크린리더가 읽을때도 다르다       ▶️ i, em  텍스트를 기울여준다  &lt;p&gt;jongbin said, &lt;i&gt;hi&lt;/i&gt;&lt;/p&gt; &lt;p&gt;jongbin is &lt;em&gt;not&lt;em&gt; child&lt;/p&gt;      &lt;i&gt;: 주위와 구분해야 하는 부분(분위기가 다름, 다른언어, 숫자 등)   &lt;em&gt;: 강조하는 역할   style적으로 사용하지 않는다 -&gt; font-style을 사용하면 좋을듯!   inline 요소   ▶️ mark  &lt;p&gt; I'm &lt;mark&gt;26&lt;mark&gt; old&lt;/p&gt;  중요한 내용으로 하이라이트한 부분을 나타내준다(형광펜으로 칠한 것처럼)     색상을 background-color로 변경할 수 있다.   스크린리더가 구별해서 읽지는 않음   ▶️ small  &lt;p&gt;I can do it!&lt;/p&gt; &lt;small&gt;- jongbin said&lt;/small&gt;  추가적으로 덧붙이는 텍스트를 나타냄(크기를 작게 나타냄)   ▶️ sup  &lt;p&gt; 2&lt;sup&gt;10&lt;/sup&gt; = 1024 &lt;p&gt;  위 첨자 요소 (ex. 제곱을 나타낼때)   ▶️ sub  &lt;p&gt;log&lt;sub&gt;a&lt;/sub&gt;1 = 0&lt;p&gt;  아래 첨자 요소 (ex. log 함수의 밑, 각주)       &lt;p&gt;장바구니&lt;p&gt;  &lt;del&gt;간장&lt;/del&gt; &lt;ins&gt;계란&lt;/ins&gt;  &lt;p&gt;&lt;code&gt;console.log()&lt;/code&gt;는 출력한다&lt;p&gt;     ▶️ del, ins  &lt;p&gt;장바구니&lt;p&gt; &lt;del&gt;간장&lt;/del&gt; &lt;ins&gt;계란&lt;/ins&gt;     del: delete의 의미, 삭제된 것을 나타낼 때 (inline요소)        속성으로 cite(이슈), datetiem(일시)가 있다       insert의 의미, 추가된 것을 나타낼 때 (inline요소)        속성으로 cite(이슈), datetiem(일시)가 있다       스크린리더가 인식하지 않음   ▶️ code  &lt;p&gt;&lt;code&gt;console.log()&lt;/code&gt;는 출력하는 기능을 한다&lt;p&gt;  &lt;pre&gt;   &lt;code&gt;const age = 26;&lt;code&gt;     &lt;code&gt;console.log(age);&lt;/code&gt; &lt;/pre&gt;  inline 요소로 코드를 나태낸다  여러줄일 경우, &lt;pre&gt;로 감싸고 각 줄을 &lt;code&gt;로 표현한다   ▶️ kbd  &lt;p&gt; if you press &lt;kbd&gt;m&lt;/kbd&gt; button, the video will mute&lt;/p&gt;  키보드 입력 요소를 나타낸다   ▶️ a  &lt;p&gt;If you are interested our products, visit our website&lt;/p&gt; &lt;a href=\"https://jongbin.com\"&gt;Home Page&lt;/a&gt; &lt;a href=\"mailto:gghkdu2@gmail.com\"&gt;mail&lt;/a&gt; &lt;a href=\"tel:000-0000\"&gt;phone&lt;/a&gt;  anchor의 의미, href의 속성을 사용해서 다른 페이지로 이동하거나 하이퍼링크를 만든다     a의 요소 내용에는 텍스트만이 아닌 이미지나 문단 등등이 들어갈 수 있다        a의 자주 사용되는 속성                                  속성           설명                                           href           * href속성을 사용해서 다른 페이지로 이동이 가능케한다(하이퍼링크가 가르키는 URL)   - 절대경로 및 상대경로를 사용해서 지정할 수 있다   - 작동을 하지 않게 하려면 href=\"javascript:void(0)\"을 사용하는게 좋다   - 이메일이나 전화를 href의 값으로 할 수 있다. (관련 응용 프로그램이 있으면 작동)                             target           * 링크된 URL을 표시할 위치를 명시 (기본값: _self)   - _self: 현재 창에서 해당 URL로 이동   - _blank: 새 탭을 만들어서 해당 URL로 이동   - _parent: 부모(이전)의 브라우저에서 이동 (없을 시 _self와 동일)   - _top: 최상단의 브라우저에서 이동 (없을 시 _self와 동일)                             rel           * 해당 URL과 현재 페이지와의 관계를 나타냄   - 사용자에게 보여지지 않음 / 브라우저가 인식   - search, next, prev, hlep ….                           ▶️ Entity  공백이나 꺽쇄등(예약어)을 텍스트로 사용자에게 보여주기 위해 사용한다   &lt;p&gt;제목을 나타낼 때는 &amp;lt;h1&amp;gt; &amp;lt;/h1&amp;gt;을 사용합니다&lt;/p&gt;   // 결과 제목을 나타낼 때는 &lt;h1&gt; &lt;/h1&gt;을 사용합니다   일반 텍스트처럼 사용하고 `&amp;`로 시작해서 `;`로 끝난다                  의미       entity                       &lt;       &amp;lt;                 &gt;       &amp;gt;                 \"       &amp;quot;                 '       &amp;apos;                 &amp;       &amp;amp;                 ` `       &amp;nbsp;              이 외 더 확인할 수 있는 사이트  https://dev.w3.org/html5/html-author/charref        다음 포스팅에서 이어서 진행하겠습니다!  ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/HTML%EC%9A%94%EC%86%8C1/",
        "teaser": null
      },{
        "title": "HTML 요소 2 - (구조, 목록과 표, 임베디드)",
        "excerpt":"2. 구조를 나타내는 요소   ▶ div  division 이라는 뜻을 가지고, 구간이나 구획을 분할하거나 묶을때 사용한다(사용빈도 최강!)     block 요소 → 가로로 차지할 수 있는 영역을 차지(부모의 영역)   내용이 없으면 보이지 않음(height가 0이므로)   의미를 가지고 있지 않은 것이 특징   ▶️ span  구문 콘텐츠를 위한 요소     inline 요소 → 내용이 차지하는 부분만을 영역으로 차지   의미를 가지고 있지 않음   ▶️ 시멘틱 웹 (Semantic Web)      Semantic: 의미론적인    컴퓨터가 웹 상의 수많은 정보들을 보다 쉽게 해석할 수 있도록 나온 개념 (시멘틱 웹)     (출처: https://eunsukim.me/posts/understanding-semantic-html)   시멘틱 웹의 요소는 div와 동일하게 작동하지만 의미를 담고있다. (non-semantic: div, span)   &lt;!-- 기존의 웹 --&gt; &lt;div id=\"header\"&gt;title&lt;/div&gt;  &lt;!-- 시멘틱 웹 --&gt; &lt;header&gt;title&lt;/header&gt;  기존의 웹과의 차이를 살펴보면 한 눈에 알아보기 쉽고 보다 의미론적이기 때문에 내용을 유추할 수 있다.   시멘틱 웹의 장점     검색엔진이 정보를 수집하는데 수월함 (검색엔진에 보다 노출)   웹접근성이 보다 좋다 (스크린리더)   알아보기 쉽기 때문에 생산성, 유지보수 측면에서 좋다   - header  소개 및 탐색에 도움을 주는 콘텐츠를 나타낸다. (제목, 로고, 검색폼, 이름 등)   &lt;header&gt;      &lt;h1&gt; title &lt;/h1&gt; &lt;/header&gt;      header 내에 header가 들어올 수는 없다 -&gt; 다른 플로우 컨텐츠에서는 사용이 가능   페이지 전체 제목, 글 하나하나의 제목 등으로 사용될 수 있다   - footer  일반적으로 구획 작성자, 저작권정보, 관련 문서, 연락처 등의 내용을 가진다 (보통 웹페이지 맨 아래에 위치)   &lt;footer&gt;     &lt;p&gt;created by jongbin&lt;/p&gt; &lt;/footer&gt;     footer 내에 footer 또는 header가 들어올 수 없다 -&gt; 다른 플로우 컨텐츠에서는 사용이 가능   - nav  현재페이지, 다른페이지로의 링크를 보여주는 구획   &lt;nav&gt;   &lt;span&gt;Jongbin&lt;/span&gt;   &lt;ul&gt;     &lt;li&gt;&lt;a href=\"\"&gt;address&lt;/a&gt;&lt;/li&gt;     &lt;li&gt;&lt;a href=\"\"&gt;age&lt;/a&gt;&lt;/li&gt;     &lt;li&gt;&lt;a href=\"\"&gt;phone&lt;/a&gt;&lt;/li&gt;   &lt;/ul&gt; &lt;/nav&gt;     현재 페이지가 어디에 위치하는지를 보여줄 수 있다   현재 페이지를 기준으로 상위페이지 혹은 하위페이지로 이동할 수 있는 링크를 가지고 있다   페이지의 이동기능을 제공하기 때문에 a태그를 가지고 있음   전체적인 메뉴를 다룰 수 있다   하나의 문서에서 여러개의 nav태그를 가질 수 있다   - aside  사이드바를 만들때 주로 사용, 본문과 큰 연관이 없고 간접적인 추가적인 정보를 제공하기 위한 구획   &lt;aside&gt;     &lt;p&gt;부가적인 정보를 제공&lt;/p&gt; &lt;/aside&gt;     다른 링크 또는 광고를 제공하기도 함   스타일링이 되지 않았을때는 글의 일부분처럼 보임 (css를 이용해서 보통 좌우로 옮김)       - main  body의 주요 콘텐프를 나타낸다(핵심내용)   &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;main&gt;     &lt;!-- 주요 내용 작성 --&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt;     main은 body내 무조건 하나만 사용됨   다른 요소의 자식요소로 사용될 수 없다 (body만 부모요소로 올 수 있다)   IE에서는 지원하지 않는다 → &lt;main role=\"main\"&gt; 내용 &lt;/main&gt;로 접근성 확보   - article  독립적으로 구분해 배포하거나 재사용할 수 있는 구획   &lt;main&gt;     &lt;article&gt;내용1&lt;/article&gt;     &lt;article&gt;내용2&lt;/article&gt;     &lt;article&gt;내용3&lt;/article&gt; &lt;/main&gt;     따로 사용되어도 단독적인 의미를 가질 수 있는 요소를 표현할 때 사용   main의 자식요소로 여러개 사용될 수 있다.   재사용이 가능   section내에 여러개 article이 올 수 있고, 반대로 article내에 여러개의 section이 올 수 있다.        보통 각각의 article을 식별할 수 있도록 각각 제목을 넣어준다       &lt;article&gt;   &lt;header&gt;     &lt;h2&gt;article로 사용가능한 독단적인 영역&lt;/h2&gt;   &lt;/header&gt; &lt;/article&gt;           - section  html문서의 독립적인 구획을 나타냄  &lt;main&gt;     &lt;section&gt;내용1&lt;/section&gt;     &lt;section&gt;내용2&lt;/section&gt;     &lt;section&gt;내용3&lt;/section&gt; &lt;/main&gt;     제목태그를 사용해서 각각의 제목을 지정해 주기도 한다        article 태그와 section 태그의 차이   article로 구분이 되면 article을 사용하고 별다른 의미를 부여할 수 없으면 section을 사용한다 → 특정한 의미가 있고 없고의 차이   &lt;main&gt;   &lt;h1&gt;Jongbin&lt;/h1&gt;   &lt;section&gt;     &lt;h2&gt;like something&lt;/h2&gt;     &lt;p&gt;food, play&lt;/p&gt;   &lt;/section&gt;   &lt;section&gt;     &lt;h2&gt;intro&lt;/h2&gt;     &lt;p&gt;his age is 26! and his address is suwon&lt;/p&gt;   &lt;/section&gt; &lt;main&gt;  여기서 like something이나 intro는 단독으로 사용될 수 없다 따라서 article보다는 section이 알맞다       3. 목록과 표   목록태그는 크게 두가지로 구분할 수 있다.     순서가 있는 Ordered List(ol)   순서가 없는 Unordered List(ul)   ▶️ ol  순서가 있는 목록을 나타내는 태그  &lt;ol&gt;   &lt;li&gt;첫번째&lt;/li&gt;   &lt;li&gt;두번째&lt;/li&gt;   &lt;li&gt;세번째&lt;/li&gt; &lt;/ol&gt;     type속성: 기본값은 1, 영어로 구분 (대소문자 A,a), 로마자(I)   start속성: 시작점을 지정해줄 수 있다   value속성: 특정위치의 순서값을 지정해줄 수 있다 (이후에 오는 요소의 순서는 해당 순서의 다음 순서부터 진행)   reverse속성: 순서를 반대로 바꾼다   ▶️ ul  순서가 없는 목록을 나타내는 태그  &lt;ul&gt;     &lt;li&gt;a&lt;/li&gt;     &lt;li&gt;b&lt;/li&gt;     &lt;li&gt;c         &lt;ul&gt;             &lt;li&gt;catch&lt;/li&gt;             &lt;li&gt;carry&lt;/li&gt;         &lt;/ul&gt;     &lt;/li&gt; &lt;/ul&gt;     중첩이 가능하다   ol과 중첩될 수 있다        ul과 ol은 관계없이 list-style-type으로 숫자또는 사각형, 원형으로 나타낼 수 있다                                  값           설명           값           설명                                           none           장식 없음           lower-alpha           소문자 영어(a, b, c)                             disc           채워진 원형(기본값)           upper-alpha           대문자 영어(A, B, C)                             circle           속이 빈 원형           lower-roman           로마자 숫자(소문자)                             square           채워진 사각형           upper-roman           로마자 숫자(대문자)                             demical           숫자 형태                                                        list-style-image를 이용해서 기본형태가 아닌 이미지로 표현도 가능하다       ul { list-style-image : url('filepath') }           list-style-position을 이용해서 위치를 지정할 수 있다            outside : 블릿을 바깥에 위치(기본값)       inside : 블릿을 내부에 위치       inherit : 부모의 값을 상속받음           ▶️ li  목록(리스트)에 포함되는 아이템을 정의할때 사용한다     ul태그 또는 ol태그 내부에 사용된다   ▶️ dl, dt, dd  설명 목록을 나타낸다  &lt;dl&gt;   &lt;dt&gt;1&lt;/dt&gt;   &lt;dd&gt;one&lt;/dd&gt;      &lt;dt&gt;2&lt;/dt&gt;   &lt;dd&gt;two&lt;/dd&gt;      &lt;dt&gt;3&lt;/dt&gt;   &lt;dd&gt;three&lt;/dd&gt; &lt;/dl&gt;     dt와 dl을 자식태그로 가진다   용어 사전이나 메타데이터를 표시할때 사용   dt: 용어   dd: 설명   1:1, 1:n, n:1로 이루어질 수 있다(ex - 용어 하나에 여러 설명)   dt, dd를 div로 감쌀 수 있지만(css목적), 형제요소로 사용되지 않아야한다   ▶️ table  테이블을 나타내기 위한 요소   &lt;table&gt;   &lt;tr&gt;     &lt;th scope=\"col\"&gt;목록명1&lt;th&gt;     &lt;th scope=\"col\"&gt;목록명2&lt;th&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;내용1&lt;/td&gt;     &lt;td&gt;내용2&lt;/td&gt;   &lt;/tr&gt; &lt;/table&gt;     &lt;th&gt;: table head 제목을 나타냄(scope를 속성으로 사용할 수 있음 - 대표로 하는 범위)   &lt;td&gt;: table date 값을 나타냄   빈칸을 나타내기 위해서는 colspan을 사용한다   ▶️ 테이블 구획  테이블을 보다 명시적으로 나눌 수 있다  &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;목록명1&lt;th&gt;       &lt;th&gt;목록명2&lt;th&gt;     &lt;/tr&gt; &lt;/thead&gt;  &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;내용1&lt;/td&gt;       &lt;td&gt;내용2&lt;/td&gt;     &lt;/tr&gt; &lt;/tbody&gt;  &lt;tfoot&gt;     &lt;tr&gt;       &lt;td&gt;결과&lt;/td&gt;       &lt;td&gt;종합결과&lt;/td&gt;     &lt;/tr&gt;   &lt;/tfoot&gt; &lt;/table&gt;      thead: th가 들어가는 제목부분을 넣어준다   tbody: 본문의 내용은 tbody로 감싼다   tfoot: 마지막으로 footer의 부분은 tfoot으로 감싸준다   thead, tbody, tfoot은 tr이 형제요소로 올 수 없다(웹표준)   ▶️ caption  설명 또는 제목을 나타낸다  &lt;table&gt;   &lt;caption&gt;제목&lt;/caption&gt;   &lt;thead&gt;...&lt;/thead&gt;   &lt;tbody&gt;...&lt;/tbody&gt;   &lt;tfoot&gt;...&lt;/tfoot&gt; &lt;/table&gt;     caption은 항상 최상단에 위치해야 한다   figure가 함께 사용될 경우 caption을 사용하지 않고, figurecaption을 사용하는 것이 좋다       4. 임베디드 요소   ▶️ 이미지 유형  특정 확장자를 웹브라우저가 지원할때 이미지가 정상적으로 출력된다                  종류       MIME       확장자       설명                       JPEG       image/jpeg       .jpg, .jpeg, .jfif, .pjpeg, .pjp       정지 이미지의 손실압축에 적합하다(저장될수록 손실되기 때문에 여러번 재저장하면 픽셀이 뭉개진다)                 PNG       image/png       .png       원본이미지를 보다 정확하게 보여주거나 투명도 지원(무손실 압축, 파일크기가 비교적 크다)                 GIF       image/gif       .gif       여러장으로 이루어져 애니메이션 표현이 가능(256개의 색을 표현가능)                 WEBP       image/webp       .webp       구글이 만든 이미지 포멧으로 우수한 성능을 가지지만 사용할 수 있는 브라우저가 적다(파일크기가 작다)                 SVG       image/svg+xml       .svg       벡터이미지, 확대해도 깨지지 않음, XML언어로 구성되어 있다(이미지 임의 수정이 가능)           SVG(벡터이미지)를 제외한 나머지는 레스터(laster)이미지이다 크게 확대했을경우 래스터이미지는 깨지지만 벡터이미지는 전혀 깨지지않음 (사용처가 다름)   ▶️ img  이미지를 불러와서 삽입하는 태그(빈태그)  &lt;img src=\"filePath\" alt=\"대체텍스트\" width=\"100\" height=\"100\"/&gt;                  속성       설명                       src       필수적이며, 이미지의 경로를 지정(상대경로/절대경로)                 alt       정상적으로 이미지를 불러오지 못했을 경우 출력하는 텍스트(스크린리더가 읽음 - 웹접근성!)                 title       마우스를 올렸을때 텍스트가 나오도록 할 수 있다                 width       이미지 픽셀기준으로 가로너비를 단위없이 숫자값을 입력(단독사용시 비율을 맞춤)                 height       이미지 픽셀기준으로 세로높이를 단위없이 숫자값을 입력(단독사용시 비율을 맞춤)                 srcset       * 하나의 경로만 지정하는 src속성과 다르게 srcset은 여러개의 경로를 지정해 반응형처럼 보여줄 수 있다   - 사용자의 환경에 맞춰 적절한 이미지를 로딩한다(작은 사이즈일수록 파일의 크기가 작음 → 효율적)   - srcset은 IE는 지원하지 않는다 따라서 srcset과 함께 src를 지정해주는 것이 좋다   - 너비서술자(w): srcset=\"filepath1 300w\", filepath2 450w, filepath3 600w\"   - 픽셀밀도서술자(x)도 존재하나 너비서술자가 사용하는데 편하다   - @media를 사용하는것을 권장 (개발자가 원하는 결과를 명시할 수 있다)                 sizes       * 해당 범위에서의 크기를 지정할 수 있다   - min-width로 명시한다   - sizes=\"(min-width: 600px) 600px, (min-width: 450px) 450px, 300px\"           ▶️ video  비디오파일을 삽입하는 태그  &lt;video src=\"filePath\"&gt;failed loading video&lt;/video&gt;      내부 텍스트는 비디오가 정상적으로 출력되지 않을때 출력된다   src속성: 옵션이다 자식요소로 &lt;source&gt;로 지정해줄 수 있기 때문이다   controls속성: boolean속성으로 기본적인 인터페이스가 제공됨(기본값 false)   autoplay속성: boolean속성으로 자동재생되도록 한다 자동재생되지않는 경우가 있는데 비디오에 사운드가 포함된 경우 재동재생을 브라우저가 막는 경우가 있다(UX를 위해) → muted와 함께 사용   muted속성: boolean속성으로 음소거된다   poster속성: 기본적으로 첫 프레임이 섬네일로 출력 파일로 지정하는경우 해당 이미지가 출력된다   ▶️ audio  비디오가 동일하게 사용되며 오디오파일을 삽입하는 태그  &lt;audio&gt;   &lt;source src=\"filePath1\" type=\"audio/ogg; codecs=opus\" /&gt;   &lt;source src=\"filePath2\" type=\"audio/ogg; codecs=corbis\" /&gt;   &lt;source src=\"filePath3\" type=\"audio/ogg; codecs=mpeg\" /&gt;   정상적으로 출력되지 않을때 출력하는 텍스트 &lt;/audio&gt;     여러개의 source를 지정해서 지원가능한 형식을 찾도록 할 수 있다   ▶️ canvas  html로 마크업을 한 뒤 javascript를 이용해서 내부에 그림을 그린다   ▶️ iframe  source를 프레임안에 띄워주는 태그     지도를 삽입할때 많이 사용한다       다음 포스팅에서 이어서 진행하겠습니다!   ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/HTML%EC%9A%94%EC%86%8C2/",
        "teaser": null
      },{
        "title": "HTML 요소 3 - (폼 관련 요소)",
        "excerpt":"5. 폼 관련 요소   ▶️ form  정보를 제출하기 위한 입력창 (사용자와의 대화형 문서구획)           form 내부에 input창 또는 제출을 위한 버튼을 만들어 입력한 정보를 제출하는 등의 동작을 수행할 수 있다       action속성: 제출하는 주소(form 데이터를 전송함)   method속성            POST: 입력된 데이터를 body 본문에 담아서 전송한다(주소창에 데이터가 보여지지 않는다)       GET: action의 url과 ?와 입력한 데이터를 name과 =를 덧붙여 전송한다(사용자가 입력한 데이터를 주소창에 보여진다)       POST는 GET과 다르게 body에 데이터를 담아서 전송하기 때문에 크기의 제한이 없다(대용량 데이터를 담아서 보낼 수 있다)           ▶️ fieldset  여러 개의 label과 input들을 묶어줄 때 사용한다  &lt;form&gt;   &lt;fieldset&gt;     &lt;legend&gt;Login&lt;/legend&gt;      &lt;label for=\"user-id\"&gt;User Id&lt;/label&gt;     &lt;input type=\"text\" id=\"user-id\" name=\"user-id\"&gt;      &lt;label for=\"user-password\"&gt;User Password&lt;/label&gt;     &lt;input type=\"password\" id=\"user-password\" name=\"user-password\"&gt;   &lt;/fieldset&gt; &lt;/form&gt;     legend태그는 범례를 뜻하고, fieldset에서 제목으로 사용된다 (무조건 첫번째 자식요소로 와야함)   ▶️ input  여러가지 데이터를 입력받을 수 있다 (텍스트만이 아닌 checkbox, file, number 등)   &lt;form action=\"\" method=\"GET\"&gt;   &lt;label for=\"test\"&gt;&lt;/label&gt;   &lt;input type=\"text\" name=\"dataName\" id=\"test\"&gt;   &lt;button type=\"submit\"&gt;&lt;/button&gt; &lt;/form&gt;  input은 보통 label과 함께 쓰여진다(label - 입력창이 무엇을 가르키는지 설명해주는 역할) label의 for속성은 input을 가르키기 위해서 사용되는데 이때 input의 id값을 가르킨다 또는 for 속성을 사용하지 않고 label의 자식요소로 input을 사용한다    input type                   type       설명                       text       텍스트 입력칸(기본값)                 password       text와 속성은 같으나, 데이터가 보이지 않음(*로 보임)                 checkbox       체크박스를 만듬(여러개 선택 가능) -&gt; 제출하면 name에 on이 추가되어 보여진다                 radio       라디오 버튼(한가지만 선택가능)                 button       누름버튼                 submit       데이터 전송 버튼                 reset       재설정 버튼 (form 내부의 데이터를 초기화한다)                 file       파일 선택칸을 만듬                 hidden       사용자에게 보여지지 않는 창을 만듬                 image       이미지로 된 전송버튼(src=\"이미지경로\")                 color       색상 선택칸을 만듬                 date       날짜 입력칸(년, 월, 일)                 datetime       날짜 시간칸(년, 월, 일, 시, 분, 초, 초분할) - 표준시간o                 datetime-local       날짜 시간칸(년, 월, 일, 시, 분, 초, 초분할) - 표준시간x                 email       email 주소칸                 month       년과 달 입력칸                 number       숫자 입력칸(max, min, step, value)                 range       동영상 컨트롤러 처럼 범위가 있는 칸을 만듬                 search       검색칸                 tel       전화번호 입력칸                 time       시간 입력칸                 url       주소 입력칸                 week       년과 주 입력칸           브라우저마다 지원하지 않는 type도 있으므로 Can I use 사이트에서 확인하는 것이 좋다      minlength=\"숫자\" maxlength=\"숫자\"로 최소길이, 최대길이를 지정할 수 있다   양식이 지켜지지 않은 경우 툴팁을 사용자에게 보여준다        checkbox나 radio 버튼의 경우 초기에 선택되어 있는 값을 checked속성으로 준다(boolean)       name속성: 제출했을때의 데이터를 구분해주는 역할은 한다, POST로 데이터를 보낼때 백에서 name을 key로 데이터를 받는다   placeholder: 입력칸의 힌트 역할을 한다, 입력칸에 데이터를 입력하면 placeholder가 사라지고, 다시 빈칸으로 만들면 나타난다   autocomplete: 자동완성기능이 작동 (on, off값을 입력해서 활성화 및 비활성화 한다 - 기본값은 on)   required: (boolean값) 무조건 입력되어야 한다   disabled: 입력할 수 없도록 한다 (아에 값이 존재하지 않도록 된다 - form 전송에 포함이 되지 않음)   readonly: 입력할 수 없도록 한다 (기본값value을 주고 변경하지 않을때도 사용)   step: 증가하는 단위(크기)를 지정한다   min, max: type이 number나 range일때 최소 최대값을 지정할 수 있다   ▶️ button  클릭가능한 버튼  &lt;button type=\"submit\"&gt;submit&lt;/button&gt;      type속성            submit: 입력한 데이터를 제출하도록 한다       reset: form내부의 값을 초기화한다       button: 아무 동작도 하지 않는다           value속성 : 버튼에 들어갈 텍스트(문자열)을 지정할 수 있다 (value를 사용하지 않고 태그의 내용으로 기입하는 경우 문자열이 아닌 다른 컨텐츠도 가능하다)   ▶️ select  값을 고를 수 있는 드롭다운 메뉴를 보여준다      선택보기는 option을 이용하고, option의 속성인 value는 제출될 데이터이다   처음에 “select”같은 기본 문구를 사용하기 위해서 select에 required을 추가하고, 해당 글의 option속성을 value=\"\"(빈값)로 한다   selected는 미리 선택되어 있을 값을 지정(bollean)   optgroup을 이용하면 보기를 그룹화시킬 수 있다.   &lt;form action=\"\" method=\"get\"&gt;     &lt;label for=\"num\"&gt;number&lt;/label&gt;     &lt;select name=\"num\" id=\"num\"&gt;         &lt;option value=\"\"&gt;select&lt;/option&gt;         &lt;optgroup label=\"1~3\"&gt;             &lt;option value=\"1\"&gt;1&lt;/option&gt;             &lt;option value=\"2\"&gt;2&lt;/option&gt;             &lt;option value=\"3\"&gt;3&lt;/option&gt;         &lt;/optgroup&gt;         &lt;optgroup label=\"4~6\"&gt;             &lt;option value=\"4\"&gt;4&lt;/option&gt;             &lt;option value=\"5\"&gt;5&lt;/option&gt;             &lt;option value=\"6\"&gt;6&lt;/option&gt;         &lt;/optgroup&gt;     &lt;/select&gt; &lt;/form&gt;   ▶️ datalist  가능한 선택지를 추천한다  &lt;form action=\"\" method=\"get\"&gt;     &lt;label for=\"num\"&gt;number&lt;/label&gt;     &lt;input name=\"num\" id=\"num\" list=\"num-list\"/&gt;      &lt;datalist id=\"num-list\"&gt;       &lt;option&gt;1&lt;/option&gt;       &lt;option&gt;2&lt;/option&gt;       &lt;option&gt;3&lt;/option&gt;       &lt;option&gt;4&lt;/option&gt;     &lt;/datalist&gt; &lt;/form&gt;      input에는 list=\"datalist의 id”, datalist에는 id를 지정한다   ▶️ textarea  여러줄(멀티라인)의 텍스트를 입력받을 수 있는 태그  &lt;textarea name=\"data\" id=\"data\"&gt;&lt;/textarea&gt;      미리 데이터를 입력할 수 있다   pre처럼 개행이 적용된다   자식요소를 가질 수 있다 ()   rows로 가로줄, cols로 세로줄의 수를 지정할 수 있다(늘어날 수 있다)   placeholder로 힌트를 제공할 수 있다   크기를 변경 할 수 있다 (고정시켜두기 위해서 resize: none;사용)   ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/HTML%EC%9A%94%EC%86%8C3/",
        "teaser": null
      },{
        "title": "CSS개요",
        "excerpt":"   CSS (Cascading Style Sheets)  HTML이나 XML로 작성된 문서의 표시 방법을 기술하기 위한 스타일 시트 언어이며 룰기반의 언어(Rule-based)이다      Cascading: 흐르는 의미를 뜻하며, 어떤 스타일을 적용할지 우선순위를 정할 수 있다    /* 중괄호(선언블럭)를 열고 닫는다 */ element 또는 selector {     /* 속성: 값; */ }      현재 버전은 CSS3 모듈별로 버전이 업데이트된다(지원이 되는지 확인하는 것이 좋다)   특정 요소, 선택자를 활용해서 요소에 스타일 규칙을 적용할 수 있다   주석은 /* 내용 */으로 작성할 수 있다   선언블럭내 각 값들 이후 세미콜론(;)를 붙힌다 (여러개 선언할 경우 무조건 필수)   선언 블럭내 코드들은 속성과 값이 쌍을 이룬다   ▶️ CSS를 적용하는 방법      내부 스타일(embedded)   인라인 스타일(inline)   외부 스타일(external)   1. 내부 스타일(embedded)  &lt;head&gt;&lt;/head&gt;내에 &lt;style&gt;&lt;/style&gt;을 생성해서 적용한다   브라우저가 html문서를 해석하다가 style을 만나면 css로 인식하고 해석한다   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;      &lt;!-- 내부스타일 부분 --&gt;     &lt;style&gt;         p {             font-size: 50px;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;p&gt;Hi Jongbin!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   2. 인라인 스타일(inline)  html 내부에서 하나의 요소에 적용하고 싶을때 사용한다      유지보수 측면에서 좋지 않기 때문에 권장하지 않는다   요소의 태그 내 style 전역속성을 사용한다   여러가지 스타일을 적용하기 위해서는 세미콜론(;)을 입력해서 구분한다   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 인라인 스타일 --&gt;     &lt;p style=\"font-size:50px;\"&gt;Hi Jongbin!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   3. 외부 스타일(external)  따로 css 파일을 생성해서 html에서 link태그를 이용해서 명시      rel속성: 현재파일과 해당 파일이 어떤 관계인지를 명시   href속성: 파일의 경로   빈태그이다   가장 권장하는 방법이다   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;     &lt;link rel=\"stylesheet\" href=\"파일의 경로\" /&gt; &lt;/head&gt; &lt;body&gt;     &lt;p&gt;Hi Jongbin!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   ▶️ Cascading 원칙  css는 상속이 되므로 지정한 스타일이 중복되어 무시되거나 덮어씌워진다. 따라서 우선순위를 정해줘야 하는데 규칙은 다음과 같다      상속이 되므로 자식요소는 부모의 스타일을 덮어쓴다 (산속되지 않는 속성도 있음)   동일한 스타일이라도 선언된 곳에 따라 우선순위가 정해진다   적용범위가 작을 수록 우선된다   코드상 뒤에 위치할수록 우선된다   ▶️ 우선순위가 강한 정도   ➡︎ 선언된 위치에 따라서  브라우저에 의해 정의된 스타일 &lt; 개발자가 선언한 스타일 &lt; 사용자가 구성한 스타일   ➡︎ 적용범위에 따라서  tag(요소) 스타일 &lt; class스타일(.클래스명) &lt; id스타일(#아이디명) &lt; 인라인스타일      우선순위가 낮을 경우 스타일이 무시된다   css는 상속이 된다(상속되지 않는 속성도 존재)       CSS의 프로퍼티나 기능 등 브라우저의 지원현황을 확인하고 싶은 경우 다음과 같은 사이트를 이용하면 좋다           브라우저 지원 : https://caniuse.com/     요소나 프로퍼티 기능 등의 설명: https://developer.mozilla.org/ko/      ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/css%EA%B0%9C%EC%9A%94/",
        "teaser": null
      },{
        "title": "vi,vim",
        "excerpt":"        vi: 유닉스 환경에서 사용되는 텍스트 편집기(editor)이다            vim:  ‘Vi IMproved’ 의 약자로  vi 호환 텍스트 편집기이다       vi는 모드가 존재한다      명령모드: esc를 이용해서 입력모드에서 명령모드로 전환할 수 있고, 명령어를 사용해서 복사를 한다던지 이동한다던지 하는 동작을 수행할 수 있다   입력모드: i를 이용해서 입력할 수 있는 모드로 전환한다   라인모드: 저장하거나, vi편집기를 종료하는 등의 작업을 수행할 수 있다       vi 편집기 명령어 정리   1. vi  vi을 실행하기 위해서는 터미널에서 vi 파일명을 사용한다     해당 파일이 존재하지 않는 상태라면 알아서 생성이 된다   % vi README.md   ~ ~ ~ ~ ~ \"README.md\" [New File]  이런 화면이 나오면 정상적으로 성공이다!   2. i  입력모드로 전환하기 위해서는 명령모드인 상태에서 i를 입력해서 전환할 수 있다 i를 입력하면 다음과 같이 하단에 INSERT가 나오며 입력모드임을 알 수 있다  ~ ~ ~ ~ ~ -- INSERT --  이 상태에서는 텍스트를 입력할 수 있다   esc를 눌러서 명령모드로 전환할 수 있다   3. :wq  [라인모드] 입력을 완료하고 파일을 저장해야 한다 이때 콜론(:)을 입력하고, w(저장), q(종료)를 사용할 수 있다   text1 text2 text3 ~ ~ :wq   w와 q는 각각 사용도 가능하고 조합해서 사용이 가능하다   4. 라인수 표기  라인모드로 현재 입력한 라인수를 볼 수 있다 콜론(:)을 입력후에 set nu를 입력하면 라인수가 편집기 내부에 보여지게 된다     1 Hi!   2 my name is JongBin   3 I'm 26 years old   4 I living in Suwon   5 Bye! ~ ~ ~ ~ :set nu   5. h, j, k, l  h, j, k, l는 화살표와 같다 명령모드 상태에서 각각 ←, ↓, ↑, → 로 동작한다   6. dd, yy, p  dd: 잘라내기 yy: 복사하기 p: 붙여넣기   7. 되돌리기(u), 다시되돌리기(control+r)  u를 입력하면 되돌릴 수 있다(←) 이후 되돌린 작업을 다시 반대방향으로 되돌리기(→) 위해서는 control + r를 입력해서 되돌릴 수 있다   다시 되돌릴 상태가 없는 최신 상태에서 control+r을 입력하게 되면 하단에 Already at newest change라는 텍스트가 출력된다   ▶️ 명령모드 command                  키        의미        키       의미                        i        현재 커서 위치부터 입력        I        현재 커서 줄의 맨 앞에서 입력                 a       현재 커서 다음 위치부터 입력         A       현재 커서 줄의 맨 뒤부터 입력                 o       현재 커서의 다음 줄에 입력        O       현재 커서의 이전 줄에 입력                 s       현재 커서의 한 글자 지우고 입력        S       현재 커서 한 줄을 지우고 입력                 ^       현재 줄의 처음으로 이동        $       현재 줄의 마지막으로 이동                  gg        맨 앞 첫 번째 줄로 이동        G        맨 끝 줄로 이동                  숫자+G        해당 숫자 줄로 이동        u        되돌리기                 Ctrl+F        다음 화면으로 이동        Ctrl+B        이전 화면으로 이동                 x       현재 커서가 위치한 글자 삭제        X       현재 커서가 위치한 앞 글자 삭제                 d+d       현재 커서의 줄 삭제        숫자+d+d       현재 커서부터 숫자만큼 줄 삭제                 y+y       현재 커서가 있는 줄 복사        숫자+y+y       현재 커서부터 숫자만큼 줄 복사                  p        복사한 내용을 현재 줄 이후로 붙여넣기        P        복사한 내용을 현재 줄 이전에 붙여넣기                  w        현재 커서에서 다음 단어로 이동        -       이전 줄의 처음으로 이동                  .        이전에 사용한 명령어 재실행        ~        대소문자 변경                  J        현재 줄과 다음 줄을 연결        &lt;+&lt;        현재 줄을 왼쪽으로 내어쓰기                  &gt;+&gt;        현재 줄을 오른쪽으로 들여쓰기        r        한 글자 변경하기                  Ctrl+G        마지막 줄에 현재 줄 정보 출력        )        다음 문장으로 이동                  (        이전 문장으로 이동        }        다음 문단으로 이동                  {        이전 문단으로 이동        +        다음 줄의 처음으로 이동                 (출처 : https://inpages.tistory.com/124)        (출처 : https://inpages.tistory.com/124)      ","categories": ["vim"],
        "tags": ["vim"],
        "url": "/vim/vim%EB%8B%A4%EB%A3%A8%EA%B8%B0/",
        "teaser": null
      },{
        "title": "메타데이터",
        "excerpt":"메타데이터(Metadata)   메타데이터는 &lt;head&gt;에 포함되는 내용으로 브라우저에 보여지지 않는 웹페이지의 정보를 가진다   ▶️ head  head태그 내부에 들어가는 내용은 사용자에게 보여지지 않는다 하지만 페이지에 대한 메타데이터(데이터를 설명하는 데이터)를 포함한다      데이터를 설명하는 데이터 ➞ html문서를 설명하는 데이터    ▶️ title  문서의 제목을 정의한다      &lt;title&gt;는 텍스트만 포함할 수 있고 다른 태그를 포함하면 무시한다   &lt;title&gt;는 &lt;head&gt;내에 한개만 존재할 수 있다   검색엔진이  결과페이지의 순서를 결정하는 구성요소 중 하나가 페이지의 제목 → 검색엔진에서 title을 알맞게 지었을때 검색의 상위(SEO)에 위치할 수 있다      좋은 제목을 작성할 때 참고하면 좋은 사항         하나 혹은 두 개의 단어로만 제목을 구성하는걸 피하세요. 콘텐츠를 설명하는 문장을 넣거나, 사전과 참고 문서의 경우 용어와 정의를 짝지어 사용하세요.     검색 결과는 보통 페이지 제목의 첫 55~60글자만 노출합니다. 이후 텍스트는 보이지 않을 수도 있으므로 글자 수를 제한하세요. 긴 제목을 반드시 사용해야 하는 경우, 중요한 부분을 앞에 배치해서 뒷부분이 없어지더라도 내용을 잃지 않도록 주의하세요.     “키워드 뭉치” 스타일의 제목은 피하세요. 제목이 단순한 단어 나열에 불과하다면 검색 알고리즘이 결과에서 순서를 내리곤 합니다.     웹 사이트 내에서 제목을 최대한 겹치지 않도록 하세요. 중복, 혹은 유사한 제목은 검색 결과의 정확도를 떨어트리는 요인입니다.      (출처 - https://developer.mozilla.org/ko/docs/Web/HTML/Element/title)   ▶️ meta  다른 메타관련 요소로 나타낼 수 없는 메타데이터를 정의   &lt;head&gt;   &lt;!-- 페이스북 페이지인 경우 --&gt;   &lt;meta name=\"applicetion-name\" content=\"facebook\" /&gt;   &lt;title&gt;Facebook&lt;/title&gt; &lt;/head&gt;     정보를 여러개 기입할때 meta태그를 여러번 사용해서 나열한다   meta태그의 name속성에는 이름을, content속성에는 그에 해당하는 값을 명시한다(이름-값)   빈요소이다   필수는 아니지만 검색엔진이 정보를 수집하기 수월하고, 검색결과 노출의 측면에서 좋다        meta태그의 name 값에는 여러가지가 있다                                  name           설명                                           application-name           웹 페이지에서 구동 중인 애플리케이션의 이름                             author           문서 저작자                             description           페이지에 대한 짧고 정확한 요약. Firefox, Opera 등 여러 브라우저는 즐겨찾기 페이지의 기본 설명 값으로 description 메타데이터를 사용합니다                             generator           페이지를 생성한 소프트웨어의 식별자                             keywords           페이지의 콘텐츠와 관련된, 쉼표로 구분한 키워드 목록                             referㄱer           문서에서 시작하는 요청의 HTTP Refeㄱrer 헤더(해당 페이지에 어떻게 왔는지를 표시하는 방법) - 흔적을 남기는 방법                             theme-color (en-US)           사용자 에이전트가 페이지 혹은 주위의 사용자 인터페이스를 표시할 때 사용해야 할 색상에 대한 힌트                             color-scheme           문서와 호환되는 하나 이상의 색채 조합                             viewport           뷰포트의 초기 사이즈에 대한 힌트 (모바일 장치에서만 사용하다가 현재는 거의 모든 브라우저가 사용)                             creator           단체, 협회 등 문서 저작자의 이름(다수이면 여러개의 meta태그 사용)                             publisher           문서를 출판한 자의 이름                             robots           협조적인 크롤러, 또는 “로봇”의 동작을 지정                              출처 : https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta/name       charset속성            문자 인코딩 방식을 나타낸다       유니코드는 거의 전세계의 언어를 지원한다(UTF-8) ```html                      ```       description(name)            페이지에 대한 설명을 나타낸다       검색결과시 브라우저에 노출된다           viewport(name)            width: 웹사이트를 렌더링 하고자 하는 뷰포트 너비를 정의 (양수 또는 device-width)       height: 웹사이트를 렌더링 하고자 하는 뷰포트의 높이를 정의 (양수 또는 device-height)       initial-scale: 실제 장치와 뷰포트의 비율을 지정(0.0 ~ 10.0) (보통 1.0)       maximum-scale: 최대 확대 비율 (0.0 ~ 10.0)       minimum-scale: 최소 확대 비율 (0.0 ~ 10.0)       user-scalable: yes 또는 no의 값으로 no인 경우 페이지 확대가 불가능하다(기본값 yes)       viewport-fit: 뷰포트의 크기 조절 (auto, contain, cover)           &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 브라우저의 접속하는 기기의 가로 사이즈와 viewport를 동일(width) 하게 하고, 비율은 1대 1로 지정(initial-scale)      viewport의 값으로 content=\"width=device-width\"를 하는 것이 일반적이다 width를 지정하면 height값이 보통 자동으로 되기 때문에 따로 지정하지 않는다   ▶️ link  현재 문서와 외부리소스의 관계를 명시한다   &lt;head&gt;   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt; &lt;/head&gt;     rel속성            stylesheet: css와 연결하기 위해 사용       icon: favicon을 연결하기 위해 사용 (파비콘: 웹 title이 표시되는 부분 옆의 icon)       기타 다른 파일을 불러올때는 타입을 명시해야한다(MIME 타입)           href속성: 파일의 경로를 입력   ▶️ MIME 타입  외부의 파일을 불러올때 해당 파일이 어떤파일인지 분석하지 않음 → 파일의 타입을 명시   전송된 문서의 다양성을 알려주기 위한 메커니즘(웹을 통해 여러 파일을 전달하기 위함)   파일을 불어올때 어떤 형식으로 됬는지 타입을 명시해주는 것을 MIME 타입이라고 함   type(대분류)/subtype(확장자)      /로 나누어 두개의 타입을 명시한다 (공백문자 허용 x)   브라우저에서 지원하지 못하는 유형들을 따로 지정해줘야 한다   비디오, 오디오 파일 등은 ASCII로 전송이 어렵기 때문에 텍스트로 변환이 필요   텍스트 파일로 변환하는 것을 인코딩(Encoding), 텍스트 파일을 바이너리 파일(비디오, 오디오 등)으로 변환하는 것을 디코딩(Decoding) 이라고 한다   대분류에는 text, image, audio, video, application이 있다   ▶️ style  HTML내에서 css를 적용할 수 있다 (내부스타일)   &lt;head&gt;   &lt;style&gt;     .box {       background-color: skyblue;       color: white;     }   &lt;/style&gt; &lt;/head&gt;   ▶️ script  js를 사용할 수 있도록 한다 script태그에는 두가지 사용방법이 있다      HTML내에서 직접 js를 사용한다   src속성을 이용해서 외부의 js파일을 불러온다   &lt;head&gt;     &lt;!-- 문법을 직접 작성 --&gt;     &lt;script&gt;         console.log(\"hi\");     &lt;/script&gt;      &lt;!-- 외부 파일을 불어옴 --&gt;     &lt;script src=\"js file path\"&gt;&lt;/script&gt; &lt;/head&gt;   script는 위치가 중요하다 브라우저가 html파일을 위에서부터 순차적으로 해석해내려온다 그러던중 script태그를 만나면 html의 해석을 중단하고, 자바스크립트 엔진에 의해서 js를 해석하게 된다   script는 head태그가 아닌 어디서든 사용이 가능한데 만약 html의 요소를 수정하는 js를 body내부의 요소들이 해석하기 전에 위치시키면 js코드내부에서 조작할 수 있는 html요소가 없기때문에 정상적으로 동작하지 않을 것이다 따라서 body의 가장 마지막에 script를 위치시키는 것이 좋다   만약 head태그 내부에 script를 위치시키려면 html이 모두 해석된뒤에 script를 해석하도록 하는 속성인 defer를 사용한다   &lt;head&gt;   &lt;script defer src=\"filePath\"&gt;&lt;/script&gt; &lt;/head&gt;   ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0/",
        "teaser": null
      },{
        "title": "CSS 선택자 (selector)",
        "excerpt":"CSS 선택자   ▶️ 주요 선택자   1. Type Slelector  태그이름을 통해서 선택한다 (유형선택자, 요소선택자, 타입선택자…)  div {     background-color: skyblue; }     HTML문서 내에 모든 요소들에 적용한다   일관적으로 적용할때 사용   보통 상단부에 작성한다(컨벤션)   2. Id Selector  전역속성인 id를 통해서 선택한다  #box {     background-color: skyblue; }     중복없이 유일하다(HTML문서 내 단 한개)   id앞에 #을 붙여서 표기한다   3. Class Selector  전역속성인 class를 통해서 선택한다  .box {     background-color: skyblue; }     여러개의 요소에 지정할 수 있고 한 요소에 여러개의 class를 가질 수도 있다(공백으로 구분)   class앞에 .을 붙여서 표기한다       ▶️ 속성선택자 (Attribute Selector)  태그의 속성을 통해서 선택한다   태그마다 가지고 있는 속성이 다름을 이용한다   1. [attr]  요소가 해당 속성을 가지고 있는지로 선택  a[target] {     color: yellowgreen; }   2. [attr=value]  요소의 해당 속성이 어떤값을 가지고 있는지로 선택   input태그의 type별로 작성할때 많이 사용된다  a[target=\"_blank\"] {     color: yellowgreen; }   3. [attr^=value]  요소의 속성의 값이 시작되는 것으로 선택  /* type태그 중에 값이 t로 시작하는 input태그에 적용  */ input[type^=\"t\"] {     background-color: black; }  /* type=\"text\" */ /* type=\"time\" */ /* type=\"tel\" */   4. [attr$=value]  요소의 속성의 값이 끝나는 것으로 선택  /* type태그 중에 값이 t로 끝나는 input태그에 적용  */ input[type$=\"t\"] {     background-color: black; } /* type=\"text\" */ /* type=\"submit\" */ /* type=\"reset\" */   5. [attr*=value]  요소의 속성의 값이 적어도 하나 이상 포함하는 것을 기준으로 선택  /* type태그 중에 값이 t를 포함하는 input태그에 적용  */ input[type*=\"t\"] {     background-color: black; } /* type=\"text\" */ /* type=\"submit\" */ /* type=\"reset\" */ /* type=\"tel\" */ /* type=\"time\" */       ▶️ 가상클래스 선택자 (Pseudo-Class Selector)  조건을 입력(:)해서 범위를 좁힌다   1. :first-child  형제요소들 중에서 첫번째 요소를 선택  li:first-child {     color: skyblue; }   2. :last-child  형제요소들 중에서 마지막 요소를 선택  li:last-child {     color: skyblue; }   3. :nth-child()  형제요소들 중에서 숫자로 지정해서 선택  li:nth-child(2n) {     color: skyblue; }     n을 입력해서 함수처럼 사용가능하다(1번째부터 시작)   2n : 짝수   even : 짝수   2n-1 : 홀수   odd : 홀수   4. :first-of-type  타입들(태그이름)중에 첫번째 요소를 선택  li:first-of-type {     color: skyblue; }   5. :last-of-type  타입들(태그이름)중에 마지막 요소를 선택  li:last-of-type {     color: skyblue; }   6. :nth-of-type()  타입들(태그이름)중에 숫자로 지정해서 선택 (nth-child와 비슷)  li:nth-of-type(2n) {     color: skyblue; }     n을 입력해서 함수처럼 사용가능하다(1번째부터 시작)   2n : 짝수   even : 짝수   2n-1 : 홀수   odd : 홀수   7. :not()  괄호 내부의 요소의 셀렉터를 제외하고 선택  selector:not(selector){     ... }  input:not(input[type=\"text\"]){     background-color: black; }     attr selector와 함께 할 수 있다   8. :link, :visited  방문기록을 사용해서 방문했는지 방문하지 않았는지에 따라 바뀐다.   /* HTML */ &lt;a href=\"address\"&gt;Link&lt;/a&gt;  a:link {     color: tomato; } a:visited {     color: skyblue; }     방문하지 않은 경우 토마토색상   방문했던 경우 하늘색   상태에 따라 css를 바꿔줌 (동적 가상클래스 선택자)   9. :hover  마우스를 해당 요소에 올려두었을때 css를 변경해준다  button {     background-color: white; } button:hover {     background-color: skyblue; }     마우스를 올려두기 전에는 흰색, 마우스를 해당 요소위에 올려두면 하늘색으로 바뀐다   다른 선택자들과 조합해서도 사용 가능하다   10. :active  마우스로 클릭하고 떼기전의 상태(mousedown 상태)일때 css를 변경해준다  button {     background-color: white; } button:active {     background-color: yellowgreen;     color: black; }     link나 button에 많이 사용된다   link, visited, hover, active 선택자를 사용할때는 LVHA(link-visited-hover-active)순서에 따라서 하는것을 권장(무시될 수 있기 때문에)   11. :focus  포커싱(선택되었을 때 - input에 입력할때, 버튼을 누를때 등)이 되었을때 css를 변경해준다  button {     background-color: white; } button:active {     background-color: blue;     color: black; }   12. :enabled  활성화되어 있는 요소에만 css를 변경  input[type=text]:enabled {     background-color: black; }   13. :disabled  비활성화되어 있는 요소에만 css를 변경  input[type=text]:disabled {     background-color: black; }   14. :checked  check된 요소만 css를 변경  input[type-checkbox]:checked {     outline: 3px solid skyblue;xw }       ▶️ 가상 요소 선택자 (Pseudo-Element Selector)  클래스가 없지만 있는것처럼 동작(실제로 존재하지 않는 범위를 만듬)      ::를 붙여서 표현(css3)   :하나만 붙여서 표현(css3 이전)   ::를 붙여서 가상 클래스 선택자와 구분해준다   이전에 읽어봤던 블로그 포스팅에 의하면 구형 브라우저에서는 ::를 지원하지 않기 때문에 크로스브라우저 차원에서 :를 하나로 사용한다는 것을 본 적이 있다      (해당 글의 본문)  차이는 없다. 오히여 더블콜론(::)::before을 쓴다면 ie8 이하 버전은 적용이 되지 않기 때문에 클론 하나만(:):before 쓰는 것이 좋다고 볼 수 있다. css2에서는 콜론이 하나였다가, css3에는 더블클론으로 바뀌었다.  https://green-webdesigner.tistory.com/20    1. ::before, ::after   ::before: 해당 요소의 앞에 가상의 요소를 생성한다 ::after: 해당 요소의 뒤에 가상의 요소를 생성한다   .box::before {     content: \"before\";  ← 원하는 텍스트를 기입한다         color: skyblue; } .box::before {     content: \"after\";         color: skyblue; }     해당 요소를 드래그 했을때 선택이 되지 않는다   2. ::first-letter, ::first-line, ::selection   first-letter: 첫 번째 글자에만 css를 적용  first-line: 첫 번째 줄에만 css를 적용 selection: 텍스트를 드래그 했을때의 css를 적용   p::first-letter {     font-size: 1.5em;     color: skyblue; } p::first-line {     font-size: 1.5em;     color: skyblue; } p::first-letter {     font-size: 1.5em;     color: skyblue; }     ::before와 함께 사용되면 before가 제일 앞에 위치하기 때문에 before에도 적용이 된다       ▶️ 선택자 결합  선택자들을 결합하거나, 하위 선택자 등을 사용해서 더욱 세부적으로 요소들을 선택할 수 있다   1. 하위 선택자  공백으로 구분해서 보다 세부적으로 요소들을 선택할 수 있다.   앞쪽이 있는것이 상위 요소, 뒤에 위치하는 것이 하위요소이다   ul li:first-of-type {     color: red; }   2. 자식 선택자  꺽쇄(&gt;)를 이용해서 구분한다 앞쪽에 위치한 것의 바로 자식요소들을 선택한다   .list &gt; li {     color: red; }   3. 형제 선택자     일반 형제 선택자 결합 (~)  ~ 앞에 위치한 요소의 형제요소이지만, 코드위치상으로 뒤쪽에 위치한 것을 선택      &lt;p&gt;p-1&lt;/p&gt;  &lt;div&gt;div-1&lt;/div&gt;  &lt;p&gt;p-2&lt;/p&gt;  &lt;p&gt;p-3&lt;/p&gt;           div ~ p {      color: red;  }          p-2와 p-3만 color가 red가 된다       인접 형제 선택자 결합 (~)  +앞에 위치한 요소의 형제요소중애서 코드 위치상 바로 다음 요소를 선택      &lt;p&gt;p-1&lt;/p&gt;  &lt;div&gt;div-1&lt;/div&gt;  &lt;p&gt;p-2&lt;/p&gt;  &lt;p&gt;p-3&lt;/p&gt;           div + p {      color: red;  }          p-2만 color가 red가 된다       4. 그룹화  ,를 사용해서 여러개의 요소를 선택할 수 있다  div, span {     background-color: skyblue; }     div와 span 모두 background-color가 skyblue가 된다       ▶️ 범용선택자 (Universal Selector)  (전체선택자) *을 사용해서 모든 요소를 선택한다  * {     color: skyblue; }     보통 파일의 맨 위에서 사용한다   중간에서 사용하게 되면 잘못되었을때 찾기가 어렵다       ▶️ 상속제어  css는 기본적으로 상속이 되는데 이것을 제어할 수 있다   1. initial  상속을 받지 않도록 한다   2. inherit  무조건 상속값을 사용하도록 지정함   3. unset     부모로 받은 상속값이 존재할때: inherit으로 동작   부모에게 상속받을 값이 없을때: initial로 동작   → 보통 초기화를 할때 사용한다       ▶️ 우선순위           선언된 위치에 따라서 적용  인라인스타일 &gt; 내부스타일과 외부 스타일 중 html 문서의 코드 위치상 뒤에 작성된것       명시도가 높은것(적용범위가 낮은것)이 우선됨            !impoirtant       inline sytle       Id       Class/Attribute/Pseudo Class       Type       *       상속받은 값           코드상에서 늦게 작성된 것이 우선된더   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/%EC%84%A0%ED%83%9D%EC%9E%90(selector)/",
        "teaser": null
      },{
        "title": "전역속성",
        "excerpt":"전역속성  전역속성은 어떤태그에도 전부다 사용할 수 있다   ▶️ id  id는 식별자이며, 고유한 요소로 지정할 수 있다.   &lt;div id=\"box\"&gt;&lt;/div&gt;  #box {   background-color: #fff; }      id를 지정하고 표현할때 앞에 #을 붙여 표현한다   딱 하나의 요소에만 적용할 수 있다(유일한 id를 가진다 - 동일한 id는 존재할 수 없다)   id에 공백이 들어가서는 안된다   id의 시작 단어는 무조건 영어 소문자이다   ▶️ class  id와 비슷하지만 중복을 허용한다   &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box hide other\"&gt;&lt;/div&gt;         &lt;!-- box, hide, other의 클래스를 가진다 --&gt;  .box {   background-color: #fff; }      class를 지정하고 표현할때 앞에 .를 붙여 표현한다   중복이 가능하다(여러개의 요소에 지정가능)   하나의 요소에 여러개의 class가 지정할 수 있다   여러개의 class가 지정될 경우 공백으로 구분한다   하나의 클래스에는 공백이 들어가면 안된다   ▶️ style  css를 적용할 수 있다   &lt;div style=\"color:#000\"&gt;text&lt;/div&gt;      태그안에 들어갈 수 있다(inline style로 유지보수가 어렵다 - 권장하지 않음)   빠르게 style을 적용할 수 있다.   우선적으로 적용   ▶️ title  추가적인 설명을 툴팁으로 제공한다(마우스를 오버하면)   &lt;div title=\"this is text\"&gt;text&lt;/div&gt;      마우스를 올리면 툴팁이 나온다   공백, 개행을 인식한다   가장 하위 자식의 title이 우선 적용 (상속이 된다)   ▶️ lang  사용자가 읽는 언어를 지정한다   요소의 수정 불가한 텍스트언어와 수정가능한 텍스트가 사용해야 하는 언어를 지정      사용자가 읽는 언어를 기준   웹 접근성을 높여주는 요소   상속이 됨   html lang=\"언어\"로 지정하고 부분적으로 지정이 가능   &lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;종빈페이지&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;p&gt;안녕하세요&lt;/p&gt;     &lt;p lang=\"en\"&gt;hello&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;  html태그의 lang은 Ko로 지정하고 내부에서 영어를 사용해야 하는 부분이 있는 경우 부분적으로 해당 요소의 lang을 en으로 지정해준다 → 스크린리더가 읽을때 한국에에 최적화되어 읽다가 영어를 읽는 경우 부자연스러울 수 있다 따라서 영어임을 명시해줘야 한다   ▶️ data  표준이 아닌 개발자가 지정한 속성(정보)      data-로 시작하는 속성은 개발자가 지정한 data이다   사용자에게 보여지지는 않음   html이 데이터를 지닐 수 있게 한다   javascript(dataset)나 css(attr())로 접근가능   &lt;!-- HTML --&gt; &lt;div data-name=\"jongbin\" data-age=\"26\"&gt;JB&lt;/div&gt;   const data = document.querySelector(\"div\"); console.log(data.dataset);  // dataset으로 불러온다   ▶️ draggable  요소의 드래그 여부를 지정한다   &lt;div draggable=\"true\"&gt;text&lt;/div&gt;      스크롤하는 것이 아닌 요소를 끄는 기능   true, false값으로 명시   기본값은 auto이다   javascript를 이용하면 드래그를 이용해서 어떠한 기능을 만들 수 있다   ▶️ hidden  hidden을 적용해서 해당 요소가 보여지지 않도록 할 수 있다.   &lt;div hidden&gt;text&lt;/div&gt;      개발자도구로는 볼 수 있다(html문서가 가지고 있다)   boolean 값   display: none이 적용이 된다   css에서 display를 지정하면 보이게 된다   ","categories": ["HTML"],
        "tags": ["HTML"],
        "url": "/html/%EC%A0%84%EC%97%AD%EC%86%8D%EC%84%B1/",
        "teaser": null
      },{
        "title": "CSS요소 1 - 폰트 관련 속성",
        "excerpt":"텍스트에 적용될 수 있는 css 요소들을 살펴보겠습니다   CSS를 적용할 HTML예제는 다음과 같습니다   &lt;body&gt;   &lt;div&gt;     &lt;p class=\"default\"&gt;       Lorem Ipsum is simply dummy text of the printing and typesetting industry.     &lt;/p&gt;     &lt;p class=\"text\"&gt;       Lorem Ipsum is simply dummy text of the printing and typesetting industry.     &lt;/p&gt;   &lt;/div&gt; &lt;/body&gt;   ▶️ font-size  기본적으로 브라우저의 기본값은 16px이다 폰트의 크기를 변경할 수 있다   .text {   font-size: 20px; }     px, rem, rm의 단위를 많이 사용헤서 표현한다   ▶️ font-style  글꼴을 시스템폰트로 설정할 수 있다   .text {   font-style: italic; }     italic체로 변경하기 위해 많이 사용한다 (기울임)   기본값은 normal   ▶️ font-weight  텍스트의 굵기를 변경할 수 있다   .text {   font-weight: 500; }      보통 100단위의 숫자를 사용함 (400 = normal)   normale(400), bold(700), lighter(부모보다 얇게), bolder(부모보다 굴게) - 키워드로 입력할 수 있다   폰트마다 지원하는 굵기가 다를 수 있다   ▶️ font-family  텍스트의 글꼴을 지정할 수 있다  p {   font-family: Verdana, Arial, sans-serif; }      여러개가 값으로 들어간 경우 앞에서부터 차례대로 있는지 확인하고 있으면 사용하고 나머지는 무시한다   마지막에 있는 값은 지정한 폰트가 없을때 브라우저에서 해당 유형의 글꼴을 알아서 선택한다   ▶️ line-height  줄의 높이를 의미  p {   line-height: 2.0; }     폰트의 작성자가 기본값을 지정한다 (폰트마다 다를 수 있음)   값(양수, px, %)을 지정해서 모든 글들의 높이를 맞추는 것이 좋다   ▶️ font  단축속성으로 여러 요소를 한줄로 표현할 수 있다 (6가지)    p {     font-size: 20px;     font-family: 'Times New Roman', Times, serif;     font-style: italic;     font-weight: 700;     line-height: 2.0;      /* 위 코드와 동일 */     font: italic weight 20px/2.0 'Times New Roman', Times, serif;   }     필수속성: font-size, font-family   선택속성: font-style, font-variant, font-weight, line-height   style과 weight는 size보다 앞에 있어야 한다   line-height는 size뒤에 /를 붙이고 표현한다   작성을 하지 않으면 inital값이 된다   ▶️ letter-spacing  글자간의 간격을 지정한다  p {   letter-spacing: 5px; }     기본값 normal   음수를 사용하면 글자끼리 겹치기도 함   px, rem em 단위를 사용할 수 있다   폰트 제작자가 기본값을 지정해주었기 때문에 폰트마다 다르다   굳이 조절하지 않는 것이 좋다   ▶️ word-spacing  단어 사이의 간격을 지정한다  p {   word-spacing: 5px; }     px, rem, em, % 단위를 사용할 수 있다   ▶️ text-align  텍스트를 정렬할 수 있다  p {   text-align: left }     많이 사용하는 값으로는 왼쪽 오른쪽, 중앙 정렬이 있다(left, right, center)   block요소에서 변하는 길이에 맞춰서 정렬이 된다   ▶️ text-indent  들여쓰기에 관련되어 제일 앞 부분을 어느정도 띄울지 지정할 수 있다  p {   text-indent: 20px; }     상속이 된다   block요소에만 적용이 된다   % 단위도 사용이 가능하다   ▶️ text-decoration  단축속성으로 글자의 장식을 지정한다   p {     text-decoration: underline skyblue 5px double  }      공백으로 구분   순서가 중요하지 않다                  text-decoration-style       solid, double, dooted, dashed, wavy                 text-decoration-line       none, underline, overline, line-through   여러개를 동시에 사용할 수 있다                 text-decoration-color       텍스트의 색상을 지정한다                 text-decoration-thickness       장식의 두께를 지정한다           ▶️ word-break  자신의 영역 이외로 나가게 될경우 줄바꿈을 하는데 단어가 분리되지 않는다 (줄바꿈의 기준 설정)  p {     word-break: break-all; }     기본값일때 영어(keep-all)의 경우 요소를 뚫고나감, 한글(break-all)은 줄바꿈   기본값은 normal   break-all: 줄바꿈을 한다   keep-all: 요소를 벗어나도 줄바꿈이 되지 않음   ▶️ text-transform  p {     text-transform: uppercase }     한글에는 적용할 수 없음   기본값은 none   uppercase: 대문자   lowercase: 소문자   capitalize: 문장의 제일 앞글자만 대문자   개발자도구로 보았을때는 소문자로 표시 (보여질때 css가 적용되어 대문자로 보임)   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/CSS%EC%9A%94%EC%86%8C1/",
        "teaser": null
      },{
        "title": "Git, Github",
        "excerpt":"   git은 분산 버전 관리 시스템(Version Control System)이다. git을 사용하면 동료들과 협업하기가 매우 수월해지고 버전을 관리하는데 용이하다   git을 사용하기 전에 설정을 하고 보다 정확하고 편리하게 사용하자!      git config --global user.name \"name\"   git config --global user.email \"email\"   git config --global core.pager \"cat\"   git config --global core.editor \"vim\"   git config --list로 제대로 설정이 되었는지 확인하기   user.email=gghkdu2@gmail.com user.name=JJongBin core.editor=vim core.pager=cat  config를 수정한 부분이 정상적으로 수정되었는지 확인한다!   ▶️ 정방향으로 git을 사용하는 방법   1. git init   사용자가 remote repository까지 밀어넣는법은 다음과 같다      git init: 현재 폴더를 git을 사용할 수 있도록 만든다   git branch -M main: git의 branch가 master에서 main으로 변경되었기 때문에 branch를 main으로 변경한다   git remote add [alias] [repository 주소]: 사용자의 git 저장소와 연결시켜준다   파일을 작업한 후에 git add [file-name]으로 stage에 파일을 올려준다   git commit: local repository로 stage에 있는 파일을 commit message와 함께 올려준다   git push origin main: remote repository로 commit 된 내역들을 밀어넣는다 이때 만약 commit이 처음 이라면 싱크를 맞춰주기 위해 -u flag를 사용한다   2. clone  git페이지에서 저장소를 생성한 후에 주소를 복사하고 다음의 명령어를 입력한다   git clone [repository주소]   이하 과정은 remote 이후의 과정과 동일하다!   - 참고  추가적으로 권장하지 않는 사항이 있다      git add .: 모든 파일들이 모두 stage로 올라가기 때문에 관리 측면에서 어렵고 꼬일 수 있는 경우가 많다   git commit -m \"\": 간단하게 vi를 이용하지 않고 commit message를 작성할 수 있는 방법이지만 여러줄을 이용해서 제목, 내용을 commit message로 작성하는 것을 권장하고, 여러줄을 작성할때 -m을 사용한 commit은 이전줄의 수정이 어렵기 때문에 처음부터 다시 해야될 수 있다   ▶️ commit 작성 요령      영어로 commit message를 작성한다   commit 제목만 보고도 작업의 유형을 유추할 수 있도록 적어주는 것이 좋다   작업단위가 다른 경우에는 commit을 따로 해줘야한다   commit의 제목은 40자를 넘기지 않도록 한다   제목과 내용 사이에는 한줄의 공간을 준다   commit message의 첫 부분에 type을 명시하는 것이 좋다고 하는데 어떤 작업을 했는지 유추할 수 있기 때문이다 type은 다음과 같이 정해져있다                  type       설명                       feat       새로운 기능에 대한 커밋                 fix       버그 수정에 대한 커밋                 build       빌드 관련 파일 수정에 대한 커밋                 chore       그 외 자잘한 수정에 대한 커밋                 ci       CI관련 설정 수정에 대한 커밋                 docs       문서 수정에 대한 커밋                 style       코드 스타일 혹은 포맷 등에 관한 커밋                 refactor       코드 리팩토링에 대한 커밋                 test       테스트 코드 수정에 대한 커밋           ▶️ commit 시 주의 사항     동작하는 최소단위로 커밋한다 -&gt; 동작한다는 것을 전제로 하고 있기 때문에   영어를 사용해서 commit message를 작성한다   제목은 축약, 내용은 문장형으로 작성한다   내용에서는 제목에서 작성하지 못한 세부적인 부분을 작성한다   ▶️ README.md  프로젝트와 저장소를 설명하는 문서로 repository를 보는 다른 사람들을 위한 표지의 역할을 한다   ▶️ .gitignire  .gitignore는 git에 올리지 않도록 하는 역할을 한다. 폴더나 파일명을 적어주면 된다     쉽게 작성할 수 있는 사이트: https://gitignore.io    ▶️ LICENSE  많이 사용되는 라이센스는 다음과 같다      MIT License: 오픈소스로 자유롭게 사용   Apache License2.0: 무료로 사용해도 되지만 소유권을 주장할 수 있다   GNU General Public License v3.0: 해당 코드를 참조하면 GNU가 됨 -&gt; 의무적(MIT로 풀 수 없다)   만약 무엇이든 가져다 사용하는 경우가 있는 경우 라이센스를 확인해야한다 (라이센스가 보이지 않아도 메일을 보내는 등 꼭! 확인해봐야 한다)   ▶️ branch  git은 동일한 코드를 다른 동료들과 함께 공유하고 다룰 수 있는데 branch라는 개념이 있기 때문이다 branch는 가지라는 뜻으로 현재 줄기에서 가지를 새로 뻗는다고 생각하면 된다   현재 git은 main branch를 사용한다 이 main에서 새로운 branch를 생성하여(branch를 친다라고 한다) 수정하고 merge해서 main에 반영할 수 있다      git branch [branch-name]으로 새로운 branch를 생성한다   아직 현재 branch는 main이므로 새로운 branch로 이동해줘야 한다 → git switch [branch-name] or git checkout [branch-name]   만약 새로운 branch에서 파일을 수정하고 merge하기전에 기존의 main에서 수정한 파일이 수정되어 있다면 무언가 잘못된 것이다 → 각각의 branch에서 작업한 내용은 merge하기전에 반영되지 않는다   ▶️ merge  별도의 branch에서 파일을 작성하거나, 수정하고 기존의 branch로 반영하기 위해서는 git merge [branch-name]라는 명령어를 이용한다   기존의 branch에서 별도의 branch에서 수정한 파일을 동시에 수정하지 않았다면 그냥 병합된다   하지만 동시에 똑같은 파일을 수정했을 경우를 충돌했다고 하는데 협의 후 진행하도록 기존 branch의 파일 내용과 별도 branch의 파일 내용이 같이 존재하는 파일이 생성된다   test.py파일을 생성하고, 새로운 branch를 만들어서 테스트해봤다      main branch test.py     print(\"This is main branch!!!\")           stem branch test.py     print(\"This is stem branch!\")           git merge stem을 한 결과 다음과 같은 메세지를 볼 수 있었다  Auto-merging test.py CONFLICT (content): Merge conflict in test.py Automatic merge failed; fix conflicts and then commit the result.  merging이라는 메세지를 보니 merge가 아직 진행중이며 완료되지 않았음을 알 수 있었다   main의 test.py를 보면 다음과 같다  &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD print(\"This is main branch!!!\") ======= print(\"This is stem branch!\") &gt;&gt;&gt;&gt;&gt;&gt;&gt; stem  두 파일이 합쳐져있었다 여기서 협의를 해서 최종적인 코드를 작성하면 된다   print(\"This is main branch but stem plused main branch!\")   이후 add, commit , push 해주면 정상적으로 remote repository에 반영이 된다   ▶️ git flow  git을 이용해 여러명이 개발을 할때 거의 표준처럼 사용되는 방법이다   git flow에서는 branch를 5가지를 사용한다                  branch       설명                       main       기준이 되는 브랜치로 제품을 배포하는 브랜치                 develop       개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 합친다                 feature       단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 합친다                 release       배포를 위해 main 브랜치로 보내기 전에 먼저 검사 하기위한 브랜치                 hotfix       main 브랜치로 배포를 했는데 버그가 생겼을 떄 긴급 수정하는 브랜치           git flow를 하기 위해서는 준비가 필요하다   macos의 경우 다음의 명령어를 이용해서 git-flow를 다운받는다(brew를 이용하므로 brew 필요!) brew install git-flow-avh   window의 경우 git bash를 이용하는 경우 받지 않아도 된다      참고 https://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html    - feature  feature는 개발하기 위한 branch이다   Git flow feature start [branch 이름]\t\t// branch를 생성하고 해당 branch로 이동 Git flow feature finish [branch 이름]\t  // branch를 종료하고 원래 branch로 이동  기존에는 branch를 생성하고 switch를 이용해서 이동까지 해야하지만 자동으로 해준다   이렇게 생성된 branch는 feature/입력한 branch이름이 된다   만약 잘못 생성한 경우 main branch로 이동한 후 해당 branch를 삭제해주면 된다 (git branch -D [branch-name])   - release  relaese는 main으로 반영하기 전에 검사를 할 수 있는 branch이다   Git flow release start  [버전] Git flow release finish [버전]  finish를 하게 되면 세번의 vi을 마주하게 된다 첫번째는 main, 두번째는 release note(tag) 세번째는 develop에 반영이 되는 commit이다   이후 각각 main, develop, tag에 push를 해주면 된다  git push origin main git push origin develop git push --tag        # 버전의 표현  버전은 보통 v0.0.0 처럼 표현한다 만약 다음과 같이 세자리로 구성되어 있다면   Release Number . Major Number . Minor Number      Release Number: 1로 시작해서 큰 변화가 발생했을 때 이 수치를 올린다   Major Number: 0으로 시작해서 주요 기능의 추가나 변경 등 사용상 혹은 컨텐츠의 주요 변화가 발생했을 때 1 또는 무작위로 증가한다. 간혹 알파벳이 붙기도 하는데 예를 들어 Beta(테스트버전)의 경우 b를 숫자 뒤에 붙이는 경향이 있다.   Minor Number: 0으로 시작해서 버그 수정 등 미미한 변화가 발생하면 1씩 혹은 무작위로 증가한다. 역시 개발사 정책에 따라 특정 알파벳이 붙을 수도 있다.   ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git,-github1/",
        "teaser": null
      },{
        "title": "CSS요소2 - 단위와 값",
        "excerpt":"MDN을 참고하면 CSS마다 허용하는 단위값이 따로 있다 따라서 MDN을 참고 해서 허용되는 범위, 단위를 알고 사용해야 한다!   단위     상대길이 단위: 기준점이 있는 상태에서 기준점의 배율            em, rem, vw, vh           절대길이 단위: 고정적인 값            px           ▶️ px     px을 굉장히 많이 사용한다   모니터는 점으로 이루어져 있는데 px은 점 하나를 뜻함(근래에는 아닌 경우가 있음)   보통의 브라우저에서는 기본값이 16px이다   ▶️ em  상대적인 단위로 부모의 font-size를 기준으로 지정된다     %와 동일하다   부모가 font-size:20px이면, 해당 요소가 font-size: 2em인 경우 40px이 된다   ▶️ rem  상대적인 단위로 root(브라우저)의 font-size(보통 16px)를 기준으로 지정된다     %와 동일하다   만약 해당 요소가 font-zise: 2rem인 경우 32px이 된다   ▶️ vw  viewport(브라우저의 크기)의 너비를 기준으로 한다(뷰포트 백분율)     너비를 100vw로 두고 지정한다   50vw → 보여지는 브라우저 너비의 50%   ▶️ vh  viewport(브라우저의 크기)의 높이를 기준으로 한다(뷰포트 백분율)     높이를 100vh로 두고 지정한다   50vh → 보여지는 브라우저 높이의 50%   ▶️ vmin, vmax  가로 세로에 따라서 100vw, 100vh중 큰것이 vmax, 작은것이 vmin이다     반응형에서 사용된다   ▶️ %  부모요소를 100%로 두고 계산한다  .container {   width: 100px; } .container .box {   width: 50% }  .box의 width는 50px이 되고 .container의 width가 변경될때마다 값이 바뀔 것이다   ▶️ 함수표기법  값을 계산해서 표현할 수 있다      calc()            값을 계산해서 넣을 수 있다.       사칙연산(+, -, /, *)이 가능하다       연산자 좌우에는 공백을 줘야 한다       브라우저가 자동으로 계산한다           min()            더 작은 값을 자동으로 선택한다           max()            더 큰 값을 자동으로 선택한다           min()과 max()는 IE에서는 지원하지 않는다   .box1s {   /* 전체 너비에서 100px을 뺀 값 */   width: calc(100% - 100px); } .box2 {   /* 전체 너비와 100px 중에서 더 작은 값 */   width: min(100%, 100px); }ß .box3 {   /* 전체 너비와 100px 중에서 더 큰 값 */   width: max(100%, 100px); }   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/CSS%EC%9A%94%EC%86%8C2/",
        "teaser": null
      },{
        "title": "CSS요소3 - 박스 모델",
        "excerpt":"박스모델  브라우저에서는 전부 네모 형태로 계산이 되어진다      바깥쪽부터 margin영역-border영역-padding영역-content영역으로 나눠져있다   ▶️ width, height  요소의 너비 및 높이를 설정할 수 있다   .box {     width: 100px;     height: 100px; }     px, em, rem, % , vw, vh 단위를 사용할 수 있다   상속이 되지 않는다   기본값이 auto는 블록요소의 경우 너비가 최대(100%) 높이는 내부 content만큼을 차지한다   인라인 요소의 경우 너비 및 너비가 내부 content만큼 차지한다(width, height 지정 x)   ▶️ max, min  최대, 최소의 너비 및 높이를 설정할 수 있다.   .box {     width: 50%;     height: 100px;     min-width: 100px; }     위 코드에서 box 클래스는 부모의 50%의 너비를 가지지만 최소 100px의 값을 가진다   max-width, min-width, max-height, min-height   ▶️ margin  단축속성으로 다른 요소와의 간격을 조절할 수 있다(요소의 외부 여백을 지정)   .box {     width: 100px;     height: 100px;     margin: 10px;     /* === margin: 10px 10px 10px 10px; */     /* 각각 다른 값을 입력할 수 있고, 특정방향의 margin을 주지 않으려면 0을 입력한다 */ }     margin은 단축속성으로 margin-top, margin-right, margin-bottom, margin-left로 구분될 수 있다   단축속성은 공백으로 구분된다.   margin의 단축속성은 margin: top right bottom left;로 시계방향으로 지정하면 된다   단축속성의 값으로 두개를 입력시 (top, bottom) / (left, right)으로 표현   단축속성의 값으로 세개를 입력할 경우 (top) / (left, right) / (bottom) 으로 표현   %는 부모의 너비(width)를 기준으로 한다   음수값이 사용가능하다   ▶️ margin collapsong(마진상쇄)  마진이 겹쳐져서 상쇄되는 특성이다 (더 큰값이 적용 - 작은값 무시)     float요소와 절대위치의 요소는 여뱍상쇄가 일어나지 않는다   이런 현상이 발생될 수 있는 경우     인접 형제            두 형제의 위아래의 여백이 상쇄됨(좌우는 x)           부모 자식요소간            부모요소의 여백과 자식요소의 여백이 만났을때(상하) -&gt; border나 padding값으로 구분해줄 수 있다           빈블록            빈블록이면 해당 블록의 margin-top과 margin-bottom이 만나게 된다 따라서 margin-top과 margin-bottom중에 더 큰 값으로 상쇄된다              MDN https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing    ▶️ padding  단축속성으로 요소 내부의 여백을 줄 수 있다   .box {     padding:10px; }      padding-top, padding-right, padding-bottom, padding-left 순으로 적용가능하다 (시계방향)   패딩상쇄는 존재하지 않는다   음수값을 사용할 수 없다   퍼센트(%)를 사용할 경우 부모요소의 가로길이(width)를 기준으로 한다   만약 요소의 크기가 100px일때 padding을 추가하면 그만큼 크기가 늘어난다   ▶️ border  단축속성으로 요소의 테두리를 설정해줄 수 있다  .box {     border: width style color;     /* border: 1px solid #000; */ }      border의 초기값은 0   border-width: 키워드(thin, medium, thick)또는 단위(px)을 사용해서 굵기를 나타낸다   border-style            none: 보이지 않음(우선순위 제일 낮음)       hidden: 보이지 않음(우선순위 제일높음)       dotted: 둥근 점       dashed: 직사각형 여러개       solid: 하나의 직선       double: 두개의 직선       groove: 테두리가 파인 것처럼 보임       ridge: 테두리가 튀어나온 것처럼 보임       inset: 요소개 파인 것처럼 보임       outset: 요소가 튀어나온 것처럼 보임           border-color: 테두리 선의 색상을 설정   각 속성의 값을 하나를 입력하면 (상 / 하 /)   각 속성의 값을 두개 입력하면 (상하 / 좌우)   각 속성의 값을 세개 입력하면 (상 / 좌우 / 하)   border: width style color; 형태로 단축속성을 작성한다   border-bottom처럼 bottom, top, left, right로 지정할 수 있다   ▶️ border-radius  테두리 경계를 둥글게 설정해준다  .box {     width: 150px;     height: 150px;     border-radius: 50%; }      모서리 끝에 원이 생겨서  border-radius의 값으로 넣은 값이 반지름이 되고 모서리의 모양이 원의 테두리처럼 반영   border-radius: 50%는 원을 생성한다   값은 % 또는 px로 지정해준다   네가지 값을 입력할 경우 왼쪽 상단부터 시계방향으로 설정이 된다   두개의 경우 대각선을 기준으로 (왼쪽상단, 오른쪽하단) / (오른쪽 상단, 왼쪽하단)으로 묶어 표현   최대값은 50%이다   ▶️ box-sizing  요소의 크기를 어떤 것을 기준으로 지정할지 명시한다   .box {     width: 100px;     height: 100px;     padding: 20px;     border: 10px solid block; }  box-sizing을 명시하지 않았기 때문에 기본값인 content-box   따라서 전체 크기는 100px(content)+40px(padding)+20px(border) = 160px   .box {     width: 100px;     height: 100px;     padding: 20px;     border: 10px solid block;     box-sizing: border-box; }  같은 경우에 box-sizing을 border-box로 지정해준 경우에는 border까지의 크기가 100px이 되므로 전체 크기는 100px      두가지 값이 있다   content-box: content를 기준으로 지정한 크기로 설정(기본값)   border-box: border를 기준으로 지정한 크기로 설정(padding, border가 포함됨)   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/CSS%EC%9A%94%EC%86%8C3/",
        "teaser": null
      },{
        "title": "Git, Github 2 - git flow",
        "excerpt":"상황별 되돌리기  git flow를 이용해서 어떤 작업을 하더라도 feature branch를 생성해서 하는 것을 권장한다 (main branch는 실제 서비스를 담당하는 부분이기 때문에 main branch에서 실수를 할 수도 있기 때문이다)   또한 develop branch에서 commit을 하지 않는 것을 권장한다 (feature branch를 생성해서 하는 것 권장!)   ▶️ 파일의 이름을 바꾸거나 이동시킬때  cmd나 터미널에서 mv [file-name] [path]를 이용해서 파일의 경로를 변경하거나 이름을 변경하는 경우 git에서는 파일이 이동하거나 이름이 변경된 것을 인식하지 못한다 → 기존의 파일이 삭제되고 새로운 파일이 생성됬다고 인식   따라서 git에게 파일을 이동하거나 이름을 변경한다고 전달해주어야 한다 이때 명령어 앞에 git을 붙여주면 된다   git mv [file-name] [path]  // ex git mv README.md readme2.md   이렇게 했을 경우 git status로 확인하면   Changes to be committed:   (use \"git restore --staged &lt;file&gt;...\" to unstage) \trenamed:    README.md -&gt; readme2.md  renamed라고 이름이 변경됨을 인식할 수 있었다   ▶️ 파일을 수정하고 최신의 commit으로 돌아가는 경우  여러 파일을 수정하다가 꼬여서 최근의 commit으로 돌아가야 하는 경우가 있다 이럴때는 다음과 같은 명령어를 사용한다  // 하나의 파일 git checkout -- [filename]  // 여러개 파일 git checkout -- .   최근 checkout이라는 명령어가 변경되어 restore로 사용가능하다 (현재 둘다 사용가능)   ▶️ 변경사항을 잘못 add 했을때  git reset HEAD [filename]   HEAD는 현재 가르키는 최신상태이고 이를 reset하는 명령어이다   ▶️ 가장 최신의 commit을 수정하는 방법  commit message를 입력하다가 잘못 입력한 경우 가장 최근의 commit을 수정하는 다음과 같은 명령어를 사용하면 된다  git commit --amend   vi 창이 열리면서 수정이 가능하다   ▶️ commit을 취소하는 방법  commit을 수정하기 위한 방법으로는 두가지로 볼수 있다      강제적으로 commit 취소     git reset —-hard HEAD~3 git push -f origin [branch]          –hard는 굉장히 위험한 flag로 권장하지 않는다       잘못된 commit을 두고 새로 수정하는 방법     git revert --no-commit HEAD~[개수]..          revert는 하나를 되돌릴 때마다 commit이 하나씩 작성되기 때문에 --no-commit은 이런 commit을 작성하지 않도록 한다       revert를 사용하면 잘못을 인정하고 되돌리는 commit을 다시 작성하는 형식이다   반면에 reset --hard를 이용한 commit의 취소는 강제적이다 그러나 내가 commit을 강제적으로 취소했더라도 다른 동료가 이전에 그 파일을 가지고 있었다면 좀비파일처럼 계속해서 다시 생기는 경우를 볼 수 있다   따라서 revert를 수행하는 것을 권장한다   revert를 수행할때 고민할 수 있는 부분이 있는데 만약 feature branch를 생성하고 작업을 하고 있었다면 잘못 되었을때 branch를 삭제하고 아에 새로하는 방법을 선택하지 아니면 revert를 수행해서 어느정도의 commit을 취소한뒤 재작업할지 고민할 수 있다 →       git flow  git flow를 이용해서는 다른 동료들과 협업을 진행할 수 있다 → issue, project   ▶️ Issue  프로젝트를 진행라면서 해야할 일들, log를 등록할 용도로 사용할 수 있다   - Label  해당 이슈가 어떤 카테고리에 속하는지 지정할 수 있다   - Milestone  보통 각 기능별 단위별 데드라인을 지정할 수 있다      이슈를 작성할 때 - [ ]를 이용해서 checkbox를 만들 수 있다   하나의 작업(checkbox 하나)를 완료하고 checkbox에 체크를 한다   이슈를 작성할 때 이유를 같이 명시하는 것이 좋다   팀장이 Assignees로 이슈의 담당원을 명시할 수 있다   ▶️ Project  project에서는 이슈를 개별로 backlog, todo, done의 구간으로 옮길 수 있다      모든 backlog를 done의 공간으로 옮겨야 한다   ▶️ team 단위의 협업  team 단위로 작업을 할 수 있는데 이때 방법이 두가지가 있다      cooaborator를 추가하는 방법(권장x)            팀장이 manage access를 팀원에게 할당한다 (권한을 줌)       원본에 바로 밀어넣는 형태이기 때문에 잘못하면 원본이 꼬일 수 있다           fullrequest  팀원은 사본을 가지고 작업하고 원본에 반영이 되도록 팀장에게 요청하는 방법   ▶ 팀장의 역할     새로운 repository를 생성   clone 진행   branch를 생성한다 (git flow init)   대상 파일 생성 (touch [file-name])   git add [file-name]   commit message와 함께 commit을 진행한다 (git commit)   git push -u origin develop (처음이라면 -u 플래그를 사용한다)   ▶️ 팀원의 역할     팀장이 생성한 repository 주소를 받는다   팀원이 스스로 Issue를 작성한다   FORK를 진행해서 사본을 만든다(개인의 repository)   FORK한 repository의 주소로 clone을 진행한다 (git clone [forked-repo])   git flow init: branch를 생성한다   Feature branch를 생성한다(git flow feature start [branch-name])   작업을 완료하고 git add [file-name], git commit을 진행한다   마지막 commit에서는 이슈가 마무리 되었음을 알리기 위해 resolve, close, fix과 넘버링된 이슈를 입력해준다(resolve [issue-numer])   git flow feature finish [branch-name]   git push origin develop (첫 push인 경우 -u를 추가한다)   fullrequest를 진행한다   수정사항이 있을시에 develop branch에서 add, commit, push를 진행하고 팀장이 확인한다   여러명이서 진행하다보면 파일 충돌의 위험이 있다 이럴때는 다음과 같은 과정을 진행한다   git remote add upstream [leader-repo] git fetc upstream develop git merge FETCH_HEAD  자신이 수정한 파일에 충돌이 된부분을 해결하고 ad,, commit, push한다   ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git,-github2/",
        "teaser": null
      },{
        "title": "CSS요소4 - 레이아웃",
        "excerpt":"layout   ▶️ display   1. 박스요소의 기본값을 변경 (block, inline, inline-block)  - block  .box {   display: block; }     세로방향으로 배치된다   block은 부모요소의 너비의 100%의 영역을 차지   height를 지정해줘야 보인다   - inline  .box {   display: inline; }     가로방향으로 배치   inline은 내용부분만큼만 영역을 차지한다   width나 height가 적용되지 않음   - inline-block  .box {   display: inline-block; }     inline과 동일하게 가로방향으로 배치된다   height, width가 적용된다   input, button..   - none, hidden  .box {   display: none; } .box1 {   visibility: hidden; }     display: none: 코드 상으로 존내하지만 보이지 않음 (랜더링할때 아에 무시된다)   visibility: hidden;: 레이아웃 상에 공간을 차지하지만 눈에 보이지 않는다   ▶️ float  요소를 배치할 수 있는 속성  .box {     float: left; }     none(기본값), left, right   자신의 부모 요소를 기준으로 배치된다   요소의 위에 배치된듯한 느낌을 준다   ▶️ normal flow  일반적인 흐름으로 레이아웃을 변경하지 않았을때이다     블록 요소와 인라인요소에 따라 배치된다   ▶️ position  어떠한 대상을 기준으로 요소를 배치한다 (기본값은 static)  .box {   position: relative; }     static(기본값), relative, absolute, fixed, sticky   static: top, bottom, left, right값을 줘도 영향이 없다(기본값)   relative: 일반적인 문서흐름에 배치하나, 자기 자신을 기준으로 top, bottom, left, right에 따라 요소를 배치한다   absolute: 요소는 일반적인 흐름에서 벗어나고, 자신의 부모요소(static이 아닌 요소)를 기준으로 top, bottom, left, right값만큼 떨어진 곳에 요소를 배치한다   fixed: 일반적인 문서흐름에서 벗어나고, 뷰포트(창)를 기준으로 top, bottom, left, right값만큼 떨어진 곳에 요소를 배치한다            화면에 고정된 것처럼 보인다       항상보이는 메뉴바, 최상단으로 올라갈 수 있는 버튼에 많이 사용된다           sticky: 일반적인 문서흐름에 따르나, 가장 가까운 스크롤 되는 부모요소를 기준으로 요소가 동작한다            어느 위치에 걸리는듯한 느낌을 준다       스크롤되는 요소의 자식이어야한다           top, bottom, left, right값은 음수값을 사용할 수도 있다   반대가 되는 (top, bottom), (left, rignt)를 동시에 사용하게 되면 top과 left가 우선된다   ▶️ overflow  단축속성으로 내용이 요소의 크기를 벗어났을때 어떻게 처리할지를 지정한다  .box {     overflow: visible; }     visible, hidden, scroll, auto   visible: 넘어서더라도 눈에 보인다(기본값)   hidden: 보이지 않게 한다   scroll: 스크롤이 되는 요소로 만든다   auto: 넘치면 스크롤 넘치지 않으면 그대로(visible)   x축과 y축을 설정할 수 있다(overflow-x, overflow-y)   ▶️ 스크롤바 바꾸기  브라우저 마다 기본적으로 제공하는 스크롤바의 모양이 다르지만, css(선택자)를 이용해서 스크롤바를 커스텀할 수 있다  &lt;!-- HTML --&gt; &lt;div class=\"container\"&gt;   &lt;div class=\"box\"&gt;1&lt;/div&gt;   &lt;div class=\"box\"&gt;2&lt;/div&gt;   &lt;div class=\"box\"&gt;3&lt;/div&gt;   &lt;div class=\"box\"&gt;4&lt;/div&gt;   &lt;div class=\"box\"&gt;5&lt;/div&gt;   &lt;div class=\"box\"&gt;6&lt;/div&gt;   &lt;div class=\"box\"&gt;7&lt;/div&gt; &lt;/div&gt;  &lt;!-- CSS --&gt; &lt;style&gt; .box {   border: 1px solid black;   width: 30%;   height: 400px;   overflow: auto;   font-size: 50px;   text-align: center; } .box .item {   height: 200px; } .box .item:nth-child(1){ background-color: skyblue; } .box .item:nth-child(2){ background-color: yellow; } .box .item:nth-child(3){ background-color: yellowgreen; } .box .item:nth-child(4){ background-color: coral; }  .box::-webkit-scrollbar{   /* 스크롤바의 너비 */   width: 30px; } .box::-webkit-scrollbar-thumb {    /* 스크롤 위치를 나타내는 바 */   background-color: white;    border: 1px solid #000;   border-radius: 10px; }  .box::-webkit-scrollbar-track {    /* 스크롤부분의 배경 */   background-color: lightcoral;  } &lt;/style&gt;  결과        ::-webkit-scrollbar-thumb: 스크롤바의 색상   ::-webkit-scrollbar-track: 스크롤바 이외 부분(트랙)의 색상   ▶️ z-index  z축(사용자에게 보여지는)의 순서를 지정한다(높을수록 위로 쌓인다)   .box {   z-index: 10; }      기본값은 auto이다   정수(음수, 0, 양수) 사용가능   요소가 겹쳐있는 경우 z-index가 높은것이 더 위로 올라온다   position: static인 요소는 뒤로 배치된다   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/",
        "teaser": null
      },{
        "title": "CSS요소8 - flex",
        "excerpt":"flex   ▶️ flex 용어                  용어       설명                       container       바깥쪽 부모영역                 flex item       내부의 요소들                 main axis       주축(초기값 기준 가로축)                 cross axis       교차축           ▶️ display  요소의 유형을 지정한다  .container {   display: flex; }     바깥쪽(block, inline, inline-block)과 안쪽(flex, grid)의 관계로 나눌 수 있다   CSS2부터 가운데에 -를 사용해서 바깥쪽의 관계와 안쪽과의 관계를 설정할 수 있다 (display: inline-block)   ▶️ flex-direction  container내에 item을 배치할때 주축 및 방향을 지정할 수 있다  .container {   display: flex;   flex-direction: column; }  * 기본값 * main의 방향: →  / cross의 방향: ↓      row: 주축의 방향을 → (기본값)   row-reverse: 주축의 방향을 ←   column: 주축의 방향을 ↓   column-reverse: 주축의 방향을 ↑   ▶️ flex-wrap  flex container내의 item들을 한줄로 배치할지 여러줄로 배치할지 지정한다  .container {   display: flex;   flex-wrap: wrap; }     nowrap: 부모요소를 벗어나더라도 한줄로 배치한다(기본값)   wrap: 여러행으로 배치한다   wrap-reverse: 여러행으로 배치하나(wrap), 순서가 반대로(시작점과 끝점)   ▶️ flex-flow  단축속성으로 flex-direction과 flex-wrap을 한번에 지정할 수 있다  .container {   display: flex;   flex-flow: row wrap; } /* .container {   display: flex;   flex-direction: row;   flex-wrap: wrap; } */     direction과 wrap 순서로 지정한다   ▶️ order  개별적으로 현재 요소의 배치 순서를 지정한다  .container {   display: flex; } .item-2 {   order: -1 } /* 기본값이 0이므로 다른 item보다 앞에 배치 */     개별적으로 item에 지정한다   기본값은 0   낮은 값일수록 앞으로, 높은 값이면 뒤로 배치   같은 경우 코드상의 순서대로 배치   화면에 보이는 순서에만 영향을 준다(코드상에는 원래 순서대로 되어 있다)   ▶️ flex-grow  남는 공간이 있을때 더 많은 영역을 차지할 수 있게 한다  .container {   display: flex; } .item {   flex-grow: 1; }     기본값은 0   각 item이 동일한 값을 가지면 남은 공간을 각 아이템이 남는 영역을 같은 비율로 나눠가진다   item별로 flex-grow값의 비율에 따라 남는 공간을 나눠가진다   음수값은 허용하지 않는다   소수점 사용가능하다   ▶️ flex-shrink  요소의 크기가 줄어들때 줄어드는 비율을 지정한다(item이 container가 더 클때)  .container {   display: flex; } .item {   flex-shrink: 1; }     기본값이 1이므로 display:flex를 했을때 container가 줄어들때 item의 크기가 작아진다   값이 0이면 줄어들지 않는다   음수값이 허용되지 않는다   줄어든 영역을 비율만큼 각각 item이 줄어든다   ▶️ flex-basis  flex내 item의 초기 크기를 지정한다  .container {   display: flex; } .item {   flex-basis: 100px; }      box-sizing을 지정하지 않으면 컨텐츠박스의 크기를 변경   auto: 자동으로 변한다(기본값)   content: item의 크기에 따라 자동으로 변한다(auto와 동일)   값을 입력해서 동일한 너비를 가지게 할 수 있다   0으로 값이 들어가면 grow값을 주게 되면 item이 모두 동일한 크기를 가진다   ▶️ flex  단축속성으로 item이 크기를 키우거나 줄어거나 할 때 비율을 지정할 수 있다  .container {   display: flex; } .item {   flex: 1 1 100px }   - 각 속성의 초기값                  속성       값                       flex-grow       0                 flex-shrink       1                 flex-basis       auto              flex-basis와 다르게 단축성성 flex를 이용할 때 기입하지 않으면 0이 값이 된다   키워드 initial: (0, 1, auto)로 초기값이 됨   키워드 auto: (1, 1, auto)로 flex-grow값은 1이됨   키워드 none: width와 height에 따라 정해지고 크기의 변화가 없다 (0, 0, auto)   - flex 값이 한개일 때     값이 1개일때 flex-grow 값을 뜻한다   단위를 입력하면 flex-basis 값을 뜻한다   - flex 값이 두개일 때     첫번째 값으로 flex-basis가 올 수 없다 따라서 무조건 숫자만 위치할 수 있다   첫번째 값은 무조건 flex-grow이다   - flex 값이 세개일 때     순서대로 flex-grow, flex-shrink, flex-basis가 지정된다   ▶️ justify-content  item을 주축(main)을 기준으로 어떻게 정렬할지를 지정한다  .container {   display: flex;   justify-content: center; }     flex-start: 주축이 시작하는 지점부터 정렬한다   flex-end: 주축이 끝나는 지점부터 정렬한다   center: 가운데 정렬   space-between: item별 간격을 자동으로 정렬한다   space-around: item 앞뒤로 동일한 여백을 추가하며 정렬한다   ▶️ align-items  전체 container 입장에서 item을 교차축(cross)을 기준으로 어떻게 정렬할지를 지정  .container {   display: flex;   align-items: start; }     stretch: item이 차지할 수 있는 가장 넓은 영역을 차지한다   center: 가운데 정렬   flex-start: 교차축의 시작점을 기준으로 정렬한다   flex-end: 교차축의 끝점을 기준으로 정렬한다      요소가 여러줄일때는 align-content를 사용한다     (flex-start, flex-end, center, space-between, space-around)   여러줄일때 align-items이 적용되면 라인 수만큼 가상의 container를 각각 만든 것처럼 동작한다    (flex-end일때 원래는 가장 아래로 정렬되야 한다면 층마다의 아래쪽에 배치가 된다)   ▶️ align-content  여러줄일때 교차축에 대한 정렬을 지정한다  .container {   display: flex;   align-content: center; }     flex-start: 교차축이 시작하는 지점부터 정렬한다   flex-end: 교차축이 끝나는 지점부터 정렬한다   center: 가운데 정렬   space-between: item별 간격을 자동으로 정렬한다   space-around: item 앞뒤로 동일한 여백을 추가해서 정렬한다   ▶️ align-self  flex 정렬시, item별로 align(교차축정렬)을 지정할 수 있다  .container {   display: flex;   align-content: center; } .item-1 {   align-self: flex-end; } /* item-1 만 아래로 배치된다 */     stretch: 차지할 수 있는 가장 큰 영역을 차지한다   center: 중앙에 위치한다   flex-start: 주축의 시작점에 위치한다   flex-end: 주축의 끝점에 위치한다   하나의 아이템만 다른값으로 별도지정하고 싶을때 사용한다   각 아이템에 지정한다   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/flex/",
        "teaser": null
      },{
        "title": "CSS요소6 - transform",
        "excerpt":"transform  회전, 크기 조절, 기울이기, 이동효과 등을 부여할 수 있다      직교좌표를 사용한다 (0,0)이 왼쪽 상단   원본의 자리를 유지한다   값으로 함수를 사용 (matrix, translate, scale, rotate, skew)   여러개의 함수를 함께 사용하면 오른쪽부터 적용한다   (0,0) (왼쪽 위) - x축은 오른쪽으로 진행, y축은 이래쪽으로 진행   ▶️ scale  scale()은 2d를 기준으로 크기를 변경  .box {   transform: scale(sx);   transform: scale(sx, sy); }     값으로 한개 또는 두개(sx), (sx, sy)   값을 입력하면 곱해져서 적용된다   width: 100px에 scale(1.5) → width: 200px   scaleX(), scaleY(), scaleZ()   3차원적으로 적용하기 위해서는 scale3d(x, y, z)를 사용한다   ▶️ rotate  요소를 회전시키는 회전하는 함수  .box {   transform: rotate(value); }     값을 하나만 받는다   deg(일반적으로 사용하는 각도)-  transform: rotate(360deg) (한바퀴)   grad(1회전이 400) - transform: rotate(400grad) (한바퀴)   rad(π*rad = 180도) - transform: rotate(6.2832rad) (한바퀴)   turn(1은 한바퀴) - transform: rotate(1turn) (한바퀴)   양수는 오른쪽으로 회전, 음수는 왼쪽으로 회전   rotateX(), rotateY(), rotateZ()   각 축을 기준으로 회전한다   rotate3d(x, y, z, a) -&gt; 각 값은 0과 1 사이값 / a는 각도를 나타낸다   ▶️ translate  요소를 이동하게함  .box {     transform: translate(x, y);     transform: translateX(x);     transform: translateY(y); }     값으로 한개(x, 0) 또는 두개(x, y)   값으로 px이나 %을 사용한다   %를 사용할 경우 요소를 기준으로 이동한다   translateX(x축만 이동), translateY(y축만 이동), translateZ(z축만 이동)   3차원적으로 이동하기 위해서는 translate3d(tx, ty, tz) → 각 값에 px단위로 지정   ▶️ skew  기울이는 함수  .box {   transform: skew(ax);   transform: skew(ax, ay); }     값을 하나만 사용할 경우 x축만 적용된다   값으로 각도(deg)를 입력   90도를 기울이면 보여지지 않음   z축이 없다   ▶️ transform-origin  (별도의 프로퍼티) 기준점을 변경한다  .box {   transform-origin: center; }     기본값은 center (50% 50% 0)   top, buttom, left, right 사용가능   px, % 사용가능   ▶️ perspective  (별도의 프로퍼티)요소에 원근감을 준다  .parent {   perspective: 500px; }     부모요소에 적용한다   개별적인 투영점을 설정할때는 각 값에 transform: perspective(px)을 준다   개별적으로 줄때 맨 앞에 위치한다 (오른쪽에서부터 계산해서 그런것 같다)   transform-style: preserve-3d는 부모의 perspective를 자식까지도 전달해준다   IE는 지원하지 않는다   ▶️ perspective-origin  어느 방향에서 보는지를 지정  .box {   perspective-origin: 50% 50%; }     부모요소에 적용한다   키워드를 조합해서 사용가능 (top, buttom, left, right)   %로도 입력가능   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/transform/",
        "teaser": null
      },{
        "title": "CSS요소7 - transition, animation",
        "excerpt":"✏️ transition  변환이 되는 요소의 과정을 단축속성으로 지정한다  .box {   transition: all 1s ease 2s; }     property, duration, timing-function, delay   시간 값(s)이 한개만 있으면 무조건 duration으로 동작   시간 값(s)이 두개이면 duration, delay 순서로 위치   ▶️ transition 속성의 기본값                  프로퍼티       값                       transition-delay       0s                 transition-duration       0s                 transition-property       all                 transition-timing-function       ease           ▶️ transition-property  변환되는 css의 특정 요소를 지정한다  .box {   transition-property: none;   transition-property: all;   transition-property: element (margin,color...); }     모든 요소를 지정하려면 all을 사용하면 된다   property를 여러개 지정하는 경우 ,로 구분한다   ::before, ::after에도 적용이 가능하다   ▶️ transition-duration  변환하는데 걸리는 시간을 얼마로 할지 지정한다  .box {   transition-duration: 1s; }     ms단위로도 지정할 수 있다(1000ms = 1s)   property를 여러개 따로 지정해줬을 경우에는 duration을 각각 ,로 구분해서 명시한다   ▶️ transition-delay  변환하는 시점을 일정 시간동안 지연시킨다  .box {   transition-delay: 1s; }     delay를 이용하면 여러개의 요소가 있을때 순차적으로 움직을 수 있다   ▶️ transition-timing-function  시간의 흐름에 따라 어떤 방식으로 변환이 되는지를 지정한다  .box {   transition-timing-function:  }   → timing function value                  function       설명                       ease       느리게 시작해 빨라지다가 다시 느리게                 ease-in       느리게 시작하고 빨라짐                 ease-out       빠른 속도로 시작해 느려짐                 ease-in-out       ease와 동일(ease는 시작속도가 조금 더 빠름)                 linear       처음부터 끝까지 일정(선형)                 cubic-bezier       (x, y, x’, y’) 네개의 포인트로 function의 그래프를 그린다              cubic-bezier를 이용해서 커스텀하고 코드를 제공해주는 사이트 https://matthewlein.com/tools/ceaser           ✏️ animation  단축속성으로 전환시키는 과정을 지정할 수 있다      특정 액션을 하지 않아도 동작하게 할 수 있다   keyframe을 사용해서 세부적으로 애니메이션 과정을 지정해 줄 수 있다   /* 단축속성사용 */ .box {   animation: 3s ease 1s infinitie reverse forwards running test; }     duration, function, delay, count, direction, mode, state, name   시간값이 두개 지정되면 앞의 값은 duration, 뒤의 값은 delay가 지정된다   ▶️ animation 속성의 기본값                  프로퍼티       값                       animation-name       none                 animation-duration       0s                 animation-timing-function       ease                 animation-delay       0s                 animation-iteration-count       1                 animation-direction       normal                 animation-property       all                 animation-fill-mode       none                 animation-play-state       running           ▶️ @ketframes  여러가지의 애니메이션을 지정해놓을 수 있다 이후 animation을 이용해서 사용한다   keyframe을 세부적으로 지정하는 방법에는 두가지가 있다     from, to: 처음과 끝을 지정한다   %: %별로 구간을 나눠서 지정이 가능하다   두 방법 모두 {}로 구간을 분리해서 css를 개별 적용한다  /* from - to 이용 */ @keyframes 이름 {   from{     내용   }   to {     내용   } }  /* % 이용 */ @keyframes 이름 {   0% { 내용 }   25% { 내용 }   50% { 내용 }   75% { 내용 }   100% { 내용 } }      animation에 이름을 입력하고 다른 속성을 입력해서 사용 (alternate 속성을 주면 다시 되돌아옴)   keyframes의 이름은 animation-name의 값이 된다   keyframes 네이밍 규칙            대소문자를 구분한다       특수문자는 -,_만 사용가능       글로벌 값으로 지정해서는 안된다(initial, inherit, revert, unset…)               ▶️ animation-name  미리 작성한 keyframe중 어떤 keyframe을 사용할지 명시한다  .box {   animation-name: keyframes-name;  }     기본값은 none   ▶️ animation-duration  애니메이션이 동작하는 시간을 명시한다(한 사이클을 완료하는데 걸리는 시간)  .box {   animation-duration: 1s   /* 1초동안 애니메이션의 한 사이클이 1초 */ }     ms, s단위를 사용한다   음수 사용 불가   ▶️ animation-delay  애니메이션을 시작하기 전에 지연시킬 시간을 지정  .box {   animation-delay: 3s   /* 3초 이후에 애니메이션이 동작한다 */ }     ms, s단위 사용   음수값을 사용할 경우 곧바로 재생이 되는 대신 음수값만큼의 도중에서 시작된다   ▶️ animation-timing-function  동작하는 방식을 지정(시간에 흐름에 따른 변화 속도)  .box {   animation-timing-function: linear;   /* 일정한 속도로 애니메이션을 진행 */ }     transition의 timing-function과 동일하다   ease, ease-in, ease-out, ease-in-out, linear, cubic-bezier   ease: 중간까지 속도 증가, 이후 느려짐 / cubic-bezier(0.25, 0.1, 0.25, 1.0)과 동일   ease-in: 천천히 증가하면서 시작됨 / cubic-bezier(0.42, 0, 1.0, 1.0)과 동일   ease-out: 빠르게 시작해 속도가 줄어든다 / cubic-bezier(0, 0, 0.58, 1.0)과 동일   ease-in-out:천천히 증가하면서 시작했다가 속도가 즐어든다 /  cubic-bezier(0, 0, 0.58, 1.0)과 동일   linear: 동일한 속도 유지 / cubic-bezier(0.0, 0.0, 1.0, 1.0)과 동일   cubic-bezier: 값(x, y, x’, y’)을 지정하는대로 속도의 증가 및 변환이 이루어진다   ▶️ animation-iteration-count  반복하는 횟수를 지정한다  .box {   animation-iteration-count: infinite; }     값으로 숫자가 들어가거나 infinite(무한반복)이 들어갈 수 있음   0.5도 가능 (50% 재생)   ▶️ animation-direction  애니메이션을 반대로 재생할 수 있음  .box {   animation-direction: reverse; }     normal: 원래대로 진행(기본값)   reverse: 반대로 진행   alternate: 정방향, 역방향으로 반복해서 진행   alternate-reverse: 역방향, 정방향 반복해서 진행   ▶️ animation-play-state  재생 유무를 설정한다(일시정지)  .box {   animation-play-state: running;   } .box:hover {   animation-play-state: paused; } /* 기존에 애니메이션이 동작하다가 마우스를 올리면 중지됨 */     running: 재생되고 있는 상태(기본값)   paused: 일시정지   ▶️ animation-fill-mode  애니메이션이 실행하기 전과 후의 css를 적용하는지의 경우를 지정한다  .box {   color: skyblue;   animation-fill-mode: forwards;   animation: colorChange 1s;   /* colorChange를 1초 사이클로 동작한다 */ } @keyframes colorChange {   from {     color: yellow;   }   to {     color: red;   } } /* 애니메이션이 끝났음에도 color는 red이다 */ /* fill-mode가 backwards라면 시작할때부터 yellow의 color값을 가진다 */     none: 재생될때만 keyframes에 있는 스타일 적용(기본값)   forwards: 끝난 모습의 스타일을 유지   backwards: 지연시간동안에도 스타일을 적용   both: forwards, backwards 둘 다 적용   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/transition/",
        "teaser": null
      },{
        "title": "CSS요소5 - 색상과 배경",
        "excerpt":"색상 표현   1. HEX(16진수)  #으로 시작해서 여섯개의 문자가 붙는 16진수의 색상표현     6자리가 동일한 문자이면 3자리로 축약해서 사용가능   #000000 → #000 (검은색)   #ffffff → #fff (흰색)   2. rgb  red, green, blue의 정도를 0~255사이의 숫자로 나타낸다     rgb(red, green, blue);   rgb(0, 0, 0) (검은색)   rgb(255, 255, 255) (흰색)   3. rgba  rgb와 동일하지만 투명도를 명시할 수 있다     rgba(red, green, blue, alpha);       색상과 배경   ▶️ color  글자의 색상을 지정한다  p {   color: skyblue; }     키워드: blue, red, green 등등 (transparent는 투명)   ▶️ opacity  투명도를 지정할 수 있다  .box {   background-color: #000;   opacity: 0.5; }      0부터 1까지의 값을 입력할 수 있다.   소수점 앞의 0을 생략할 수 있다 (0.5 -&gt; .5)   0은 완전히 투명하기 때문에 보이지 않는다   1은 투명도가 아에 없으므로 불투명(기본)   내부의 모든 요소에 영향을 준다   ▶️ background-color  배경색상을 지정한다  .box {   background-color: #000; }   ▶️ background-image  배경으로 이미지를 지정할 수 있다.  .box{     background-image: url(\"file-path\"); }      기본값은 none   만약 background-color와 같이 사용이 되면 background-image가 위로 올라온다   background: url(\"file-path\") 단축속성을 이용해서 이렇게 표현도 가능   ▶️ background-repeat  .box{     background-image: url(\"file-path\");     background-repeat:  }     기본값은 repeat   repeat: 요소의 크기를 채울만큼 반복한다   repeat-x: 가로방향으로 채운다   repeat-y: 세로방향으로 채운다   no-repeat: 반복하지 않고 한번만 나온다   ▶️ background-position  background-image의 위치를 지정할 수 있다  .box {     background-image: url(\"file-path\");     background-position: x, y;     /* background-position: 100px, 200px; */ }     x축과 y축을 설정할 수 있다   기본적으로 왼쪽 상단을 기준으로 한다(얼마나 떨어져있는지 명시)   키워드: top, bottom, left, right, center   이미지스프라이트를 이용해서 사진을 보여줄때 많이 사용된다   ▶️ background-origin  원점(기준)을 지정할 수 있다.  .box {     background-image: url(\"file-path\");     background-origin: border-box; }     border-box: 배경을 테두리박스에 상대적으로 배치   padding-box: 배경을 안쪽 여백에 상대적으로 배치(기본값)   content-box: 배경을 컨텐츠 박스에 상대적으로 배치   ▶️ background-size  배경의 크기를 지정할 수 있다.  .box {     background-image: url(\"file-path\");     background-size: cover; }     기본값은 auto으로 원본값의 크기를 가진다   contain: 더 짧은 가로 또는 세로에 맞춰 꽉채움(비율 유지)   cover: 더 긴 가로 또는 세로에 맞춰 꽉 채움(비율 유지)   값을 지정할 수 있음 ex) background-size: 100px 100px; (비율 유지x)   %를 입력할 수 있음 ex) background-size: 100%; = 가로에 맞춤   비율을 유지하고 요소내 여백을 남기려면 100%, 비율을 유지하고 여백을 남기지 않으려면 cover를 사용한다   ▶️ backgroud  단축속성으로 배경에 관련된 여러가지를 설정할 수 있다  .box {     background: url(\"파일경로\") no-repeat center/100px blue; }      몇개만 선택해서 작성할 수 있다   공백(스페이스)로 구분한다   color는 마지막에만 올 수 있다   size는 position 뒤에만 올 수 있고 /로 구분한다 (position/size)       background의 8개 하위 속성     background-attachment: 배경이미지를 고정(스크롤 여부)(기본값: scroll)            scroll: 페이지와 함께 스크롤(아에 고정)       fixed: 페이지와 함께 스크롤되지 않음(부모요소를 스크롤할때 보여지는 배경이 다름)       local: 요소 내용과 함께 스크롤(내부요소 스크롤시 같이 스크롤됨)           background-clip: 어느 영역까지 차지할지를 지정(기본값: border-box)            border-box: 테두리 영역까지       padding-box: 요소 내부 여백까지       content-box: 컨텐츠박스까지       text: 텍스트 위에만           background-color: 배경의 색상을 지정(기본값: transparent)   background-image: 배경을 이미지로 지정(기본값: none)   background-origin: 원점을 지정(기본값: padding-box)   background-position: 배경의 위치를 지정(기본값: 0% 0%)   background-repeat: 배경의 반복을 지정(기본값: repeat)   background-size: 배경의 크기를 지정(기본값: auto auto)  ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/%EC%83%89%EC%83%9D%EA%B3%BC%EB%B0%B0%EA%B2%BD/",
        "teaser": null
      },{
        "title": "CSS요소9 - grid",
        "excerpt":"grid  이차원 레이아웃 시스템으로 원하는 위치에 요소를 배치할 수 있고 공간을 더 많이 차지하도록 하는 등의 레이아웃을 구성할 수 있다      flex는 여러개의 아이템이 있을때 주축을 기준으로 배치된다 반면에 grid는 주축과 교차축 전부에 요소를 배치하도록 한다   column: 열   row: 행   gutter: 행 사이 간격(gap)   열병합, 행병합이 가능하다   이전에는 table을 가지고 레이아웃을 구성했으나 현제는 flex, grid를 사용한다   display를 이용해서 지정한다   display를 이용해서 요소의 바깥쪽 레이아웃과 내부 레이아웃을 지정할 수 있다 (-를 가운데에)     .container { display: grid;               container에 사용되는 속성과 item에 사용되는 속성을 명시해서 정리하겠습니다   ▶️ grid-template-rows, grid-template-columns  [container 속성]   가로(행) 세로(열)을 가지는지를 명시할 수 있다   .container {   display: grid;   grid-template-columns: 100px 100px 50px;   grid-template-rows: 100px 100px;   /* grid-template-columns: 1fr 1fr 1fr;   grid-template-rows: 1fr 1fr; */ }     공백으로 구분한다   각각 어떤 너비를 가지는지 설정가능하다   명시되지 않은 부분은 자신의 컨텐츠 크기를 가진다   fr단위: 비율을 설정한다   repeat: 반복횟수를 지정할 수 있다 (함수표기법 - repeat(반복횟수, 크기))   ▶️ grid-template-areas  [container 속성]   item이 container 내부 공간을 어느정도 차지할지를 명시적으로 지정할 수 있다      HTML에서 item에 class를 미리 지정한다   각 class의 css에서 grid-area: name;을 이용해서 이름을 지정한다   grid-template-areas에서 지정된 이름으로 배치한다   .container {   display: grid;   grid-template-columns: 1fr 1fr 1fr;   grid-template-rows: 1fr 1fr;   grid-template-area:      \"a a a\"     \"b . c\"; }     네모 형태의 공간을 차지하도록 한다   .은 빈칸을 나타낸다   ▶️ row-gap, column-gap  [container 속성]   열과 행 사이의 간격(gutter)을 지정할 수 있다   .container {   display: grid;   grid-template-rows: repeat(4, 1fr);   grid-template-columns: repeat(3, 1fr);    row-gap: 20px;   column-gap: 30px;   /* 20px씩 간격이 존재 */      /* 단축속성을 사용할 수 있다 */   gap: 20px 30px; }      기본값은 0   최근 변경된 사항으로 접두사를 붙히지 않아도 동작한다 → 앞에 grid라는 접두사를 붙히면 예전 브라우저에서도 동작할 수 있다 (grid-row-gap)   gap이라는 단축속성을 이용해서 row-gap, column-gap을 한번에 지정할 수 있다   순서가 중요하다 (앞에 위치한 값은 row-gap, 뒤에 위치한 값은 column-gap)   ▶️ grid-auto-rows, grid-auto-columns  [conatiner 속성]   grid-template-rows, columns(명시적)로 지정한 공간을 넘어갔을때 grid-auto-rows, coumns(암시적)을 사용해서 미리 지정해둘 수 있다   .container {   display: grid;   grid-template-rows: repeat(2, 1fr);   grid-template-columns: repeat(3, 1fr);    grid-auto-rows: 100px;    grid-auto-columns: 100px;  }     기본값은 auto   ▶️ grid-auto-flow  [container 속성]   item들이 어떠한 형태로 흘러갈지를 지정한다 (공간을 채울 방향을 결정한다)   .container {   display: grid;   grid-template-rows: repeat(2, 1fr);   grid-template-columns: repeat(3, 1fr);    grid-auto-flow: column dense; }     row: 행방향을 기준으로 배치된다(기본값)   columns: 열방향을 기준으로 배치한다   dense: row, columns뒤에 공백과 함께 붙여준다 - 빈 영역을 차례대로 채워주며 배치된다   ▶️ grid  [container 속성] [단축속성]   6가지 속성 (grid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, grid-auto-flow)을 한번에 작성할 수 있다      명시적인 속성: grid-template-rows, grid-template-columns, grid-template-areas   암시적인 속성: grid-auto-rows, grid-auto-columns, grid-auto-flow   .conatiner {   display: grid;    grid: repeat(2, 1fr) / repeat(3, 1fr);   /* 행은 1fr 1fr  / 열은 1fr 1fr 1fr */    grid : auto-flow dense 1fr 1fr / repeat(3, 1fr);   /* 행은 1fr 1fr  / 열은 1fr 1fr 1fr , grid-auto-flow: row dense */  }     슬래시(/)를 사용해서 두개로 나누는데 슬래시 앞부분은 행(row), 뒷부분은 열(column) 부분이다   (명시적 / 명시적), (명시적 / 암시적), (암시적 / 명시적) 으로 사용될 수 있다   grid-template-rows, columns를 지정해주기 위해서 각각 슬래시를 기준으로 지정한다   grid-auto-flow를 지정해주기 위해서는 행부분 또는 열부분에 auto-flow라고 지정한다   grid-auto-rows, columns를 지정해주기 위해서는 (명/명) (명/암) (암/명)으로 작성되기 때문에 auto-flow가 사용된 부분에서 grid-auto-rows, columns의 값을 넣어주면 된다   ▶️ justify-content  [container 속성]   item의 크기보다 container의 크기가 커서 남는 공간이 존재할 때 container를 배치한다(주축)   .container {   display: grid;   grid-template-rows: 1fr 1fr;   grid-template-columns: 1fr 1fr;   justify-content: center; }      주축(→)을 기준으로 container의 위치를 결정한다   start: 시작점에 배치   end: 끝점에 배치   center: 가운데 배치   space-between: item 사이의 공백을 동일하게   space-around: 각 item에 앞뒤 여백을 동일하게   ▶️ align-content  [container 속성]   item의 크기보다 container의 크기가 커서 남는 공간이 존재할 때 container를 배치한다(교차축)     .container {     display: grid;     grid-template-rows: 1fr 1fr;     grid-template-columns: 1fr 1fr;     align-content: center;   }      교차축(↓)을 기준으로 container의 위치를 결정한다   ▶️ justify-item  [container 속성]   grid로 지정된 크기(1fr, 100px …)안에서 item의 크기가 작은 경우 지정된 크기 내에서의 정렬(주축)   .container {   display: grid;   grid-template-rows: 1fr 1fr;   grid-template-columns: 1fr 1fr;   justify-items: center; } .item {   width: 50%;   height: 50%; }     stretch: 넓어질 수 있을 만큼 커짐(기본값)   start: 시작점에 배치   end: 끝점에 배치   center: 중앙에 배치   각각의 item에 따로 적용하고 싶은 경우, 각각의 item에 justify-self를 사용한다   ▶️ align-item  [container 속성]   grid로 지정된 크기(1fr, 100px …)안에서 item의 크기가 작은 경우 지정된 크기 내에서의 정렬(교차축)   .container {   display: grid;   grid-template-rows: 1fr 1fr;   grid-template-columns: 1fr 1fr;   align-items: center; } .item {   width: 50%;   height: 50%; }     stretch: 넓어질 수 있을 만큼 커짐(기본값)   start: 시작점에 배치   end: 끝점에 배치   center: 중앙에 배치   각각의 item에 따로 적용하고 싶은 경우, 각각의 item에 align-self를 사용한다   ▶️ grid-row, grid-column  [item 속성] [단축속성]   grid로 인해서 생긴 격자번호에 따라 지정된 칸의 영역을 차지할 수 있도록 한다      .container {   display: grid;   grid-template-rows: repeat(2, 1fr);   grid-template-columns: repeat(2, 1fr); } .item {   grid-row-start: 0;   grid-row-end: 2;    /* 위와 동일하다 */   grid-row: 0 / 2; }      grid-row, grid-column을 사용할때 시작점을 슬래시(/)앞에 입력하고 뒤에 span 과 숫자를 입력하면 시작점에서 숫자칸만큼을 차지할 수 있다   grid-row: 1 / span 2;   ▶️ grid-area  [item 속성] [단축속성]   grid-row-start, grid-column-start, grid-row-end, grid-column-end 네가지 속성을 설정할 수 있는 단축속성이며, grid-template-areas의 name을 지정할 때 사용한다   .container {   display: grid;   grid-template-rows: repeat(3, 1fr);   grid-template-columns: repeat(3, 1fr); } .item {   /* grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end; */   grid-area: 4 / 2 / span2 / -1; }      순서를 지켜줘야 한다 (grid-row-start, grid-column-start, grid-row-end, grid-column-end)   두가지 형태로 사용된다 (name을 지정, 단축속성)   ▶️ order  [item 속성]   item 별로 위치를 별도로 지정할 수 있다   .container {   display: grid;   grid-template-rows: repeat(3, 1fr);   grid-template-columns: repeat(3, 1fr); } .item {   order: 2; }     기본값은 0   특정 item을 맨 앞부분으로 위치하기 위해서는 다른 item의 order값이 0이기때문에 -1을 사용하면 맨 앞으로 위치한다   order가 같은 값이 주어지면 코드순서상으로 배치된다   ▶️ z-index  [item 속성]   grid row, column으로 겹쳐졌을때, 쌓여진 순서르 제어할 수 있다   .container {   display: grid;   grid-template-rows: repeat(3, 1fr);   grid-template-columns: repeat(3, 1fr); }   ▶️ grid 단위   1. fr (fraction)     비율을 사용해서 나눌때 사용한다   container 내의 모든 부분을 기준으로 한다   2. min-content  .container {   grid-template-columns: min-content 1fr; }     단위처럼 사용가능하다   내부 내용을 기준으로 차지할 수 있는 가장 작은 영역을 차지한다   영문으로 구성된 내용을 가질때 가장 큰 단어의 너비만큼 (단어는 잘라서 볼 수 없음)   3. max-content  .container {   grid-template-columns: max-content 1fr; }     단위처럼 사용가능하다   내부 내용을 기준으로 차지할 수 있는 가장 큰 영역을 차지한다   4. auto-fill  .container {   grid-template-columns: repeat(auto-fill, 100px);    /* minmax와 함께 사용되면 여백을 생기게 하지 않도록 할 수 있다 */   grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) }     repeat과 함께 쓰인다   minmax를 이용해서 여백을 생기게 하지 않도록 할 수 있다   100px이 들어갈 수 있으면 넣고 그게 아니면 전체적으로 1fr의 크기(전체를 나눠가짐)를 가지므로 여백이 생기지 않는다   5. auto-fit  .container {   grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) }     item이 부족해서 여백이 생길 수 밖에 없는 상황에서 사용한다   auto-fill의 경우 지정된 크기가 들어올 수 있는값이 된 경우 item을 배치하는데 이때 item이 없으면 여백이 된다 하지만 auto-fit을 이용하면 여백을 채우게 된다   ","categories": ["CSS"],
        "tags": ["CSS"],
        "url": "/css/grid/",
        "teaser": null
      },{
        "title": "[Algorithm] String, Hash",
        "excerpt":"▶️ String  문자열을 다루는 알고리즘을 풀면서 알게된 방법   1. 앞 뒤 문자열의 비교      문자열이 주어지고 각 알파벳이 몇개가 이어지는지 모든 개수를 출력해보는 문제(1개도 출력)    str = \"aaazbbbccc\";  // 공백을 추가해주는 이유는 마지막에 종료하기 위해서 str = str + \"\"  // 몇개나 중복되는지 체크하기 위해서(기본적으로 한개는 존재하므로 1) cnt = 1; for (let i = 0; i &lt; str.length; i++){   if(str[i] === str[i+1]){     cnt++;   }else {     console.log(`${str[i]}은 ${cnt}개 있습니다`)     cnt = 1;   } }   index를 이용해서 현재 index와 그 다음번의 index를 비교해본다   마지막 index에서는 다음번에 비교할 문자가 없기때문에 미리 공백을 추가해준다(str = str + \" \")   2. 문자열을 앞 뒤로 비교해주는 방법   index를 이용해서 제일 처음 인덱스 left, 맨 마지막을 가르키는 right를 지정한다  left = 0; right = str.length-1; // index를 이용하기 때문에 -1을 해준다  이후 문자열을 확인하면서 +1, -1을 해주면서 다시 확인한다     left는 +1(→ 방향)   right는 -1(← 방향)   * 문제타입  - 문자열에서 문자뒤집기  - 회문문자열   3. 문자열에서의 브루트포스  브루트포스(brute force)란, 완전탐색 알고리즘이다   가능한 모든 경우의 수를 확인하면서 요구에 충족되는 조건을 리턴할 수 있다 (100% 정답만을 리턴)      같은 문자열이 존재하는가를 확인하는 문제    strArr = [\"abc\", \"abcd\", \"efg\", \"abc\"]; const n = strArr.length;  const check = (strArr, n) =&gt; {   // 반복문의 중첩을 통해 모든 경우의 수를 확인한다 (문자열 4개 기준 - 6가지)   for (let i = 0; i &lt; n; i++){        // n은 문자열을 담고있는 배열의 길이     for (let j = i+1; j &lt; n; j++ ){     // n은 문자열을 담고있는 배열의 길이       if(staArr[i] === strArr[j]){             return false;   // 같은 문자열이 있을때 false를 리턴       }     }   }   return true;    // 반복문동안 false 리턴이 수행되지 않은 경우 중복되는 문자열이 없었다고 판단 (true 리턴) }   반복문의 중첩을 사용해서 모든 경우를 확인한다   두번째 for문에서 j가 i+1에서부터 시작하는 이유는 이전의 문자열과의 비교는 이전에 수행되었기 때문이다s                  i       j       str                       0       1       abc, abcd                 0       2       abc, efg                 0       3       abc, abc                 1       2       abcd, efg                 1       3       abcd, abc                 2       3       efg, abc               Hash  해시테이블과 반복문 등을 사용해서 값의 누적, 중복의 여부 등을 확인할 수 있다   해시 테이블(Hash Table)  자료구조의 종류 중 하나로 key와 value를 가지는 자료구조 형태이다      Hash Function을 이용해서 빠른 접근이 가능하다 (시간복잡도: O(n))   Map의 사용     const hashTable = new Map();           1. Map.set()  값을 설정하는 해시테이블(Map)의 함수  const hashTable = new Map();  hashTable.set(\"key\", \"value\");  console.log(hashTable);  // 결과 Map { 'key' =&gt; 'value' }  set()에 두개의 인자를 넣는다      첫번째 인자: key   두번째 인자: value   인자를 하나만 넣을 경우 인자는 key값이 되고 value는 undefined   2. Map.get()  선언한 Map에서 값을 가져오는 해시테이블의(Map)의 함수  const hashTable = new Map();  hashTable.set(\"서울\", \"서울특별시\"); hashTable.set(\"수원\", \"그냥 수원시\");  console.log(hashTable.get(\"서울\")); console.log(hashTable.get(\"수원\"));  // 결과 서울특별시 그냥 수원시  get()의 인자로 한개를 넣어주게 되는데 이때 key값이 들어가게 된다   3. Map.has()  선언한 Map에 key가 존재하는지를 확인하는 함수   const hashTable = new Map();  hashTable.set(\"서울\", \"서울특별시\"); hashTable.set(\"수원\", \"그냥 수원시\");  console.log(hashTable.has(\"서울\")); console.log(hashTable.has(\"제주도\"));  // 결과 true false   4. Map.delete()  선언된 Map에서 key로 key와 value를 삭제하는 함수  const hashTable = new Map();  hashTable.set(\"서울\", \"서울특별시\"); hashTable.set(\"수원\", \"그냥 수원시\");  hashTable.delete(\"수원\");  console.log(hashTable);  // 결과 Map { '서울' =&gt; '서울특별시'}     true, false를 리턴한다   5. Map.size()  Map의 크기를 리턴하는 함수  const hashTable = new Map();  hashTable.set(\"서울\", \"서울특별시\"); hashTable.set(\"수원\", \"그냥 수원시\");  console.log(hashTable.size);  // 결과 2     빈 Map의 size를 출력하면 0       JS 메소드   1. split()  문자열(string)을 지정한 구분자로 구분한다  문자열.split(\"구분자\");      MDN Link    // 예시 const str = \"a, b, c, d, e\"; arr = str.split(\", \");  console.log(arr);  // 결과 [ 'a', 'b', 'c', 'd', 'e' ]   2. join()  배열의 모든 요소를 나열해 하나의 문자열(string)로 만든다  배열.join(\"각 항목 사이에 지정할 문자열\")      MDN Link    // 예시 const arr =  [ \"a\", \"b\", \"c\", \"d\", \"e\" ];  str = arr.join(\"\"); console.log(str);  // 결과 abcde   3. substring()  문자열(string)의 인덱스를 사용해서 시작인덱스부터 끝인덱스까지의 부분문자열을 반환한다   문자열.substring(시작인덱스, 끝인덱스)      MDN Link    const str = \"abcdefg\"; const subStr = str.substring(1, 4);  console.log(subStr);  // 결과 bcd     만약 끝인덱스를 입력하지 않은경우 끝까지 진행한다   4. sort()  배열을 정렬해준다  배열.sort();      MDN Link    const arr = [1, 3, 2, 4]; const arr2 = [\"a\", \"c\", \"d\", \"b\"];  arr.sort((a, b) =&gt; a-b); arr2.sort();  console.log(arr); console.log(arr2);  // 결과 [ 1, 2, 3, 4 ] [ 'a', 'b', 'c', 'd' ]      복사본을 생성하지 않고 원본이 변경된다   기본적으로 문자열의 유니코드 코드에 따라 정렬한다 (숫자의 오름차순 정렬시 1, 2, 11가 있다면 1, 11, 2로 정렬됨)   오름차순의 경우(arr.sort((a,b) =&gt; a-b))   내림차순의 경우(arr.sort((a,b) =&gt; b-a))   5. reverse()  배열의 순서를 반대로 반전시켜준다   배열.reverse();      MDN Link    const arr = [1, 2, 3, 4]; arr.reverse();  console.log(arr);  // 결과 [ 4, 3, 2, 1 ]   6. isNaN()  인자가 숫자인지 아닌지 false, true값을 반환한다  console.log(isNaN(1));  // 결과 false      숫자이면 false반환   숫자가 아니면 true 반환  ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/string,hash/",
        "teaser": null
      },{
        "title": "[Algorithm] array",
        "excerpt":"▶️ Arrar (1차원배열)  배열을 사용해서 문제를 구현한다      지정된 길이를 가지고 있는 배열 선언     const arr = new Array(배열길이).fill(초기화 값);           주의할 사항 → 정렬해서 배열이 제공되었다는 것은 O(n)의 시간복잡도를 가지도록 문제를 해결하라는 것!   1. 증가수열 찾기  단일 for문을 사용해서 문제를 해결한다      접근방법 : 배열의 인덱스를 이용해서 앞뒤 요소를 비교한다   const solve = (arr) =&gt; {   for (let i = 0; i &lt; arr.length; i++){     if(arr[i] &lt; arr[i+1]){       // 문제에 따른 요구사항 구현     }   } }   2. 바이토닉 수열 문제  [ 바이토닉인지를 확인하는 문제를 기준 ]      바이토닉 수열이란 증가하다가 감소하는 수열을 말한다    바이토닉 수열은 반복문 두개를 이용해서 해결한다 (중첩 x)      증가를 기준으로 진행하는 반복문            진행하는 반복문 이후 확인을 한번 해준다       포인트가 전혀 움직이지 않음(처음부터 증가하지 않음)       포인트가 제일 마지막에 위치(끝까지 증가)           감소를 기준으로 진행하는 반복문            왼쪽으로 진행하는 반복문 이후 확인 필요           // arr = [1, 2, 3, 4]라는 수열 입력됨  // 증가해야하므로 오른쪽 요소의 값이 더 크다면 i에 +1 while (arr[i] &lt; arr[i+1]) i++;  // 전혀 증가하지 않거나 끝까지 증가만 한 경우를 확인 if (i === 0 || i === arr.length - 1) return false;  증가를 기준으로 진행하는 반복문의 예시이다   위 예시는 [1, 2, 3, 4]의 배열이 입력이므로 끝까지 증가만 해서 i === arr.length - 1의 조건에 걸린다   // 감소해야하므로 오른쪽 요소의 값이 더 작다면 i에 +1 while (arr[i] &gt; arr[i+1]) i++;  // 끝까지 진행하지 않았으면 바이토닉 수열이 아니다 if (i !== n - 1 ) return false;  감소를 기준으로 진행하는 반복문의 예시이다   증가를 확인하는 반복문이 종료된 i의 시점에서 진행하고, 끝까지 진행했는가를 확인한다   3. 거리두기 문제  배열이 있을때 항목간 얼마나 멀리 떨어져있는지를 판별하는데 사용할 수 있다   배열을 기준으로 양방향으로 한번씩 계산해준다      왼쪽으로 진행   오른쪽으로 진행   - 문제   “X”와 가장 먼 “O”의 인덱스를 선정하는 문제  [ X O O X O O O X O ]      직관적으로 봤을때 6번째 O가 답이다    - 풀이  새로운 배열을 선언하고 임시변수를 선언한다  const tempArr = new Array(입력된 배열의 길이).fill(초기값); let temp = 0;   이후 왼쪽과 오른쪽으로 진행하며 계산한다  // 왼쪽에서 오른쪽 for (let i = 0; i &lt; n; i++){   if(arr[i] === 1) {     temp = 0;   } else{     temp++;   }   tempArr[i] = d; } // 오른쪽에서 왼쪽 for (let i = n-1; i &gt;= 0; i--){   if(arr[i] === 1){     temp = 0   } else{     temp++;   }   tempArr[i] = Math.min(tempArr[i], temp) }  // tempArr [0, 1, 1, 0, 1, 2, 1, 0, 1]  tempArr에서 가장 큰수의 인덱스를 찾아주면 된다!       배열 관련 JS 메소드   1. join()  배열의 각 항목을 합쳐준다 이때 구분자를 입력할 수 있다  array.join(\"구분자\")     아무것도 입력하지 않으면 ,를 구분자로 사용한다   2. split()  입력한 구분자를 대상으로 배열을 분리한다  string.split(\"구분자\")     정규표현식도 사용이 가능하다   limit 옵션을 줄 수 있다 두번째 파라미터로 숫자를 입력하면 반환하는 배열의 크기를 정할 수 있다   3. reverse()  배열의 순서를 거꾸로 만들어준다  array.reverse()     원본을 변화시키기 때문에 주의해야한다   4. splice()  해당 부분을 삭제한다  array.splice(기준인덱스, 삭제개수)     원본을 변화시키므로 주의해야 한다   첫 번째 인자: 시작점   두번째 인자: 삭제할 개수   5. slice()  배열의 특정부분을 반환한다  array.slice(시작인덱스, 마지막인덱스)     시작지점과 어디까지인지(범위) 인덱스를 입력한다 (마지막 인덱스는 반환에서 제외된다)   6. find()  조건을 만족하는 첫 번째 요소의 값을 반환한다  array.find(item =&gt; 조건)     값을 찾으면 값 반환, 못찾으면 undefined를 반환   7. filter()  조건에 부합하는 값들을 새로운 배열로 만들어 반환  array.filter(item =&gt; 조건);     콜백함수를 파라미터로 받는다   콜백함수에서 true가 나온 값들을 새로운 배열에 저장   8. map()  배열의 요소 하나하나를 다른것으로 변환할 수 있다, 데이터를 맵핑한다  array.map(item =&gt; 변환값)     새로운 배열이 리턴된다   ex) array.map(item =&gt; +item) string 타입인 숫자를 number 타입으로 변환   9. some()  조건에 해당하는 것이 하나라도 있는지를 확인  array.some(item =&gt; 조건);     조건이 하나라도 맞으면 true를 반환   true를 반환하는 순간 some함수 종료   10. every()  모든 요소가 조건에 해당하는지 확인  array.every(obj =&gt; 조건)     모든 요소가 조건에 해당해야 true를 반환   10. reduce()  반복적으로 결과값을 다음 인자로 넘겨준다  array.reduce((prev, curr) =&gt; {   return (다음 prev로 넣어줄 값) }, 초기값)     콜백함수와 초기값을 전달한다 (초기값은 옵션)   콜백함수는 누적된 값을 반환한다   초기값을 넣은경우 초기값은 처음에 prev로 들어간다   reduceRight(): reduce와 동일하지만 순서가 반대로 진행된다   ex)     arr = [1, 2, 3, 4]; arr.reduce((prev, curr) =&gt; {   console.log(prev);   return prev + curr; }, 0);          // 결과 0 1 3 6          ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/array/",
        "teaser": null
      },{
        "title": "[Algorithm] 슬라이딩 윈도우, 투 포인트",
        "excerpt":"▶️ 슬라이딩 윈도우  선형의 자료구조에서 가상의 windowrk 있다고 가정하고 가상의 window를 움직이며 window 안의 값을 다룬다         수열 [1, 2, 3, 4, 5, 6, 7]에서 크기가 3인 연속된 부분수열중 합이 10이 넘는 부분연속수열의 개수를 구하는 문제    일반적으로 반복문을 두번 돌려서 완전탐색을 진행할 수 있다   2중 반복문을 사용하는 것의 시간복잡도는 O(n^2)이다 만약 이때 슬라아당 윈도우를 사용하면 O(n)으로 시간복잡도를 줄일 수 있다   const arr = [1, 2, 3, 4, 5, 6, 7]  let result = 0; let sum = 0; for (let i = 0; i &lt; 3; i++) {   sum+=arr[i]; } if (sum &gt; 10) {    result++; }  for (let i = 3; i &lt; arr.length; i++){   sum = sum - arr[i - 3] + arr[i];   if (sum &gt; 10) {      result++;   } } console.log(result);  // 결과 3      초기 window를 셋팅한다 (크기에 맞춰서)   인덱스의 증가함에 따라 window가 움직인다   기존의 값에서 빼거나 더하는 연산을 이용해서 해당 window의 값을 구한다   조건에 따른 비교를 한다   기존의 값에서 연산을 하는 것이 중요하다      window가 이동함에 따라 겹치는 구간이 존재하기 때문에 기존에 있던 부분은 제거하고, 새로운 부분은 추가하면 된다      기존: (2+3+4) / 이동후: (3+4+5) / 겹치는 부분: (3+4) → (2+3+4)-2+5 === (9-2+5)    ▶️ 투포인트  인덱스 두개(left, right)를 사용해서 두개의 포인트를 조작해서 값을 구한다      수열이 주어지고, 합이 3이 되는 연속된 부분수열의 개수을 구하는 문제    const arr = [1, 2, 1, 3, 1, 1, 1, 2];  let result = 0; let sum = 0; let left = 0; for (let right = 0; right &lt; arr.length; right++){   sum += arr[right];   while(sum &gt; 3){     sum -= arr[left++];   }   if (sum === 3){     result++;   } }  console.log(result);  // 결과 5   for문을 통해 오른쪽 인덱스(right)가 하나씩 증가하고 내부 while문에 의해서 합이 3보다 클때 왼쪽 인덱스(left)를 3보다 작을때까지 인덱스를 증가시킨다   양 포인터(left, right) 사이 값들의 합이 3이면 카운트(result)를 하나 증가시킨다   시간복잡도 O(n)으로 효율적으로 탐색이 가능하다   포인트가 이동하는 과정        ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%9C%88%EB%8F%84%EC%9A%B0/",
        "teaser": null
      },{
        "title": "[Algorithm] 2차원 배열",
        "excerpt":"자바스크립트에서 이차원배열을 다루는 문제들을 푸는 방법을 정리했습니다   2차원 배열   ▶️ 2차원 배열의 생성  2차원 배열을 생성하는 방법에는 몇가지가 있다   1. push  빈 배열을 선언하고 push 하는 방법  const arr = new Array(); for (let i = 0; i &lt; 4; i++){   arr.push(Array(4).fill(0)); }   2. map  크기가 지정된 배열을 선언하고 map을 이용해서 배열로 바꿔주는 방법  const arr = new Array(4).fill(null).map(() =&gt; Array(4).fill(0));   3. Array.from  Array.from은 첫번째 인자로 배열을 받고 두번째 인자로는 map과 동일하게 각 요소에 적용할 홤수를 인자로 입력받는다  const arr = Array.from(Array(4), () =&gt; Array(4).fill(0));     Array.from은 얉은 복사 된 새로운 객체를 생성한다   ▶️ 2차원 배열 문제  보통 2차원 배열의 문제는 인덱스를 다루는 문제가 주를 이룬다   1. 모든 경우를 다 도는 문제      n*n 크기의 격자판에서 가로 세로의 합이 가장 큰 경우를 반환하는 문제    const solve = (board) =&gt; {   // 가로의 길이   const len = board.length;    // 결과를 저장할 변수   let result = 0;    // 각각 가로세로의 합을 저장할 임시 배열   const tempArr = new Array(len*2).fill(0);    // 모든 경우를 탐색한다   for (let i = 0; i &lt; len; i++){     for (let j = 0; j &lt; len; j++){       tempArr[i] += board[i][j];       tempArr[j+len] += board[i][j];     }   }   result = Math.max(...tempArr);    return result; }      각 가로 세로의 합을 저장할 임시 배열을 생성하고, 이중 for문을 이용해서 모든 경우를 탐색하며 임시 배열에 더해준다   암사 해열을 펼침 연산자(...)를 이용해서 가장 큰 수를 구해준다   2. 플러드 필(Flood Fill)  플러드 필이란 다차원 배열에서어떤 칸과 연결된 영역을 찾는 알고리즘이다      주위(상하좌우)보다 큰수의 위치를 찾는 문제    const solve = (nums) =&gt; {   const len = nums.length;   let answer = [];      // 상하좌우의 인덱스 계상을 하기 위한 배열   const dx = [1, 0, -1, 0];   const dy = [0, 1, 0, -1];    // 모든 요소를 탐색   for (let i = 0; i &lt; len; i++){     for(let j = 0; j &lt; len; j++){       flag = true;       // 플로드 필(상하좌우를 확인한다)       for (let k = 0; k &lt; dx.length; k++){         nx = i+dx[k];         ny = j+dy[k];         if(nx &gt;= 0 &amp;&amp; nx &lt; len &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; len){           if(nums[i+dx[k]][j+dy[k]] &gt;= nums[i][j]){             flag = false;             break;           }         }       }       if(flag === true) answer.push([i, j]);     }   }   return answer; }     이중 for문을 이용해서 모든 요소를 탐색한다   플로드 필을 이용해서 상하좌우 인덱스를 확인한다            만약 현재 인덱스가 (0, 0)이라면 배열에서 (0, -1)인덱스를 탐색할 수 없다       out of range!           현재 요소가 상하좌우 요소보다 크면 결과배열(answer)에 push 한다   3. 플러드 필을 응용한 문제 (백준 - 오목)      백돌과 흑돌중 이긴 사람을 출력하는 문제    백준 2615 - 오목문제       접근방향  플로드 필을 이용해서 한 방향으로 진행하며 카운팅이 5가 되거나, 다른 돌 또는 공백이 있으면 break한다      for문을 통해 위에서부터 순차적으로 탐색이 진행되므로 4가지 방향만 탐색하면 된다 (반대 방향으로 진행해도 같다)   const fs = require(\"fs\"); const filePath = process.platform === 'linux' ? '/dev/stdin' : './2615.txt';  let board = fs.readFileSync(filePath).toString().trim().split(\"\\n\"); board = board.map(item =&gt; item.split(\" \").map(item2 =&gt; +item2));  const solve = (board) =&gt; {   const len = board.length;      // →, ↘︎, ↓, ↙︎ 방향으로 진행하기 위한 배열   const dx = [0, 1, 1, 1];   const dy = [1, 1, 0, -1];    for(let i = 0; i &lt; len; i++){     for(let j = 0; j &lt; len; j++){       if(board[i][j] !== 0){         // 현재 돌(1 or 2)을 저장하기 위한 변수         temp = board[i][j];         for(let k = 0; k &lt; dx.length; k++){           x = i;           y = j;           nx = i + dx[k];           ny = j + dy[k];           cnt = 1;                      while(true){             // 만약 다음 인덱스가 범위를 벗어나면 break             if(nx &lt; 0 || nx &gt;= len || ny &lt; 0 || ny &gt;= len) break;             // 다음 돌이 다른 돌이라면 break             if(board[nx][ny] !== temp) break;             nx += dx[k];             ny += dy[k];             cnt++;              if(cnt === 5){               // 진행방향의 반대편이 같은 돌이라면 break (6개 이상이 되는 경우)               if(x-dx[k] &gt;= 0 &amp;&amp; x-dx[k] &lt;= len-1 &amp;&amp; y-dy[k] &gt;= 0 &amp;&amp; y-dy[k] &lt;= len-1){                 if(board[x-dx[k]][y-dy[k]] === temp) break;               }               // 다음돌이 같은 돌이라면 break (6개 이상이 되는 경우)               if(nx &gt;= 0 &amp;&amp; nx &lt; len &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; len) {                 if(board[nx][ny] === temp) break;               }               // 이긴사람 (temp)               console.log(temp);               // 오른쪽 하단으로 진행하는 경우 가장 왼쪽돌을 출력               if(k === 3) console.log(i+5, j-3);               else console.log(i+1, j+1);               return;             }           }         }       }     }   }   console.log(0);   return; }  solve(board);      이중 for문을 사용해서 전체의 경우를 탐색   0이 아닌 흰돌 또는 검은 돌을 만났을 때 4가지 경우를 확인(플러드 필)   각각의 방향을 확인하면서 돌이 6개 이상이 되는 경우를 제거 (인덱스를 이용)   위 과정을 반복하면서 오목이 완성된 곳의 인덱스와 승자를 console.log()로 출력   ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/2%EC%B0%A8%EC%9B%90%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[Algorithm] stack, queue, deque",
        "excerpt":"▶️ 스텍 (stack)  스텍은 한쪽에서만 push, pop (데이터 I/O)을 할 수 있는 선형 자료구조이다     LIFO (Last In First Out)      tip!  (),{},[]가 등장하면 스텍을 활용하는 것을 고려해보자(70%~80%)   후위 연산   참고) 트리순회       전위 순회: 부모 → 왼쪽자식 → 오른쪽자식   중위 순회: 왼쪽자식 → 부모 → 오른쪽자식   후위 순회: 왼쪽자식 → 오른쪽자식 → 부모       후위연산을 하는데 스텍을 이용할 수 있다  const solve = (s) =&gt; {   const stack = [];   for(const item of s){     if(item === \"+\"){       temp1 = stack.pop();       temp2 = stack.pop();       stack.push(temp2 + temp1);     } else if(item === \"-\"){       temp1 = stack.pop();       temp2 = stack.pop();       stack.push(temp2 - temp1);     } else if(item === \"*\"){       temp1 = stack.pop();       temp2 = stack.pop();       stack.push(temp2 * temp1);     } else if(item === \"/\"){       temp1 = stack.pop();       temp2 = stack.pop();       stack.push(temp2 / temp1);     }else stack.push(parseInt(item));   }   return stack.pop(); } console.log(solve(\"25+3*21+*\"));  // 중위표현 (2 + 5) * 3 * (2 + 1)  // 결과 63      스텍(배열)을 생성해서 숫자는 순서대로 스텍에 넣어준다   연산자를 만난 경우 연산자를 가운데에 스텍에서 먼저 뺀 숫자를 뒤로, 늦게 뺀 숫자는 앞으로 배치하여 계산한다   계산한 결과를 스텍에 다시 넣어준다   백준2493 - 탑         간단하게 말해서 현재의 위치에서 바로 왼쪽의\u001c탑중에 자신보다 큰 탑의 인덱스를 출력해주면 된다    const fs = require(\"fs\"); const filePath = process.platform === 'linux' ? '/dev/stdin' : './2493.txt';  let input = fs.readFileSync(filePath).toString().trim().split(\"\\n\"); n = parseInt(input.shift()); input = input[0].split(\" \").map(item =&gt; +item);  const solve = (nums, n) =&gt; {   const result = new Array(nums.length).fill(0);   const stack = [];    for (let i = n; i &gt;= 0; i--){     while (stack.length &gt; 0 &amp;&amp; nums[stack[stack.length-1]] &lt; nums[i]){       result[stack.pop()] = i+1;     }     stack.push(i);   }   return result.join(\" \"); }  console.log(solve(input, n));  // 결과 0 0 2 2 4      먼저 자신보다 더 작은 탑이 없는 경우를 고려해서 result를 0으로 초기화해준다   스텍역할을 하는 배열을 하나 선언한다   for문을 이용해서 뒤에서부터 반복한다   만약 스텍이 비어있고, 스텍의 인덱스를 가진 값이 for문의 i값을 인덱스로 하는 값보다 작으면(비교 - while이용), 스텍의 가장 윗 인덱스를 제거하고 결과값에 떨어진 정도(i+1)을 저장한다 / 스텍에 값을 넣어준다   결과값을 출력하게 되면 자신보다 큰 탑의 인덱스를 저장하게 된다       ▶️ 큐 (Queue)  큐는 스텍과 다르게 처음 양쪽에 하나씩 삽입(In), 삭제(Out)이 가능한 선형 자료구조이다     FIFO (First In First Out)   In, Out이 같은 방향에 있지 않는다      선행되어야 하는 항목   만약 스킬트리를 선택할 때 선행되어야 하는 스킬이 있다고 했을때 잘못된 스킬트리를 작성했을때는 NO를 정상적인 스킬트리라면 YES를 출력하는 문제  const solve = (skill, skill_trees) =&gt; {   const queue = skill.split(\"\");   for(const s of skill_trees){     if(queue.includes(s)){       if(queue[0] === s) queue.shift();       else return \"NO\";     }   }   if(queue.length === 0) return \"YES\";   return \"NO\";  } console.log(solve(\"ABC\", \"ABDCGE\"));  // 결과  YES      먼저 정해진(선행되어야하는) 스킬을 큐 역할을 하는 배열로 변환시켜준다   for문을 이용해서 작성한 스킬트리를 순회한다   작성한 스킬트리를 하나하나 순서대로 순회하면서 만약 선행스킬에 현재 스킬이 존재하고, 큐의 제일 앞에 위치한 스킬과 현재 스킬이 동일하다면 큐의 제일 앞항목을 제거하고 다시 진행한다(일치하지 않으면 return \"NO\")   끝까지 다 진행했음에도 NO를 리턴하지 않았다면 YES를 리턴한다       ▶️ 데크 (Deque)  큐와 비슷하지만 양쪽으로 삽입(In), 삭제(Out)이 가능한 선형 자료구조이다     스텍과 큐의 장점을 가지고 만든 구조      ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/%EC%8A%A4%ED%85%8D,%ED%81%90,%EB%8D%B0%ED%81%AC/",
        "teaser": null
      },{
        "title": "[Algorithm] Greedy, Priority Queue ",
        "excerpt":"▶️ 그리디 알고리즘 (Greedy Algorithm)   탐욕적인 알고리즘이라는 뜻으로 현재 상황에서 가장 좋은 경우를 선택한다   현재 상황에서 가장 좋은 해를 결정하고 다음 단계로 넘어가기 때문에 일부 상황에서는 나쁜 해가 될 수 있다      그리디 알고리즘이 적용될 수 있는 경우         이전의 선택이 이후의 선택에 영향을 주지 않아야 한다.     각 부분 문제에 대한 최적해가 문제의 최적해를 얻을 수 있다.      ▷ 회의실 문제 (beakjoon - 1931)        입력값     11 1 4 3 5 0 6 5 7 3 8 5 9 6 10 8 11 8 12 2 13 12 14              회의시간이 겹치지 않고, 제일 많은 회의를 할 수 있는 회의의 개수를 구하면 된다    const fs = require(\"fs\"); const filePath = process.platform === 'linux'? \"/dev/stdin\" : \"./2_1931.txt\";  let input = fs.readFileSync(filePath).toString().trim().split(\"\\n\");  const n = input.shift()[0];  for (let i = 0; i &lt; n; i++) {   input[i] = input[i].split(\" \").map(item =&gt; +item) }  // 시작시간이 더 큰수가 기준이 되면 안되기 때문에 시작시간을 기준으로 정렬, 끝나는 시간을 기준으로 정렬 (총 두번 정렬) input.sort((a, b) =&gt; a[0] - b[0]); input.sort((a, b) =&gt; a[1] - b[1]);  // 첫번째 회의는 무조건 시작하기 때문에 result = 1 let result = 1; // 끝나는 시간 let temp = input[0][1]; for (let i = 1; i &lt; n; i++) {   if (input[i][0] &gt;= temp) {     result += 1;     temp = input[i][1];   } } console.log(result);  그리디 알고리즘은 보통 최솟값, 최댓값을 찾는 문제가 많으므로 정렬을 사용한다 위에서는 시작시간으로 한번 정렬해주고, 끝나는 시간을 오름차순으로 정렬해준다   정렬된 회의의 시작시간과 끝나는 시간을 가지고 반복문을 통해 처음 위치한 값을 기준으로 끝나는시간과 시작시간을 비교해서 카운팅한다       ▶️ 우선순위 큐 (Priority Queue)   들어간(In) 순서와 상관없이 우선순위가 높은 데이터가 먼저 나온다(Out)   힙 탐색의 시간복잡도는 O(logN)이다   우선순위 큐는 힙(Heap)을 이용해서 구현할 수 있다   ▷ 힙(Heap)  힙(Heap)은 최대값 또는 최솟값을 빠르게 찾아내기 위해 고안된 자료구조로 완전 이진 트리의 구로를 가진다   완전 이진 트리  leaf노드를 제외한 나머지 모든 부모 노드들이 자식 노드를 두개씩\u001c가지고 있는 이진트리   힙은 두가지 종류를 가진다         최대 힙(Max Heap): 루트노드로 올라갈수록 값이 커지는 완전 이진 트리(힙)            부모노드가 자식노드보다 무조건 크다           최소 힙(Min Heap): 루트노드로 올라갈수록 값이 작아지는 완전 이진 트리(힙)            부모노드가 자식노드보다 무조건 작다           1. 삽입연산(push)     삽입연산(push)을 하게되면 left노드에 개수를 고려하면서(한 노드에 자식노드 2개) 삽입이된다   삽입된 노드는 부모노드와 값을 비교한다 (크거나 작거나)   만약 최대힙에서 자식노드가 부모노드의 값보다 크다면, 부모노드와 자식노드를 교체해준다   교체해주는 과정을 더이상 그렇지 않을때까지, 루트노드에 도착했을때까지 반복한다   2. 삭제연산(pop)     우선순위큐에서의 삭제는 가장 높은 우선순위를 가진 루트노드가 삭제가 된다   이후 제일 마지막에 있는 노드를 루트노드의 자리로 옮긴다   이후 자식노드들과 비교하면서 자리를 교체한다   ▷ 최대 힙(Max Heap) 구현      * 인덱스         왼쪽 자식 노드 인덱스 → 부모 노드 인덱스 * 2 + 1     오른쪽 자식 노드 인덱스 → 부모 노드 인덱스 * 2 + 2     부모 노드 인덱스 → (자식 노드 인덱스 - 1) / 2 → parseInt()를 사용      class MaxHeap{   constructor() {     this.heap = [];     this.heap.push(1e9);    // 큰 값을 제일 앞에 넣어준다   }    // heap에 데이터를 삽입   insert(value){     this.heap.push(value);     // 값이 들어오면 작거나 큼에 따라 위로 올려준다     this.upheap(this.heap.length - 1);   }     // insert된 값을 올려주는 메소드   upheap(pos){     // 마지막으로 들어온 값을 temp에 할당     let temp = this.heap[pos];      // 부모노드와 비교하며 현시점의 부모보다 크면 부모노드의 값을 아래로 내림     while(temp &gt; this.heap[parseInt(pos/2)]){       this.heap[pos] = this.heap[parseInt(pos/2)];       pos = parseInt(pos/2);     }     // 마지막으로 현시점의 노드에 temp값을 넣어준다     this.heap[pos] = temp;   }     // 루트노드를 가져오는 메소드   get(){     // 만약 heap의 크기가 0인데 pop을 하려고 하면 false반환     if (this.size() === 0) return false;     // 만약 heap의 크기가 1이라면 downheap()을 하지않고 pop만 수행     if (this.size() === 1) return this.heap.pop();     // 루트노드값을 result 변수에 임시저장하고, 루트노드 자리에 제일 마지막 노드를 위치시킨다     const result = this.heap[1];     this.heap[1] = this.heap.pop();     // 아래로 진행하면서 자리배치     this.downheap(1, this.heap.length-1);     return result;   }    downheap(pos, len){     // 루트노드에 위치한 값을 임시 저장     let temp = this.heap[pos], child;     while(pos &lt;= parseInt(len/2)){       child = pos * 2;        // 왼쪽 자식       // 자식노드가 하나만 존재할 수 있기 때문에 child &lt; len       if(child &lt; len &amp;&amp; this.heap[child] &lt; this.heap[child+1]) child++;      // +1로 오른쪽자식과 비교한다        // 자식노드보다 크다면 멈춘다       if(temp &gt;= this.heap[child]) break;       // 자식노드와 부모노드의 자리를 교환       this.heap[pos] = this.heap[child];       // 인덱스를 아래로 옮김       pos = child;     }     // 현재 시점의 노드에 값 할당     this.heap[pos] = temp;   }       // heap의 크기를 반환하는 메서드   size(){     return this.heap.length-1;   } }     insert(): heap에 데이터를 삽입   upheap(): insert()내에 존재하면서 데이터가 삽입이되면 정렬시켜줌   get(): heap의 루트노드를 반환   downheap(): get()에 존재하면서 루트노드가 삭제되면 정렬하면서 채워줌   size(): heap의 크기를 반환   ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/%EA%B7%B8%EB%A6%AC%EB%94%94,%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/",
        "teaser": null
      },{
        "title": "[Algorithm] DFS ",
        "excerpt":"▶️ DFS (깊이 우선 탐색)  DFS는 깊이 우선 탐색으로 재귀함수를 이용해서 가지처럼 뻣어나가는 알고리즘이다   DFS를 사용하기 편한 방법으로는 다음과 같은 형태를 이용하면 좋다  const DFS = () =&gt; {   if(조건){     내용(조건이 맞아 결과에 추가하는)   }else{     내용(재귀호출)   } }   ▷ 부분집합문제  두가지로 분류한다 (해당 숫자를 사용하거나, 사용하지 않거나)      const result = []; const temp = []; function DFS(v){    // v는 인덱스   if(v &gt; n) {   // n까지의 원소     result.push(temp.slice())   // 복사해서 저장     return;   }   else{     temp.push(v);        DFS(v+1);     temp.pop();     DFS(v+1);   } } DFS(1);      DFS 함수내 if문에서 조건을 넣어주고 충족한다면 결과값에 저장한다(위의 n은 예시)   else문에서는 temp라는 배열에 push를 해주게 되는데 이때는 해당 값을 사용한다는 뜻이고 그 아래 pop은 넣어줬던 값을 뺌으로서 사용하지 않겠다는 뜻이다 (사용했을때 재귀호출, 사용하지 않을때 재귀호출)   ▷ 중복순열  중복순열 문제는 부분집합과 다르게 중복을 허용하므로써 가지가 두개만 나올 수 없다      예시) 1,2,3의 중복 수열       수열의 길이만큼(예시에서 3개이므로 가지도 3개씩) 가지가 생성된다 따라서 재귀 호출도 3번!   const answer = []; let temp = [];  const DFS = (L) =&gt; {   if(L === 수열개수){     answer.push(temp.slice());   }else {     for(let i = 1; i &lt;= arr.length; i++){       temp.push(i);       dfs(L + 1)       temp.pop();     } }  DFS의 인자인 L은 level을 뜻하는 것으로 깊이를 나타낸다      if문에서는 조건에 맞으면 결과를 저장해준다   else문에서는 for문을 사용해서 배열의 길이만큼 반복해준다   ▷ 중복이 없는 순열  중복수열을 사용할때와 다른 점이 한가지 있다면 사용여부를 확인하는 체크배열을 생성해서 검사를 해준다  let answer = []; const len = nums.length; const check = new Array(len).fill(0);   // 체크배열  let temp = []; const dfs = (L) =&gt; {   if(L === m){     answer.push(temp.slice());   }else{     for(let i = 0; i &lt; len; i++){       // check(같은 수가 있는지 확인)       if(check[i] === 0){         check[i] = 1;         // 수를 사용하면 체크         temp.push(nums[i]);         dfs(L + 1);         check[i] = 0;         // 사용한 후 pop과 함께 체크해제         temp.pop();       }     }   } } dfs(0);   ▷ Memoization (메모이제이션)  계산한 값을 저장해둠으로서 불필요한 같은 계산을 하지 않도록하기 위해 사용한다   피보나치 수열을 예시로 들자면 다음과 같다   // 계산 값을 저장할 배열 const dy = new Array(n+1);  const fibo = (n) =&gt; {   if(n &lt; 2) return n;    // 저장한 값이 있으면 저장값을 사용   if(dy[n] !== undefined) return dy[n];    // 저장값이 없으면 계산하고 배열에 저장   return dy[n] = fibo(n-1) + fibo(n-2) } return fibo(n);   fibo(10)은 fibo(9) + fibo(8)이다 또 fibo(9)는 fibo(8) + fibo(7)이 된다   이때 fibo(8)이 겹치게 되는데 메모이제이션을 사용하지 않는다면 계산을 두번 반복하게 된다 이는 아래로 내려갈수록 더욱 잦아지게 된다 따라서 속도가 느려질 수 있는데 이를 개선하기 위해 메모이제이션을 사용하면 배열에 값이 있는지를 확인하고 있다면 그 수를 사용해 불필요한 계산을 방지할 수 있다   ▷ 참고 - 함수와 스텍  함수가 호출이 되면 내부적으로 스텍에 함수가 들어가게 된다 이때 스텍프레임이라고 하며 이 스텍 프레임 각각에는 함수의 정보가 담긴다      매개변수   지역변수   복귀주소   재귀함수는 전역변수를 다루지 않는다 → 지역변수를 사용해서 문제를 해결하자!  ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/dfs/",
        "teaser": null
      },{
        "title": "[Algorithm] BFS ",
        "excerpt":"▶️ BFS (너비 우선 탐색)  BFS는 너비 우선 탐색으로 큐를 이용해서 간단하게 구현할 수 있다   기본적인 틀은 다음과 같다   const BFS = () =&gt;{    // 큐 생성 (FIFO)   let queue=[];   // 기본셋팅   queue.push(1);   while(queue.length){     // 진행할 노드     let temp = queue.shift();           for(이후 진행노드에 대해){       queue.push(이후 진행할 노드);      }   }  }      다음과 같은 사진이 있을때 DFS는 왼쪽의 자식을 계속해서 깊이(아래로) 먼저 진행하는 방식이라면 BFS는 레벨(0, 1, 2)를 기준으로 동작하는 것처럼 보인다   맨 위의 루트노드부터 아래층의 1을 가진 노드, 이후 2를 가진 노드 순서대로 같은 층(레벨)에 존재하는 노드들을 탐색한다   따라서 선입선출인 큐를 이용해서 shift(), pop()을 사용하면 순차적으로 노드 탐색을 할 수 있다   ▷ BFS문제      만약 보드게임을 진행하는데 각 칸에는 숫자가 적혀있고, 1칸부터 적혀있는 숫자까지 이동할 수 있으며 끝점에 다다르면 승리하는 게임이다 이 게임을 승리하기 위한 최소의 이동횟수를 구하라(입력은 1차원 숫자 배열)    const solve = (nums) =&gt; {   let result = 0;   // BFS를 위한 큐역할을 하는 배열   const queue = [];   // 목적지   const goal = nums.length - 1;       const BFS = () =&gt; {     // 기본셋팅     queue.push(0);     let L = 0;      while(queue.length &gt; 0){       let len = queue.length;       for(let i = 0; i &lt; len; i++){         let x = queue.shift();         for(let j = 1; j &lt;= nums[x]; j++){           // 다음 노드로 진행하기 전에 검사하고 1을 더해서 반환           if(x+j === goal) return L + 1;           if(x+j &lt;= goal) queue.push(x+j);         }       }       L++;     }          }   result = BFS();   return result === undefined ? -1 : result; } console.log(solve([2, 2, 0, 2, 1, 1]))  3      큐역할을 하는 배열을 생성한다   BFS 함수 내에서 whlie문을 통해 진행할 노드가 있을때까지 반복한다   shift()로 큐에 있는 노드를 빼서 검사한다   조건에 맞으면 return을 통해 값을 반환한다   ","categories": ["Algorithm"],
        "tags": ["Algorithm"],
        "url": "/algorithm/bfs/",
        "teaser": null
      }]
