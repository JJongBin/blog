<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://jjongbin.github.io/blog//feed.xml" rel="self" type="application/atom+xml" /><link href="https://jjongbin.github.io/blog//" rel="alternate" type="text/html" /><updated>2021-12-28T16:50:47+09:00</updated><id>https://jjongbin.github.io/blog//feed.xml</id><title type="html">공부하는 종빈🧑🏻‍💻</title><subtitle>공부한 내용을 기록하는 블로그</subtitle><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><entry><title type="html">DOM</title><link href="https://jjongbin.github.io/blog//other/DOM/" rel="alternate" type="text/html" title="DOM" /><published>2021-12-28T00:00:00+09:00</published><updated>2021-12-28T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/DOM</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/DOM/">&lt;p&gt;&lt;img src=&quot;../../imgs/childNodes.png&quot; alt=&quot;childNodes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;위 사진처럼 이전에 자바스크립트 코드를 작성하면서 DOM 노드를 탐색하는 경우가 있었는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;childNodes&lt;/code&gt;와 인덱스를 이용해서 접근하려고 했을 때 이상한 값이 출력되는 것을 목격한 적이 있다(분명 ul요소 아래에 li요소는 세개인데…?). 그래서 다른 방법으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;children&lt;/code&gt; 메서드를 사용했었는데 현재 자바스크립트를 공부하면서 이유를 알게 되었다. 그래서 DOM과 노드를 탐색하는 메서드들에 대해서 정리하려고 한다.&lt;/del&gt;&lt;/p&gt;

&lt;h1 id=&quot;dom&quot;&gt;DOM&lt;/h1&gt;

&lt;p&gt;DOM이란, HTML 문서의 계층적 구조와 정보를 표햔하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조이다.&lt;/p&gt;

&lt;h2 id=&quot;1-노드&quot;&gt;1. 노드&lt;/h2&gt;

&lt;p&gt;HTML요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 &lt;strong&gt;요소 노드 객체&lt;/strong&gt;로 변환되는데 어트리뷰트는 &lt;strong&gt;어트리뷰트 노드&lt;/strong&gt;, 텍스트 콘텐츠는 &lt;strong&gt;텍스트 노드&lt;/strong&gt;로 변환된다. 또한 중첩이 가능하기 때문에 요소노드객체 하위에는 다른 요소 노드 객체가 자식으로 올 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 노드 요소 객체로 구성된 트리 자료 구조를 &lt;strong&gt;DOM(Document Object Model)&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;노드-객체-타입&quot;&gt;노드 객체 타입&lt;/h3&gt;

&lt;p&gt;대표적인 노드 객체 타입은 다음과 같고, 총 12개의 노드 객체 타입이 존재한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;타입&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문서노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DOM의 최상위에 존재하는 루트 노드(document 객체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요소노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTML 요소를 가르키는 객체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어트리뷰트 노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTML 요소의 어트리뷰트를 가르키는 객체, 부모 요소가 없고, 요소 노드의 형제 요소도 아님&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;텍스트 노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTML 요소의 텍스트를 가르키는 객체, 요소 노드의 자식이고, 자식을 가질 수 없는 리프 노드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Comment 노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;주석을 위한 노드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DocumentType 노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DOCTYPE을 위한 노드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DocumentFragment 노드&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;복수의 노드를 생성하여 추가할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;노드-객체의-상속-구조&quot;&gt;노드 객체의 상속 구조&lt;/h3&gt;

&lt;p&gt;노드 객체의 상속 구조는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/노드객체상속.png&quot; alt=&quot;노드 객체 상속&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 객체는 Object, EventTarget, Node 인터페이스를 상속받는다. 프로토타입과 동일하게 기능들을 상속받게 된다. 따라서 노드에 따라 공통으로 가지고 있는 기능도 있고, 고유한 기능도 있다.&lt;/p&gt;

&lt;p&gt;노드 타입에 따라 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공하는데 이 DOM API를 이용해서 HTML 구조나 내용 또는 스타일들을 동적으로 조작할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-요소-노드에-접근하는-방법&quot;&gt;2. 요소 노드에 접근하는 방법&lt;/h2&gt;

&lt;h3 id=&quot;1-getelementbyid&quot;&gt;1. getElementById&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ Document.prototype.getElementById&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;HTML의 어트리뷰트로 지정한 id를 가진 요소 노드를 탐색하여 반환.&lt;/li&gt;
  &lt;li&gt;id값은 HTML문서 내 유일한 값이어야 한다.&lt;/li&gt;
  &lt;li&gt;동일한 id를 가지는 요소 중(동일한 id가 여러개여도 에러는 발생하지 않기 때문) 첫번째 요소를 반환.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-getelementsbytagname&quot;&gt;2. getElementsByTagName&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ Document.prototype/Element.prototype.getElementsByTagName&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementByTagName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;인수로 전달한 태그 이름을 갖는 &lt;u&gt;모든 요소&lt;/u&gt;를 탐색하여 반환.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HTMLCollection&lt;/strong&gt; 객체에 담아 반환.&lt;/li&gt;
  &lt;li&gt;모든 요소를 취득하려면 *을 인수로 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-getelementsbyclassname&quot;&gt;3. getElementsByClassName&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ Document.prototype/Element.prototype.getElementsByClassName&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementByClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;인수로 전달한 클래스를 가지는 &lt;u&gt;모든 요소&lt;/u&gt;를 탐색하여 반환.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HTMLCollection&lt;/strong&gt; 객체에 담아 반환.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-queryselector&quot;&gt;4. querySelector&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ Document.prototype/Element.prototype.querySelector&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;.jongbin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환.&lt;/li&gt;
  &lt;li&gt;만족하는 요소가 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;을 반환.&lt;/li&gt;
  &lt;li&gt;인수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생.&lt;/li&gt;
  &lt;li&gt;여러개의 요소를 선택하려면 querySelectorAll 메서드를 사용한다.(NodeList 객체로 반환)&lt;/li&gt;
  &lt;li&gt;다른 메서드들보다 느리지만 구체적인 조건을 사용해서 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;HTMLCollection&lt;br /&gt;
노드 객체의 상태 변화를 실시간으로 반영하는(live) DOM 컬렉션 객체&lt;/li&gt;
    &lt;li&gt;NodeList&lt;br /&gt;
실시간으로 노드객체의 상태 변경을 반영하지 않는(non-live) 객체&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;HTMLCollection과 NodeList는 유사 배열 객체이면서 이터러블이다.&lt;/p&gt;

&lt;h2 id=&quot;3-노드-탐색&quot;&gt;3. 노드 탐색&lt;/h2&gt;

&lt;p&gt;요소를 기준으로 부모, 자식, 형제 요소를 탐색할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;자식-노드-탐색&quot;&gt;자식 노드 탐색&lt;/h3&gt;

&lt;h4 id=&quot;childnodes&quot;&gt;childNodes&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.childNodes&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식 노드를 모두 탐색해서 DOM 컬렉션 객체 NodeList에 담아 반환.&lt;/li&gt;
  &lt;li&gt;반환한 NodeList 객체에는 요소노드만 존재하는 것이 아니고 텍스트 노드(공백 텍스트 노드)가 포함되어 있을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;children&quot;&gt;children&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Element.prototype.children&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식 노드들 중에서 &lt;strong&gt;요소 노드&lt;/strong&gt;만 모두 탐색하여 HTMLCollection에 담아 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;firstchild&quot;&gt;firstChild&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.firstChild&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 자식 노드를 반환 (텍스트 노드, 요소노드)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;firstelementchild&quot;&gt;firstElementChild&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Element.prototype.firstElementChild&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 요소 노드를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lastchild&quot;&gt;lastChild&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.lastChild&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마지막 자식 노드를 반환 (텍스트 노드, 요소노드)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lastelementchild&quot;&gt;lastElementChild&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Element.prototype.lastElementChild&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마지막 요소 노드를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부모노드&quot;&gt;부모노드&lt;/h3&gt;

&lt;h4 id=&quot;parentnode&quot;&gt;parentNode&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.parentNode&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요소의 부모요소를 반환.&lt;/li&gt;
  &lt;li&gt;document의 parentNode는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;형제-노드-탐색&quot;&gt;형제 노드 탐색&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;찾으려는 형제 요소가 없으면 null을 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;previoussibling&quot;&gt;previousSibling&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.previousSibling&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신의 이전 형제 노드를 반환 (텍스트 노드, 요소노드)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;previouselementsibling&quot;&gt;previousElementSibling&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Element.prototype.previousElementSibling&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신의 이전 형제 요소 노드를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nextsibling&quot;&gt;nextSibling&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Node.prototype.nextSibling&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신의 다음 형제 노드를 반환 (텍스트 노드, 요소노드)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nextelementsibling&quot;&gt;nextElementSibling&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;→ Element.prototype.nextElementSibling&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신의 다음 형제 요소 노드를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;처음에 언급했던 childNodes를 사용해서 특정 요소에 접근할때 이상한 값이 나오는 이유를 알게 되었다. childNodes는 NodeList 객체에 요소들을 담아서 반환하는데 이때 반환된 NodeList에는 요소 노드만 존재하는 것이 아니고 텍스트 노드도 존재하기 때문에 내가 의도한대로 출력이 되지 않았었다. children 메서드를 사용했을때 정상적으로 동작한 이유는 children 프로퍼티로 접근했을 경우에는 HTMLCollection에 요소 노드만 담아 반환해주기 때문에 인덱스로 접근했을때 원하는 결과를 도출할 수 있었다. 모르고 사용했을때와 알고 사용했을때의 차이는 크다고 생각한다. 왜 그렇게 동작하는지 명확하게 알고 이해하는 것이 중요함을 다시 한번 느낄 수 있었다.&lt;/del&gt;&lt;/p&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="JavaScript" /><category term="Other" /><summary type="html">DOM과 DOM 탐색</summary></entry><entry><title type="html">클래스</title><link href="https://jjongbin.github.io/blog//other/class/" rel="alternate" type="text/html" title="클래스" /><published>2021-12-19T00:00:00+09:00</published><updated>2021-12-19T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/class</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/class/">&lt;p&gt;&lt;del&gt;프로토타입에 대해서 알게된 후 개인적인 생각으로 클래스가 굳이 필요할까라는 생각을 했었는데 클래스를 사용하면 좀더 직관적이고, 명료하다는 느낌을 받게 되었다. 하지만 클래스를 사용하는 것과 생성자 함수를 이용한 프로토타입과의 동작부분의 차이가 없다는 생각이 들어 클래스와 프로토타입과의 차이에 대해 좀더 공부해보게 되었다&lt;/del&gt;&lt;/p&gt;

&lt;h1 id=&quot;클래스&quot;&gt;클래스&lt;/h1&gt;

&lt;p&gt;자바스크립트는 프로토타입 기반의 객체 지향 언어이지만 ES6에 클래스(Class)를 도입했다. 생성자 함수를 이용해 프로토타입을 사용하는 것과 클래스를 사용했을때와 비교했을때 몇가지 차이 점이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;연산자 없이 호출하면 에러가 발생한다. (생성자 함수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;연산자 없이 호출하면 일반함수로서 동작한다.)&lt;/li&gt;
  &lt;li&gt;클래스는 상속과 관련된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extends&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super&lt;/code&gt; 키워드를 지원한다.&lt;/li&gt;
  &lt;li&gt;클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 키워드처럼 &lt;u&gt;호이스팅이 발생하지 않는것처럼&lt;/u&gt; 동작한다.&lt;/li&gt;
  &lt;li&gt;클래스 내부에서는 암묵적으로 strict mode가 적용된다.&lt;/li&gt;
  &lt;li&gt;클래스의 constructor, 프로토타입 메서드, 정적메서드는 모드 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-클래스-정의&quot;&gt;1. 클래스 정의&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; 키워드를 사용하여 정의한다. 이때 클래스 이름은 파스칼 케이스를 사용하는 것이 일반적이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;클래스는 일급객체로 값처럼 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클래스의 몸체에는 &lt;strong&gt;constructor&lt;/strong&gt; &lt;strong&gt;프로토타입 메서드&lt;/strong&gt;, &lt;strong&gt;정적메서드&lt;/strong&gt; 세가지가 존재할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-constructor&quot;&gt;2. constructor&lt;/h2&gt;

&lt;p&gt;constructor는 인스턴스를 생성하고 초기화하기 위한 생성자함수와 같은 역할을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스가 동작할때 constructor는 메서드처럼 동작하지 않고, 클래스가 평가되어 생성한 함수 객체의 일부가 되는데 이는 생성자 함수와 유사하다.&lt;/li&gt;
  &lt;li&gt;constructor는 클래스 내부 하나만 존재할 수 있다.&lt;/li&gt;
  &lt;li&gt;constructor는 생략하면 암묵적으로 빈 constructor가 생성되는데 이때 상속받은 클래스와 상속받지 않은 클래스가 다르게 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// constructor에 매개변수 입력가능&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 전달된 인수로 초기화할 수 있다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;constructor에 매개변수를 지정해 클래스를 이용해 인스턴스를 생성할때 인수를 전달받을 수 있다. 이때 인수로 전달되는 매개변수의 값을 받을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;3-프로토타입-메서드&quot;&gt;3. 프로토타입 메서드&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;클래스 몸체 내부에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`Hi I&apos;m &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-정적메서드&quot;&gt;4. 정적메서드&lt;/h2&gt;

&lt;p&gt;생성자함수에서 정의한 메서드는 기본적으로 생성자함수를 이용해 호출할 수 이쓴ㄴ 정적메서드가 되는데 class에서는 class 몸체 내부에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 class에서 정적메서드를 정의하기 위해서는 특별한 방법이 필요한데 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;키워드를 사용하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`Hi I&apos;m &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`I&apos;m &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; years old!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sayAge&lt;/code&gt; 함수는 프로토타입 메서드가 아니기 때문에 클래스를 사용해서 생성한 인스턴스로 호출하면 에러가 나온다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Person.sayAge()&lt;/code&gt;로 호출해야 한다.&lt;/p&gt;

&lt;p&gt;또한 위 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sayAge&lt;/code&gt;함수(Person의 정적메서드)부분의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.age&lt;/code&gt;는 의도한대로 동작할 수 없다(Person class에 age라는 식별자 존재하지 않음)&lt;/p&gt;

&lt;p&gt;따라서 다음과 같이 사용하는 것이 맞다는 생각이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`I&apos;m &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; years old!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 매개변수를 정의하고, 인수로 명확한 값을 전달&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`I&apos;m &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; years old!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 매개변수를 정의하고, 인수로 인스턴스를 전달 -&amp;gt; 인스턴스의 age 프로퍼티를 참조&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 위 코드를 정적메서드를 사용할때 인수로 무엇을 넣어줘야할지 명확하게 알 수 없다는 단점을 가진다.&lt;/p&gt;

&lt;h2 id=&quot;5-인스턴스-생성&quot;&gt;5. 인스턴스 생성&lt;/h2&gt;

&lt;p&gt;class를 이용해서 인스턴스를 생성하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 연산자를 사용한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;연산자는 생성자함수의 내부 메서드 [[Construct]]를 호출하게 되는데 따라서 class에도 [[Construct]] 내부메서드가 존재함을 알 수 있다. 또한 일반 함수처럼 동작하지 못하는것을 보아 내부 메서드 [[Call]]은 존재하지 않다는 것을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 정의한 프로토타입 메서드, 정적메서드는 다음과 같이 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 프로토타입 메서드&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Hi jongbin!&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 정적메서드&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// I&apos;m 26 years old!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;6-클래스-상속&quot;&gt;6. 클래스 상속&lt;/h2&gt;

&lt;p&gt;클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extends&lt;/code&gt; 키워드를 사용해서 기존의 클래스를 상속받아 새로운 클래스를 확장해서 정의할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Jongbin&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상속하는&lt;/strong&gt; 클래스를 슈퍼클래스, 베이스클래스, 부모클래스라고 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상속받는&lt;/strong&gt; 클래스를 서브클래스, 파생클래스, 자식클래스라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클래스도 프로토타입을 가지게 되는데 상속받은 클래스를 그림으로 그려보면 다음과 같다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/class상속.jpeg&quot; alt=&quot;class 상속&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-super-키워드&quot;&gt;7. super 키워드&lt;/h2&gt;

&lt;p&gt;super 키워드는 함수처럼 호출할 수도 있고, 식별자처럼 참조할 수 있는 특수한 키워드이다.&lt;/p&gt;

&lt;p&gt;다음과 같이 두가지 방식으로 동작한다.&lt;/p&gt;

&lt;h3 id=&quot;1-super를-호출하면-슈퍼클래스의-constructor를-호출new-한-객체가-this가-된다&quot;&gt;1. super를 호출하면 슈퍼클래스의 constructor를 호출(new 한 객체가 this가 된다.)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서브클래스에서 constructor를 생략하지 않으면 서브클래스의 constructor에서는 무조건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super()&lt;/code&gt;를 호출해야 한다.&lt;/li&gt;
  &lt;li&gt;서브클래스의 constructor레서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super()&lt;/code&gt;를 호출하기 이전에는 this를 참조할 수 없다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super()&lt;/code&gt;는 반드시 서브클래스의 constructor에서 호출해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-super를-참조하면-슈퍼클래스의-메서드를-호출-가능&quot;&gt;2. super를 참조하면 슈퍼클래스의 메서드를 호출 가능&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서브클래스의 프로토타입 메서드내에서의 super 메서드는 슈퍼클래스의 프로토타입 메서드를 가르킨다.&lt;/li&gt;
  &lt;li&gt;super 참조를 통해 슈퍼클래스의 메서드를 참조하려면 super가 슈퍼클래스의 메서드가 바인딩된 객체(슈퍼클래스의 prototype 프로퍼티에 바인딩된 프로토타입)을 참조할 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인스턴스의-생성&quot;&gt;인스턴스의 생성&lt;/h2&gt;

&lt;p&gt;상속을 받지 않은 클래스와 상속을 받은 클래스는 인스턴스를 생성할때 차이점이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;상속을-받지-않은-클래스의-인스턴스-생성&quot;&gt;상속을 받지 않은 클래스의 인스턴스 생성&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;constructor는 빈객체 즉 인스턴스를 생성한다.&lt;/li&gt;
  &lt;li&gt;this를 바인딩하고 프로토타입 프로퍼티를 생성한다.&lt;/li&gt;
  &lt;li&gt;constructor 내부에 정의된대로 this에 바인딩된 인스턴스를 초기화한다.&lt;/li&gt;
  &lt;li&gt;암묵적으로 this에 바인딩된 인스턴스를 반환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;상속을-받은-클래스의-인스턴스-생성&quot;&gt;상속을 받은 클래스의 인스턴스 생성&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;서브클래스의 constructor에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super()&lt;/code&gt;를 호출한다.(이전에 this를 호출하고 없으면 에러)&lt;/li&gt;
  &lt;li&gt;super로 호출된 슈퍼클래스의 constructor에서 인스턴스를 생성하고 this를 바인딩한다.(서브클래스가 생성한것으로 처리한다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new.target&lt;/code&gt;) - this)&lt;/li&gt;
  &lt;li&gt;슈퍼클래스의 constructor 내부에 정의된대로 인스턴스를 초기화하고 인스턴스를 반환한다.&lt;/li&gt;
  &lt;li&gt;서브클래스의 constructor에서 super가 반환한 인스턴스를 this에 바인딩한다.(새로운 빈객체 생성x)&lt;/li&gt;
  &lt;li&gt;서브클래스 constructor 내부에 정의된대로 인스턴스를 초기화한다.&lt;/li&gt;
  &lt;li&gt;암묵적으로 this에 바인딩된 인스턴스를 반환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice&quot;&gt;서브클래스에서 인스턴스를 생성하지 않고 슈퍼클래스가 인스턴스를 생성하는것을 서브클래스가 슈퍼클래스에 인스턴스(빈객체) 생성을 위임한다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;서브클래스에서 super()를 호출하지 않았을때 인스턴스를 초기화하는 문을 작성할 수 없었는데 여기에 이유가 있었다! 슈퍼클래스에 인스턴스 생성을 위임하기 때문에 초기화할 수 있는 인스턴스(빈객체)가 존재하기 않기 때문이다!&lt;/del&gt;&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;상속을 받은 클래스인지 상속을 받지않은 클래스인지 자바스크립트가 어떻게 아는지 궁금했었는데 클래스에는 [[ConstructorKind]]라는 내부슬롯이 존재한다. 이때 슈퍼클래스는 &lt;strong&gt;base&lt;/strong&gt;, 서브클래스는 &lt;strong&gt;derived&lt;/strong&gt;로 구분한다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;연산자와 함께 호출되었을때 구분된다.)&lt;/p&gt;

&lt;p&gt;클래스에서 constructor를 정의하지 않았을때 다음과 같은 constructor가 암묵적으로 생성된다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 서브클래스에서 constructor를 정의하지 않았을때 super를 꼭 호출해야하므로 다음과 같은 constructor가 생성된다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;클래스는 생성자 함수를 이용한 프로토타입과 다른 방식이지만 거의 동일하게 동작한다. 하지만 개발자가 직관적으로, 명시적으로 코드를 작성해 상속을 구현하는 면에서 확실해보인다. 결국 개인적으로 프로토타입은 사용하기 어렵다고 느껴질 수 있지만 클래스는 프로토타입을 보다 쉽게 다룰 수 있는 방법으로 생각한다.&lt;/del&gt;&lt;/p&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="JavaScript" /><category term="Other" /><summary type="html">자바스크립트의 클래스(Class)</summary></entry><entry><title type="html">실행컨텍스트</title><link href="https://jjongbin.github.io/blog//other/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="실행컨텍스트" /><published>2021-12-14T00:00:00+09:00</published><updated>2021-12-14T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/">&lt;p&gt;&lt;del&gt;실행컨텍스트를 공부하면서 실행컨텍스트, 환경레코드, 렉시컬환경 등의 관계가 굉장히 복잡하게 얽혀있음을 알게 되었다. 그러다 문득 피보나치 수열의 경우에 실행컨텍스트는 어떤식으로 동작하는지가 궁금해졌다. 우선 실행컨텍스트를 공부하면서 알게 된 내용들을 정리해 보려고 한다.&lt;/del&gt;&lt;/p&gt;

&lt;h1 id=&quot;실행-컨텍스트&quot;&gt;실행 컨텍스트&lt;/h1&gt;

&lt;p&gt;자바스크립트의 동작원리를 담는 핵심 개념으로 간단히 말해서 코드의실행환경이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;실행컨텍스트를 생성하는 코드에는 네가지가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전역 코드: 전역에 존재하는 코드&lt;/li&gt;
  &lt;li&gt;함수 코드: 함수 내부에 존재하는 코드&lt;/li&gt;
  &lt;li&gt;eval 코드: eval 함수의 인수로 전달되어 실행되는 코드&lt;/li&gt;
  &lt;li&gt;모듈 코드: 모듈 내부에 존재하는 코드&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;간단한 코드를 기준으로 그림을 그리면서 설명을 추가하려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 코드가 실행이 되면 전역코드를 &lt;strong&gt;평가&lt;/strong&gt;하는 과정을 거친다.&lt;/p&gt;

&lt;p&gt;처음으로 &lt;strong&gt;실행 컨텍스트 스텍&lt;/strong&gt;에 &lt;strong&gt;전역 실행 컨텍스트&lt;/strong&gt; 생성되고, &lt;strong&gt;전역 렉시컬환경&lt;/strong&gt; 생성, &lt;strong&gt;전역 환경 레코드&lt;/strong&gt; 생성, &lt;strong&gt;객체 환경 레코드&lt;/strong&gt;, &lt;strong&gt;선언적 환경 레코드&lt;/strong&gt;가 생성된다.&lt;/p&gt;

&lt;p&gt;객체 환경 레코드에는 &lt;strong&gt;BindingObject&lt;/strong&gt;라는 객체와 연결되는데 이는 &lt;strong&gt;전역 객체&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;이때 평가과정에서는 선언문들만 먼저 실행이 되는데 해당 코드를 기준으로&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var&lt;/code&gt; 키워드로 선언된 전역 변수와 foo 함수 선언문이 먼저 평가된다.&lt;/p&gt;

&lt;p&gt;선언된 변수 및 함수는 전역 객체의 프로퍼티와 메서드가 된다 -&amp;gt; window 객체의 x, foo&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt; 키워드로 선언된 변수는 선언적 환경 레코드에 등록된다 이때 아직 할당이 되지 않고, 호이스팅이 동작하지 않는 것처럼 동작하기 때문에 알 수 없는 값이 존재하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트1.jpeg&quot; alt=&quot;실행컨텍스트1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 &lt;strong&gt;this가 바인딩&lt;/strong&gt;되는데 전역 렉시컬 환경의 [[GlobalThisValue]] 내부슬롯에 this가 바인딩된다.&lt;/p&gt;

&lt;p&gt;전역 코드에서의 this는 전역 객체를 가르키기 때문에 전역객체 window가 바인딩 된다.&lt;/p&gt;

&lt;p&gt;외부 렉시컬 환경 참조는 현재 평가중인 소스 코드를 포함하는 외부 소스 코드의 렉시컬 환경인 상위 스코프를 가르키는데 전역의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;이 할당된다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;전역 코드 평가 이후 전역 코드가 실행이 되게 되는데 이때 선언만 되었던 변수 값들에 값이 할당이 되게 된다!&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트2.jpeg&quot; alt=&quot;실행컨텍스트2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수코드의 경우 함수가 호출될때 함수 실행 컨텍스트가 생성이 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드의 마지막 부분에 foo함수를 호출하는데 이때 전역 코드의 실행을 일시 중단하고 foo함수로 제어권이 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;이때 함수 내부 코드가 평가된다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수 실행 컨텍스트&lt;/strong&gt;가 생성이 되고, &lt;strong&gt;함수 렉시컬 환경&lt;/strong&gt; 생성, &lt;strong&gt;함수 환경 레코드&lt;/strong&gt;가 생성된다&lt;/p&gt;

&lt;p&gt;함수도 마찬가지고 평가될때 선언문들이 먼저 등록이 된다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const x3 = 3;&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt; 키워드로 선언된 x3(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const x3&lt;/code&gt;)가 함수 환경 레코드에 등록이 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;함수의 매개변수, argument 객체, 함수 몸체 내부에서 선언된 식별자들이 함수 환경 레코드에 등록이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트3.jpeg&quot; alt=&quot;실행컨텍스트3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 this가 바인딩 되는데 이때 foo 함수는 일반함수로서 호출되었기 때문에 this는 전역 객체가 된다.&lt;/p&gt;

&lt;p&gt;함수의 외부 렉시컬 환경에 대한 참조는 자바스크립트 엔진이 함수 정의를 평가하고 함수 객체를 생성할때 &lt;strong&gt;실행중인 컨텍스트의 렉시컬 환경&lt;/strong&gt;을 &lt;strong&gt;함수 객체의 내부슬롯 [[Environment]]에 저장&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;이후 함수 렉시컬 환경에 있는 외부 렉시컬환경에 대한 참조는 이 함수의 &lt;strong&gt;내부슬롯 [[Environment]]를 참조&lt;/strong&gt;한다. 따라서 위 코드를 기준으로 foo 함수의 외부 렉시컬 환경에 대한 참조는 전역 렉시컬 환경을 가르킨다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트4.jpeg&quot; alt=&quot;실행컨텍스트4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;함수 내부 평가 이후 함수 코드를 실행하면서 함수 환경 레코드에 존재하는 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x3&lt;/code&gt;에는 3이 할당되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log(x3)&lt;/code&gt;가 실행되는데 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt; 메서드를 호출 즉, 함수 호출이기 때문에 또 다시 실행 컨텍스트가 만들어진다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;이때 `console` 객체는 window 객체가 만들어질때 내부에 존재하기 때문에 전역 객체(window)에서 `console`을 찾아 `log` 함수를 평가하는 과정을 거친다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;내부적으로 인수를 받기 때문에 해당 인수가 log 함수 환경 레코드에 등록되기 전에 log 함수 실행 컨텍스트가 생성되고, 함수 렉스컬 환경, 함수 환경 레코드들이 생성이 되고 선언문들이 함수 환경 레코드에 등록이 된다.&lt;/p&gt;

&lt;p&gt;(내부적으로 console.log로 찍을 변수를 xxx라는 변수라고 가정함 - argument를 이용해서 출력할지도 모르겠다는 생각을 한다!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트5.jpeg&quot; alt=&quot;실행컨텍스트5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;log 함수 렉시컬 환경의 [[ThisValue]]에는 전역객체 window의 console 객체가 바인딩 된다.&lt;/p&gt;

&lt;p&gt;외부 렉시컬 환경에 대한 참조에는 현재 실행중인 실행 컨텍스트가 foo 함수의 실행 컨텍스트 이므로 foo함수의 렉시컬 환경을 가르키게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트6.jpeg&quot; alt=&quot;실행컨텍스트6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;log 함수의 평가가 종료되고 실행되면서 xxx에는 인수로 넣어준 3이 할당이 되고 내부 동작으로 인해 console에 3이라고 찍히게 된다.&lt;/p&gt;

&lt;p&gt;log함수가 종료가 되면 log 함수의 실행 컨텍스트가 실행 컨텍스트 스텍에서 제거된다. 이때 렉시컬 환경이 바로 사라지지는 않는데 이는 클로저와 연관된다.&lt;/p&gt;

&lt;p&gt;log 함수의 실행 컨텍스트가 제거되고, foo 함수도 종료되므로 실행 컨텍스트 스텍에서 제거, 전역 실행 컨텍스트도 마찬가지로 제거되므로 실행 컨텍스트 스텍에는 아무것도 남지 않게 되고 이는 코드의 종료를 말한다.&lt;/p&gt;

&lt;p&gt;결국 실행 컨텍스트 스텍에서 가장 상단에 존재하는 실행 컨텍스트가 현제 실행중인 실행 컨텍스트이고, 실행 컨텍스트가 존재할때 코드가 실행됨을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 과정들을 거치면서 자바스크립트 코드가 실행이 되는데 그렇다면 피보나치 수열의 경우 반복해서 재귀함수를 호출하는데 이때는 어떻게 되는지 찾아봤다.&lt;/p&gt;

&lt;p&gt;피보나치 수열은 0과 1로 시작해서 다음 피보나치 수열의 수는 앞의 두 수를 더한 값이 된다.&lt;/p&gt;

&lt;p&gt;간단하게 F로 나타내서 4단계의 피보나치 수열로 그림을 그려보면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/fibonacci.jpeg&quot; alt=&quot;fibonacci&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트를 이용해서 피보나치를 간단하게 구현했을때는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;문과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debugger&lt;/code&gt;를 이용해서 피보나치 함수가 크롬 브라우저에서 실행될때 실행 컨텍스트(call stack)가 얼마나 쌓이는지 확인해보았다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;debugger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4번째 수를 찾을때 n이 2일때를 확인해보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/fibonacci_callstack1.png&quot; alt=&quot;fibonacci_callstack1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이어서 10번째 수를 찾을때 n이 2일때를 확인해보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/fibonacci_callstack2.png&quot; alt=&quot;fibonacci_callstack2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;콜스텍이 게속 만들어 진 것을 알 수 있었는데 그렇다면 왜 그런걸까를 생각해보았다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;피보나치 수열 코드에서 먼저 전역 코드가 평가가 되면서 실행 컨텍스트 스텍에 전역 실행 컨텍스트, 전역 렉시컬환경, 전역 환경 레코드, 객체 환경 레코드, 선언적 환경 레코드가 생성되고, &lt;strong&gt;전역 객체(window)의 메서드로 fibonacci 함수가 등록&lt;/strong&gt;된다. 또한 this 바인딩은 전역객체가, 외부 렉시컬 환경에 대한 참조에는 null이 할당될 것이다.&lt;/p&gt;

&lt;p&gt;이후 피보나치 함수가 호출이 되면서 피보나치 함수 실행 컨텍스트가 만들어지고 내부적으로 함수를 호출하면서 반환한다&lt;/p&gt;

&lt;p&gt;n이 2인 경우에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debugger&lt;/code&gt;을 하므로 다음 그림과 같이 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/fibonacci_debugger.jpeg&quot; alt=&quot;fibonacci_debugger&quot; /&gt;&lt;/p&gt;

&lt;p&gt;F(4), F(3), F(2) 순서로 호출이 된다. 따라서 결국 실행컨텍스트는 다음과 같이 구성된다.(F(4), F(3), F(2) 순서로 실행 컨텍스트 스텍에 각각의 실행 컨텍스트가 생성된다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/실행컨텍스트_fibonacci.jpeg&quot; alt=&quot;실행컨텍스트_fibonacci&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 컨텍스트를 그림으로 그리면서 공부를 하니 보다 쉽게 접근할 수 있었다고 생각한다. 아직도 굉장히 어려운 개념이지만 스코프, 클로저 등 많은 개념들이 연관되어 있기 때문에 이상함을 느낄때 그림을 그려보면서 잘못된 부분을 찾아가는 것도 좋은 방법이라는 생각이 들었다!&lt;/p&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="JavaScript" /><category term="Other" /><summary type="html">피보나치 수열 구현의 실행 컨텍스트!</summary></entry><entry><title type="html">자바스크립트 객체의 변경방지 - 불변성</title><link href="https://jjongbin.github.io/blog//other/property_attribute/" rel="alternate" type="text/html" title="자바스크립트 객체의 변경방지 - 불변성" /><published>2021-12-07T00:00:00+09:00</published><updated>2021-12-07T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/property_attribute</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/property_attribute/">&lt;p&gt;만약 변하지 않아야 하는 값들이 의도처럼 수정되지 않아야 하지만 수정된다면 의도와 다른 결과가 출력되거나 에러를 일으킬 가능성이 크다.&lt;/p&gt;

&lt;p&gt;이때 값들이 변하지 않는 것을 불변하다고 한다 즉 변하지 않는 특성을 불변성이라고 한다.&lt;/p&gt;

&lt;p&gt;객체를 다루는데에도 외부의 객체를 수정하지 않도록 하거나, 변하지 않도록 하기 위해서 의도적으로 객체의 프로퍼티가 변경되지 않도록 불변성을 줄 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체 변경 방지&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventExtensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 객체 밀봉&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;seal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 객체 동결&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;freeze&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 Object 함수의 정적메서드들이 대표적인 것들이다.&lt;/p&gt;

&lt;p&gt;해당 메서드들에 대해서 공부하다가 의문점을 가지고 질문을 드려본적이 있는데 이런 부분들에 대해서 이야기 하기전에 &lt;strong&gt;프로퍼티 어트리뷰트&lt;/strong&gt;를 알아야 한다&lt;/p&gt;

&lt;h1 id=&quot;프로퍼티-어트리뷰트&quot;&gt;프로퍼티 어트리뷰트&lt;/h1&gt;

&lt;p&gt;자바스크립트 엔진은 우리가 프로퍼티를 만들때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다&lt;/p&gt;

&lt;h2 id=&quot;내부-슬롯과-내부-메서드&quot;&gt;내부 슬롯과 내부 메서드&lt;/h2&gt;

&lt;p&gt;내부 슬롯과 내부 메서드는 자바스크립트 엔징의 구현 알고히즘을 설명하기 위햐 ECMAScript 사양에서 사용하는 의사 프로퍼티 및 의사 메서드이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[ ]]&lt;/code&gt; 이중 대괄호를 사용해서 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음은 ECMAScript를 참고한 데이터 프로퍼티의 내부 슬롯이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/dataProperty.png&quot; alt=&quot;data property attribute&quot; /&gt;
&lt;a href=&quot;https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-attributes&quot;&gt; 출처 - tc39&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터-프로퍼티와-접근자-프로퍼티&quot;&gt;데이터 프로퍼티와 접근자 프로퍼티&lt;/h2&gt;

&lt;p&gt;프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분될 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;데이터 프로퍼티&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;키와 값으로 구성된 일반적인 프로퍼티&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;접근자 프로퍼티&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 호풀되는 접근자 함수로 구성된 프로퍼티&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;데이터-프로퍼티의-어트리뷰트&quot;&gt;데이터 프로퍼티의 어트리뷰트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 어트리뷰트&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Value]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Writable]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 가진다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Enumerable]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 가진다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Configurable]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 가진다. (삭제와 프로퍼티 재정의)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;접근자-프로퍼티의-어트리뷰트&quot;&gt;접근자 프로퍼티의 어트리뷰트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 어트리뷰트&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Get]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수(getter 함수를 호출)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Set]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수(setter 함수를 호출)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Enumerable]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 가진다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Configurable]]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 가진다. (삭제와 프로퍼티 재정의)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이런 프로퍼티 어트리뷰트를 확인하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.getOwnPropertyDescriptors(obj)&lt;/code&gt;를 이용해 각 프로퍼티의 어트리뷰트를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 프로퍼티 어트리뷰트를 수정해서 객체를 불변하게 만들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;객체-확장-금지&quot;&gt;객체 확장 금지&lt;/h2&gt;

&lt;p&gt;객체에 새로운 프로퍼티가 추가되는 것을 방지한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체 확장 금지&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventExtensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로퍼티의 추가는&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;동적추가&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.defineProperty&lt;/code&gt; 메서드&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;를 통해서 할 수 있는데 이때 이러한 동작을 불가능하게 한다.&lt;/p&gt;

&lt;p&gt;확장이 가능한 객체인지 확인할때는 다음과 같은 메서드를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isExtensible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;객체-밀봉&quot;&gt;객체 밀봉&lt;/h2&gt;

&lt;p&gt;프로퍼티 추가, 삭제, 재정의를 금지한다 → 읽기와 쓰기만 가능&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체 밀봉&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;seal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 밀봉된 객체의 프로퍼티 어트리뷰트 &lt;strong&gt;[[Configurable]]&lt;/strong&gt;은 &lt;strong&gt;false&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;따라서 프로퍼티의 삭제가 불가능하고 프로퍼티 어트리뷰트를 재정의 할 수 없다.&lt;/p&gt;

&lt;p&gt;밀봉된 객체인지 확인할때는 다음과 같은 메서드를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isSealed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;객체-동결&quot;&gt;객체 동결&lt;/h2&gt;

&lt;p&gt;프로퍼티 추가, 삭제, 재정의, 갱신을 금지한다 → 읽기와 가능&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체 밀봉&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;freeze&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 동결된 객체의 프로퍼티 어트리뷰트 &lt;strong&gt;[[writeable]]&lt;/strong&gt;과 &lt;strong&gt;[[Configurable]]&lt;/strong&gt;은 &lt;strong&gt;false&lt;/strong&gt;이다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[Value]]&lt;/code&gt;의 값을 변경할 수 없고 프로퍼티 삭제, 프로퍼티 어트리뷰트의 재정의가 불가능하다.&lt;/p&gt;

&lt;p&gt;동결된 객체인지 확인할때는 다음과 같은 메서드를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isfrozen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;이때 내가 떠오른 의문점은 바로 다음과 같았다.&lt;/u&gt;&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;아니?! 왜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.seal()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.freeze()&lt;/code&gt;들은 프로퍼티 어트리뷰트의 값을 변경해서 명시적으로 각 기능들이 동작하지 않고록 금지시키는 것은 알겠는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.preventExtensions()&lt;/code&gt;는 바꿔주는게 없는건가? 그렇다면 자바스크립트 엔진이 프로퍼티를 추가할 수 있는지 없는지 어떻게 알지?&lt;/p&gt;

&lt;p&gt;결론부터 이야기하자면 애초에 말이 안되는 의문이었다. &lt;u&gt;프로퍼티 어트리뷰트는 각 프로퍼티에 존재하는 값들인데 객체에 프로퍼티를 추가할 경우 프로퍼티의 내부슬롯을 확인하는 것이 아니라 다른 부분(객체의 측면)에서 자바스크립트 엔진이 내부적으로 확인한다는 것이 스스로의 결론이었다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;기나긴 시간 동안의 구글링후에 tc39에서 해당 내용을 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/isExtensible.png&quot; alt=&quot;isExtensible&quot; /&gt;
&lt;img src=&quot;../../imgs/isExtensible2.png&quot; alt=&quot;isExtensible&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.isExtensible(obj)&lt;/code&gt; 함수가 매개변수와 함께 호출되었을때, 타입이 Object가 아니면 false를 반환하고 Object일때 추상연산을 수행하는데 &lt;strong&gt;해당 객체의 내부 메서드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[isExtensible]]&lt;/code&gt;를 호출&lt;/strong&gt;한다&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;[[IsExtensible]] : Boolean을 return한다. 해당 객체에 추가적으로 속성을 추가할 수 있는지 확인하는 메소드&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 메서드들을 사용하는 것은 객체가 의도치않게 변경되는 것을 방지할 수 있으며, 객체에 불변성을 줌으로서 안전하도록 만든다. 하지만 이런 메소드들에도 한계가 존재하는데 얕은 복사처럼 한단계에만 적용이 된다는 것이다. 따라서 중첩 객체의 경우 재귀적으로 내부의 중첩객체들에 적용을 해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 객체의 변경을 방지하는 메서드들이 어떤 상태로 변경되는지 표로 정리하자면 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;메서드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 추가&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 삭제&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 값 읽기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 값 쓰기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;프로퍼티 어트리뷰트 재정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;객체 확장 금지&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.preventExtensions&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;객체 밀봉&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.seal&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;객체 동결&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.freeze&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="JavaScript" /><category term="Other" /><summary type="html">Object.preventExtensions(), Object.seal(), Object.freeze()</summary></entry><entry><title type="html">유사배열객체</title><link href="https://jjongbin.github.io/blog//other/%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4%EA%B0%9D%EC%B2%B4/" rel="alternate" type="text/html" title="유사배열객체" /><published>2021-11-28T00:00:00+09:00</published><updated>2021-11-28T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4%EA%B0%9D%EC%B2%B4</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4%EA%B0%9D%EC%B2%B4/">&lt;p&gt;&lt;del&gt;강사님의 수업을 듣다가 유사객체라는 말씀을 하셨는데 유사객체에는 무엇이 있고 어떻게 사용될 수 있는지 궁금해졌다. 오늘은 유사객체에 대해서 공부를 해보려고 한다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;유사객체는 유사배열, 유사객체, 유사배열객체 등 다양한 이름으로 불리워진다.(이하 내용에서는 유사배열객체라고 설명하려고 한다!)&lt;/p&gt;

&lt;p&gt;배열과 유사하게 동작되는 유사배열객체에 대해서 작성하기 전에 먼저 배열에 대해서 간략하게 정리했다.&lt;/p&gt;

&lt;h1 id=&quot;배열&quot;&gt;배열&lt;/h1&gt;

&lt;p&gt;배열이란 인덱스를 가지고, 자료들을 담는자료구조이다. 각각의 데이터들은 순차적으로 저장되고 중복이 가능하다.&lt;/p&gt;

&lt;p&gt;다양한 자료형의 데이터들을 배열에 넣을 수 있는데 보통 같은 자료형의 데이터를 다루는 경우가 많다.&lt;/p&gt;

&lt;p&gt;배열은 다른 자료구조들과는 다른게 &lt;strong&gt;인덱스&lt;/strong&gt;가 존재하는데 인덱스를 사용해서 각각의 자료에 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// C&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// E&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배열내 자료의 순서에 따라 인덱스가 정해지게 된다. 인덱스는 &lt;u&gt;0부터 시작해서 배열 내 자료들의 개수 - 1&lt;/u&gt;까지로 지정된다.&lt;/p&gt;

&lt;h2 id=&quot;1-배열의-사용선언&quot;&gt;1. 배열의 사용(선언)&lt;/h2&gt;

&lt;p&gt;배열을 선언하는데는 두가지 방식이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;키워드와 생성자 함수&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 키워드와 함께 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt;생성자 함수를 이용하는 방법이다. 배열의 길이를 기존에 지정해 줄 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill&lt;/code&gt; 메서드를 사용하면 지정된 길이만큼 초기 데이터를 넣어줄 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;배열의&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;길이&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 추가적으로 배열에 데이터에 기본값을 셋팅하는 방법(fill)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 배열의 길이 n만큼 0으로 채워라&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;리터럴 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;리터럴을 사용해서 간단하게 배열을 선언할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 배열을 생성&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내부의 데이터를 넣어줄 수도 있다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-배열의-메서드&quot;&gt;2. 배열의 메서드&lt;/h2&gt;

&lt;h3 id=&quot;1-push&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;선언된 배열에 데이터를 넣어줄 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-shift-unshift&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshift()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;선언된 배열의 첫번째 값을 꺼내거나(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift()&lt;/code&gt;) 첫번째에 집어넣을 수 있다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshift()&lt;/code&gt;)&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [2, 3]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unshift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [10, 2, 3]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-pop&quot;&gt;3. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;선언된 배열의 마지막 인덱스에 해당하는 값을 꺼낼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-그외-배열을-다루는데-유용한-배열의-메서드들&quot;&gt;4. 그외 배열을 다루는데 유용한 배열의 메서드들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;배열의 각 데이터를 합쳐주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;인자를 구분자로 문자열을 배열로 나눠주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;배열의 순서를 거꾸로 만들어주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reverse()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;지정한 부분을 삭제해주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;splice()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;특정부분을 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slice()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;값을 찾아 인덱스를 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;이 외에도 수많은 메서드들이 존재하지만 이후에 포스팅하려고 한다!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 배열은 수많은 메서드들이 존재하고 많이 사용하게 되는 자료구조이다.&lt;/p&gt;

&lt;h1 id=&quot;유사배열객체&quot;&gt;유사배열객체&lt;/h1&gt;

&lt;p&gt;자바스크립트에는 유사배열객체가 존재하는데 유사배열객체는 배열은 아니지만 배열처럼 동작하는 것을 말한다. 심지어 JS의 객체를 이용해서 배열처럼 동작하도록 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로퍼티 키로 인덱스를 입력하고, 프로퍼티 값으로 데이터를 입력해준다. 해당 객체는 배열이 아니지만 배열처럼 동작하는 유사배열객체이다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.form()&lt;/code&gt;을 사용하면 실제 배열로 만들어 반환해준다.)&lt;/p&gt;

&lt;p&gt;유사배열이 되기 위해서는 몇가지 조건이 있는데 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;length가 반드시 존재해야 한다&lt;/li&gt;
  &lt;li&gt;index가 0부터 시작해서 1씩 증가해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이외에 대표적으로 함수의 arguments, HTMLCollection NodeList들이 있다. 또한 문자열도 유사배열객체처럼 동작하는 것을 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ABCDE&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// C&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// E&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열은 원시값인데 인덱스를 이용해서 순서에 해당하는 문자를 반환해준다.&lt;/p&gt;

&lt;p&gt;또한 문자열에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;length&lt;/code&gt;라는 프로퍼티가 존재할 수 없는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문자열변수.length&lt;/code&gt;를 입력했을때 제대로 동작한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;문자열 뒤에 (.)을 붙이면 문자열은 유사배열객체가 된다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.length&lt;/code&gt;를 사용할 수 있고 이후 다시 문자열로 돌려준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수의 arguments&lt;/strong&gt;같은 경우에는 함수의 인자로 넣어준 값들을 arguments에 모두 저장하게 되는데 이때 arguments는 배열은 아니지만 유사배열객체이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jongbin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [Arguments] { &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5 }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ABCDE&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 결과
A
B
C
D
E
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹시나 싶어서 map 메서드는 사용해봤는데 역시 사용할 수 없었다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TypeError: str.map is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;또한 DOM에서 HTMLCollection과 NodeList를 찾아서 출력해보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/HTMLCollection.png&quot; alt=&quot;HTMLCollection&quot; /&gt;
&lt;img src=&quot;../../imgs/HTMLCollection.png&quot; alt=&quot;NodeList&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTMLCollection와 NodeList를 봤을때 배열처럼 느껴지지만 배열인지 확인하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.isArray&lt;/code&gt;를 사용해서 확인해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;가 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/isarray.png&quot; alt=&quot;isarray&quot; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 유사배열객체임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;해당 객체를 for..of문을 사용해서 각각 출력했을때는 다음과 같이 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/forof.png&quot; alt=&quot;forof&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 유사배열객체에 사용가능한 배열의 메서드들이 있지만 사용할 수 없는 메서드들도 존재하고 유사배열객체는 배열이 아니기 때문에 주의할 필요가 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;유사배열객체를 겪는 일이 생각보다 많을거라고 예상하는데 유사배열객체를 보고 배열인지 헷갈린다면 꼭 디버그해보고(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.isArray()&lt;/code&gt; 사용!) 확실하게 판단할 필요가 있어보인다.&lt;/p&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="Other" /><summary type="html">배열과 유사배열객체, 유사배열, 유사객체</summary></entry><entry><title type="html">BigInt</title><link href="https://jjongbin.github.io/blog//other/bigint/" rel="alternate" type="text/html" title="BigInt" /><published>2021-11-24T00:00:00+09:00</published><updated>2021-11-24T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//other/bigint</id><content type="html" xml:base="https://jjongbin.github.io/blog//other/bigint/">&lt;p&gt;풀었던 백준문제: &lt;a href=&quot;https://www.acmicpc.net/problem/13305&quot;&gt;백준 13305&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;del&gt;이전에 백준에서 문제를 풀면서 BigInt를 사용하게 된 경험이 있는데 최근 강의를 수강하면서 BigInt가 ECMA에 비교적 최근에 추가된 내용이기 때문에 궁금해서 조사를 해봤다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트의 변수 타입(정확히는 값 타입)에는 원시타입에 속하는 Number, String, boolean, undefined, Null, Symbol과 객체타입에 속하는 Object로 총 7가지가 존재한다.&lt;/p&gt;

&lt;p&gt;하지만 최근 ECMA Scropt 2020의 ES11에서 &lt;strong&gt;BigInt&lt;/strong&gt;라는 새로운 숫자 타입이 생겨나게 되었다.&lt;/p&gt;

&lt;p&gt;기존의 자바스크립트는 64비트의 IEEE 754(널리 사용되는 부동소수점 표기 표준)을 따르기 때문에 숫자를 표현할때 &lt;strong&gt;2&lt;sup&gt;53&lt;/sup&gt; - 1&lt;/strong&gt; 까지만 안전하게 표현할 수 있었다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;이 이상의 길이의 숫자를 표현하게 되었을때 근사치로 계산을 하기 때문에 오류는 발생하지 않지만 정확한 값이 나오지 않는다.&lt;/p&gt;

&lt;p&gt;하지만 BigInt를 이용하면 그 이상의 숫자를 표현할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;bigint&quot;&gt;BigInt&lt;/h1&gt;

&lt;p&gt;BigInt는 이름에서부터 알 수 있듯이 큰 수를 표현하는 방법이다. MDN에서 BigInt를 어떻게 설명하는지 확인해보니 다음과 같았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;MDN - BigInt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;bigint-사용-방법&quot;&gt;BigInt 사용 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;정수리터럴 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;을 붙혀서 BigInt로 변환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;함수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigInt()&lt;/code&gt;를 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bigint를-number로-변환&quot;&gt;BigInt를 Number로 변환&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Number(BigInt형);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;주의사항&quot;&gt;주의사항&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;내장객체 Math 사용이 불가능하다.&lt;/li&gt;
  &lt;li&gt;Number 타입과의 연산이 불가능하다 (BigInt타입끼리만 연산가능!)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 30n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mdn-권장사항&quot;&gt;MDN 권장사항&lt;/h2&gt;

&lt;p&gt;BigInt를 무작정 사용하기보다 BigInt를 Number로 변환하는 과정에서 정확성이 떨어질 수 있기때문에 2&lt;sup&gt;53&lt;/sup&gt; - 1 이상이 될것이라고 예측될 때 사용하는 것이 좋다.&lt;/p&gt;

&lt;h2 id=&quot;추가적으로&quot;&gt;추가적으로!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0n&lt;/code&gt;은 falsy한 값이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1n === 1&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1n == 1&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ture&lt;/code&gt; → 타입은 다르지만 같은 타입인 경우 같은 값!&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typeof 10n&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigInt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="Other" /><category term="Other" /><summary type="html">자바스크립트의 BigInt</summary></entry><entry><title type="html">ASCII, 유니코드</title><link href="https://jjongbin.github.io/blog//cs/ascii_unicode/" rel="alternate" type="text/html" title="ASCII, 유니코드" /><published>2021-11-23T00:00:00+09:00</published><updated>2021-11-23T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//cs/ascii_unicode</id><content type="html" xml:base="https://jjongbin.github.io/blog//cs/ascii_unicode/">&lt;p&gt;컴퓨터는 사람들이 말하는 a, b, c같은 문자를 그대로 이해할 수 없다. 따라서 컴퓨터에게 ~는 a이다 라고 알려줘야 하는데 이때 컴퓨터마다 표현방법이 다르다면 혼란이 있을 수 있다. 따라서 이를 국제적으로 표준화했다.&lt;/p&gt;

&lt;h1 id=&quot;아스키코드ascii&quot;&gt;아스키코드(ASCII)&lt;/h1&gt;

&lt;p&gt;1963년 미국 국립 표준 협회(ANSI)에서 표준화한 정보교환용 7비트 부호체계&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ASCII: American Standard Code for Information Interchange&lt;/li&gt;
  &lt;li&gt;7비트로 구성되기 때문에 128개까지 표현이 가능하다.&lt;/li&gt;
  &lt;li&gt;000(0x00) ~ 127(0x7f)&lt;/li&gt;
  &lt;li&gt;문자를 나타내는 7비트 + 오류 검사 1비트(페리티 비트) = 총 8비트&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice&quot;&gt;- 패리티 비트(Parity Bit)&lt;br /&gt;
정보를 전달하는 과정에서 오류가 있었는지 확인하는 비트로 데이터비트 중 1의 개수를 기준으로 짝수/홀수를 나눈다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/ascii.jpeg&quot; alt=&quot;ASCII&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;65부터 대문자 알파벳&lt;/li&gt;
  &lt;li&gt;97부터 소문자 알파벳&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;유니코드&quot;&gt;유니코드&lt;/h1&gt;

&lt;p&gt;아스키코드로 알파벳은 표현할 수 있지만 나아가 다른 국가의 언어를 표기하는데는 무리가 있다.(7비트는 2&lt;sup&gt;7&lt;/sup&gt;까지만 표현가능 === 128)&lt;/p&gt;

&lt;p&gt;따라서 2비트를 사용해서 더 많은 문자를 표현할 수 있는 유니코드가 등장하게 되었다.(2&lt;sup&gt;16&lt;/sup&gt;까지 표현가능 === 65526)&lt;/p&gt;

&lt;p&gt;유니코드는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이며, 유니코드 협회(Unicode Consortium)가 제정한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://unicode-table.com/kr/#basic-latin&quot;&gt;유니코드 백과사전&lt;/a&gt;&lt;/p&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="CS" /><category term="CS" /><summary type="html">아스키코드와 유니코드</summary></entry><entry><title type="html">웹 접근성</title><link href="https://jjongbin.github.io/blog//etc/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1/" rel="alternate" type="text/html" title="웹 접근성" /><published>2021-10-31T00:00:00+09:00</published><updated>2021-10-31T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//etc/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1</id><content type="html" xml:base="https://jjongbin.github.io/blog//etc/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1/">&lt;h1 id=&quot;wcag&quot;&gt;WCAG&lt;/h1&gt;

&lt;p&gt;WCAG는 Web Content Accessibility Guideline의 약자로 웹사이트 또는 애플리케이션에서 충족해야 하는 기준을 정의해 장애, 비장애의 사용자가 보다 쉽게 이용할 수 있도록 준수해야 하는 지침이다&lt;/p&gt;

&lt;p&gt;WCAG는 크게 네가지의 대분류로 나뉠 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인식의 용이성(Perceivable)&lt;/li&gt;
  &lt;li&gt;운용의 용이성(Operable)&lt;/li&gt;
  &lt;li&gt;이해의 용이성(Understandable)&lt;/li&gt;
  &lt;li&gt;견고성(Robust)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-인식의-용이성&quot;&gt;1. 인식의 용이성&lt;/h2&gt;
&lt;p&gt;사용자가 웹에서 제공하는 모든 콘텐츠를 모두 동등하게 인식할 수 있어야 한다 (웹사이트를 이루는 요소들을 명확하게 알 수 있도록 해야한다)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 콘텐츠는 대체할 수 있는 수단을 가져야 한다
    &lt;ul&gt;
      &lt;li&gt;이미지 또는 오디오 등에 대체텍스트를 제공&lt;/li&gt;
      &lt;li&gt;식별이 용이하도록 색상을 사용하거나 오디오제공과 같은 시각적, 청각적인 요소를 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-운용의-용이성&quot;&gt;2. 운용의 용이성&lt;/h2&gt;
&lt;p&gt;사용자가 웹 사이트의 인터페이스 구성요소 및 네비게이션을 모두 동등하게 운용할 수 있어야 한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;키보드를 통해서 모든 요소에 접근가능해야 한다&lt;/li&gt;
  &lt;li&gt;키보드를 통해 만료시간을 조정하거나, 컨텐츠의 동작을 관리할 수 있도록 해야 한다&lt;/li&gt;
  &lt;li&gt;발작 및 신체적 반응을 일으키지 않도록 설계해야 한다(초당 3회 번쩍이는 콘텐츠를 포함하지 않도록 한다)&lt;/li&gt;
  &lt;li&gt;키보드 이외의 다양한 입력장치를 통해 쉽게 조작할 수 있어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-이해의-용이성&quot;&gt;3. 이해의 용이성&lt;/h2&gt;
&lt;p&gt;사용자가 웹 사이트에서 제공하는 모든 요소들을 이해할 수 있어야 한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가독성이 좋아야 한다&lt;/li&gt;
  &lt;li&gt;생소한 단어, 약어, 독해, 발음에 대한 대응책을 갖춰야한다&lt;/li&gt;
  &lt;li&gt;예측가능한 방식으로 동작해야 한다(사용자가 생각하는 일반적인 방식으로 동작해야 한다)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-견고성&quot;&gt;4. 견고성&lt;/h2&gt;
&lt;p&gt;사용자가 웹 사이트를 이용하는데 기술의 영향을 받지 않아야 한다 (다양한 환경에서 동작하고 오류가 없어야 한다)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 사이트는 다양한 환경에서도 동일하게 동작되어야 한다&lt;/li&gt;
  &lt;li&gt;웹사이트를 구성하는데 문법적인 오류가 없어야 한다
    &lt;ul&gt;
      &lt;li&gt;웹 사이트를 구성하는 태그들의 시작태그, 종료태그가 온전해야 한다&lt;/li&gt;
      &lt;li&gt;속성이 중복되거나, id가 중복되지 않도록 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="ETC" /><category term="ETC" /><summary type="html">WCAG 웹 접근성 지침 요약</summary></entry><entry><title type="html">float</title><link href="https://jjongbin.github.io/blog//css/float/" rel="alternate" type="text/html" title="float" /><published>2021-10-26T00:00:00+09:00</published><updated>2021-10-26T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//css/float</id><content type="html" xml:base="https://jjongbin.github.io/blog//css/float/">&lt;h1 id=&quot;float&quot;&gt;float&lt;/h1&gt;
&lt;p&gt;float는 일반적은 요소들의 흐름에서 벗어나 “둥” 떠있는 것처럼 동작을 한다&lt;/p&gt;

&lt;p&gt;MDN의 float에 대한 설명을 참조하자면 다음과 같다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/float&quot;&gt;MDN - float&lt;/a&gt;&lt;br /&gt;
CSS 속성(property) float은 한 요소(element)가 보통 흐름(normal flow)으로부터 빠져 텍스트 및 인라인(inline) 요소가 그 주위를 감싸는 자기 컨테이너의 좌우측을 따라 배치되어야 함을 지정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;보통 흐름으로부터 빠져 자신의 부모를 기준으로 좌우측으로 정렬이 되는데 이때 어떤 부모요소의 자식요소들이 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt;로 지정이 되었다면 그 부모요소는 자신의 높이를 잃어버리게 된다(부모의 높이가 지정되어 있지 않고 내부 요소들의 내용에 따라 높이가 정해지는 경우)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/float.png&quot; alt=&quot;float&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽의 레이아웃에서 main 영역에 3개의 요소를 그림과 같이 배치하려고 할때 float를 이용한다면 파란색의 main 영역이 사라지는 것을 볼 수 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/clear.png&quot; alt=&quot;clear&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽의 레이아웃은 main 내부의 요소들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt;로 변경했을때의 현상이다 footer의 레이아웃까지 무너지는 것을 볼 수 있다(float가 가리는 텍스트는 옆으로 빠져나옴 “footer”라는 텍스트는 가려지지 않고 옆으로 빠짐) 이때 footer에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clear: both;&lt;/code&gt;를 사용하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt;가 footer에 영향을 미치는 것을 막을 수 있다&lt;/p&gt;

&lt;p&gt;하지만 문제는 여전히 &lt;strong&gt;main의 영역이 사라졌다는&lt;/strong&gt; 것이다 자식요소의 영역만큼 영역을 차지하는 부모요소는 자식요소가 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt;로 지정이 되면 높이를 잃어버린 것처럼 동작한다&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위한 방법으로 5가지정도가 존재한다&lt;/p&gt;

&lt;h2 id=&quot;-1-clearfix&quot;&gt;▷ 1. clearfix&lt;/h2&gt;
&lt;p&gt;main의 내용과 관련없는 clearfix라는 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;div&lt;/code&gt;요소를 임의로 생성한다&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;main&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;clearfix&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/main&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.clearfix&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하지만 의미없는 태그로 코드상으로 보여지기도 하므로 좋은 방법이 아니다&lt;/p&gt;

&lt;h2 id=&quot;-2-가상-요소-선택자&quot;&gt;▷ 2. 가상 요소 선택자&lt;/h2&gt;
&lt;p&gt;위에서 clearfix의 방법을 가상 요소 선택자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::after&lt;/code&gt;를 이용해서 작성하는 방법이다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가상 요소 선택자로 작성된 content는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inline&lt;/code&gt;이다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clear: both&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;요소에만 적용되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: block&lt;/code&gt;을 해준다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;main&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;group group3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/main&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;::after&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-3-overflow-hidden&quot;&gt;▷ 3. overflow: hidden;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;부모요소&lt;/strong&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;overflow: hidden&lt;/code&gt;를 이용해서 작성하는 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원래 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;overflow: hidden&lt;/code&gt;은 넘치는 요소를 숨김처리하는 역할을 하기 때문에 만약 자식요소가 부모요소의 크기를 넘어서게 되면 보이지 않게 되는 큰 단점이 존재한다&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/Guide/CSS/Block_formatting_context&quot;&gt;BFC(Block Format Context)&lt;/a&gt;를 생성하게 된다 → 자신만의 독립된 영역을 가지게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;BFC가 생성되는 조건&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;루트(root) 요소일 때&lt;/li&gt;
    &lt;li&gt;html는 웹 문서의 시작을 알리는 최상위 요소이다. 따라서 기본적으로 하위 요소들은 독립적인 레이아웃을 가질 수 있도록 되어 있다.
플로팅(Floating) 되었을 때&lt;/li&gt;
    &lt;li&gt;하위 요소가 선택적으로 float 속성 값을 none이 아닌 값을 가지게 되면 독립적인 레이아웃 환경을 갖는다.&lt;/li&gt;
    &lt;li&gt;position 속성이 absolute 또는 fixed로 적용되어 있을 때&lt;/li&gt;
    &lt;li&gt;하위 요소가 선택적으로 position 속성 값을 absolute 또는 fixed 값을 가지게 되면 독립적인 레이아웃 환경을 갖는다.&lt;/li&gt;
    &lt;li&gt;display 속성이 inline-block으로 적용되어 있을 때&lt;/li&gt;
    &lt;li&gt;하위 요소가 inline-block을 갖게되면 주변 inline 요소와 관계가 무너지면서 독립적인 공간을 형성하게 되므로 역시 독립적인 레이아웃 환경을 갖는다.&lt;/li&gt;
    &lt;li&gt;overflow 속성의 값이 visible 이외의 값으로 적용되어 있을 때&lt;/li&gt;
    &lt;li&gt;overflow 속성 값이 visible 이외의 값을 갖는 다는 것은 공간에 대한 크기 정의를 했다고 볼 수 있다. 그렇게 때문에 독립적인 공간을 형성한 것으로 볼 수 있으며 따라서 BFC를 요건을 가지고 있다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-4-flow-root&quot;&gt;▷ 4. flow-root&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: flow-root&lt;/code&gt;를 사용해서 작성하는 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;비교적 최근에 나온 속성이기 때문에 오래된 브라우저, IE에서는 &lt;strong&gt;작동이 되지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;부모요소에 적용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow-root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-5-부모요소의-float&quot;&gt;▷ 5. 부모요소의 float&lt;/h2&gt;
&lt;p&gt;자식요소가 모두 float로 지정되었을 때 부모요소까지도 float로 지정해주는 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부모의 float를 해제해 주어야 하므로 좋은 방법은 아니라는것이 개인적인 생각이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="CSS" /><category term="CSS" /><summary type="html">자식요소의 float를 해제하기</summary></entry><entry><title type="html">Main Menu</title><link href="https://jjongbin.github.io/blog//html/main_menu/" rel="alternate" type="text/html" title="Main Menu" /><published>2021-10-25T00:00:00+09:00</published><updated>2021-10-25T00:00:00+09:00</updated><id>https://jjongbin.github.io/blog//html/main_menu</id><content type="html" xml:base="https://jjongbin.github.io/blog//html/main_menu/">&lt;blockquote&gt;
  &lt;p&gt;웹 접근성 측면에서의 메뉴!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;️-메인메뉴-main-menu&quot;&gt;▶️ 메인메뉴 (Main Menu)&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;웹에서 메인메뉴는 사이트의 어느 한 부분으로 이동할 수 있도록 하며, 사이트의 전반적인 내용을 파악할 수 있다. 혹은 사이트내에서 내가 어느 위치에 있는지를 알 수 있다 따라서 웹을 이용하는 사람들이 모두 잘 이용할 수 있도록 &lt;strong&gt;웹접근성&lt;/strong&gt;이 좋아야 한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-웹-접근성이란&quot;&gt;▷ 웹 접근성이란?&lt;/h2&gt;
&lt;p&gt;고령자, 장애인, 비장애인에 상관없이 모든 사람이 동등하게 접근 가능하도록 하는 것을 말한다&lt;/p&gt;

&lt;p&gt;만약 시각이 불편한 사람이 웹을 이용하는 경우 스크린리더에 의지해 원하는 동작을 수행하게 될 것이다. 이때 시각이 불편한 사람도 웹애서 원하는 동작을 수행하는데 어려움이 없도록 스크린리더가 보다 정확하고 명확하게 정보를 전달하는 등의 기능을 하도록 해야 한다&lt;/p&gt;

&lt;p&gt;어느 포털사이트의 검색창이다 시각이 불편한 사람이라면 이 요소가 검색하는 부분인지를 전혀 알 수 없다 하지만 이 포털사이트에서 검색창을 구성한 코드를 살펴보게 되면 사용자에게는 보여지지 않지만 &lt;strong&gt;검색&lt;/strong&gt;이라고 표기를 해두고 스크린리더가 인식할 수 있게끔 작성해두었다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/search-bar.png&quot; alt=&quot;search&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 화면에는 보이지 않는 태그 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blind&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;검색&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 검색 돋보기 아이콘 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ico_search_submit&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-wai-aria&quot;&gt;▷ WAI-ARIA&lt;/h2&gt;
&lt;p&gt;(Web Accessibility Initiative - Accessible Rich Internet Application)&lt;/p&gt;

&lt;p&gt;웹을 이용하는 사람들이 증가함에 따라 여러 사람들이 웹을 이용하게 되었고 몸이 불편한 더 많은 사람들이 웹을 이용할 수 있도록 동적 웹 애플리케이션의 접근성을 보장해줄 수 있다 해당 요소의 역할, 동작 등을 명시해줌으로써 보다 명시적으로 웹을 이용할 수 있도록 한다 (html만으로는 부족한 웹 접근성을 보완, W3C에서 만듬)&lt;/p&gt;

&lt;p&gt;최근에 과제를 진행하면서 체크박스의 css를 변경해야할 일이 있었다.&lt;/p&gt;

&lt;p&gt;당시에는 웹 접근성에 대한 지식이 거의 없다시피했기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label&lt;/code&gt;을 사용해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkbox&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: none&lt;/code&gt;으로 두어 보이지 않도록 하고, 내가 원하는 모양대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lable&lt;/code&gt;의 css를 변경한 적이 있다.&lt;/p&gt;

&lt;p&gt;하지만 지금 생각해보면 웹 접근성을 위한 배려가 전혀 되있지 않은 코드를 작성했다고 생각한다 스크린리더를 이용하는 사람이 해당 부분을 접하게 되었다면 이건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lable&lt;/code&gt;이라는 요소일뿐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkbox&lt;/code&gt;인지 어떤 역할을 하는지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lable&lt;/code&gt;이라면 무엇을 가르키는지에 대한 명시가 전혀 존재하지 않았다&lt;/p&gt;

&lt;p&gt;이럴때 ARIA를 이용할 수 있다 ARIA를 이용하면 해당 요소가 어떻게 작동되는지를 명시해줄 수 있다 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;role=&quot;checkbox&quot;&lt;/code&gt;라고 속성으로 추가해주게 되면 이 속성이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkbox&lt;/code&gt;처럼 동작함을 브라우저에게 알려줄 수 있다 이외에도 대표적으로 다음과 같은 역할을 수행한다&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Role&lt;/td&gt;
      &lt;td&gt;UI에 포함된 특정 element의 기능을 정의&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Property&lt;/td&gt;
      &lt;td&gt;해당 컴포넌트의 특징이나 상황을 정의하며 속성명으로 ‘aria-*‘라는 접두사를 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;State&lt;/td&gt;
      &lt;td&gt;해당 컴퓨넌트의 상태 정보를 정의&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WAI-ARIA&lt;/strong&gt;를 이용해서 해당 요소의 동작을 정의하거나, 상황 밑 상태가 어떤지를 명시적으로 알려준다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이와 같은 방법들 또는 다른 방법들을 활용해서 웹 접근성을 높인 메인 메뉴를 작성하는 것이 좋다는 생각을 한다&lt;/p&gt;

&lt;p&gt;먼저 보통의 메뉴를 보게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;li&amp;gt;&lt;/code&gt;를 이용해서 메뉴를 작성하게 된다 이때 시멘틱적으로 메뉴를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt; 태그로 감싸는데 이는 검색엔진 최적화에도 도움이 된다 브라우저들이 데이터를 수집할 때 해당 부분이 navigator 역할을 한다는 것을 알려주게 되면 검색엔진이 데이터를 수집할 때 효율적으로 할 수 있고, 스크린리더를 이용하는 사용자들도 해당 요소가 어느역할을 할지 간략하게 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt; 태그로 메뉴부분을 감싸주고, 보이지 않는 (screen leader only)의 제목을 작성해주면 웹을 사용하기 어려운 사람들도 현재 부분이 “메뉴의 역할을 하는구나!” 라고 알 수 있을 것이다&lt;/p&gt;

&lt;p&gt;시멘틱태그를 이용해서 해당 부분이 어떤 부분인지 큰 대목으로 알 수 있다면 이전에 말한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-*&lt;/code&gt;를 이용해서 사용자가 원할하게 웹을 이용할 수 있도록 해줄 수 있다(시멘틱 요소와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;role&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria&lt;/code&gt;를 혼용해서 사용하는 것은 좋지 않다)&lt;/p&gt;

&lt;p&gt;메가 메뉴(메뉴가 굉장히 많은 드롭다운식의 메뉴)를 이용할 때 해달 요소에 마우스를 hover하거나, click해야 주메뉴 아래의 서브메뉴들을 확인할 수 있다 이때 서브메뉴를 열 수 있도록 하는 요소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-label=&quot;submenu-open&quot;&lt;/code&gt;와 같이 해당 요소가 어떤 역할을 하는지 알려주는 것이 좋다&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Test Page&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;nav&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;screen-leader-only&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;menu(nav)&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu-open&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;주 메뉴 1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 1-1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 1-2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 1-3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu-open&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;주 메뉴 2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 2-1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 2-2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submenu&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;a&amp;gt;&lt;/span&gt;서브메뉴 2-3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/nav&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;main&amp;gt;&lt;/span&gt; content &lt;span class=&quot;nt&quot;&gt;&amp;lt;/main&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;footer&amp;gt;&lt;/span&gt; footer&lt;span class=&quot;nt&quot;&gt;&amp;lt;/footer&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../../imgs/web-structure.png&quot; alt=&quot;web-structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드를 보면 시멘틱 요소(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;header&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;main&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;)를 이용해서 각 요소를 명시적으로 표현하고 주메뉴 하나 하나를 구성하는 요소(자바스크립트로 드롭다운 구현)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;button&lt;/code&gt; 태그로 작성했다 이때 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;button&lt;/code&gt;이 무슨 역할을 하는지 알 수 없는 상황이 있다. 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-label&lt;/code&gt;을 이용해서 브라우저가 이 태그가 무엇을 하는지 사용자에게 알려줄 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-label&lt;/code&gt;: 레이블로 사용할 문자열을 지정할 수 있다 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-label&lt;/code&gt;이 해당 요소의 텍스트보다 우선시됨)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-labelledby&lt;/code&gt;: 자신을 참조하는 요소를 가르킨다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aria-describedby&lt;/code&gt;: 기능을 설명하는 요소를 가르킨다(자신을 설명하는 lable을 가르킨다)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>원종빈</name><email>gghkdu2@gmail.com</email></author><category term="HTML" /><category term="HTML" /><summary type="html">메인메뉴의 구성과 웹 접근성</summary></entry></feed>